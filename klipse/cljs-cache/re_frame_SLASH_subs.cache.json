["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$re-frame.subs","~:imports",null,"~:requires",["^ ","~$re-frame.db","^;","~$re-frame.interop","^<","~$re-frame.loggers","^=","~$re-frame.utils","^>","~$re-frame.registrar","^?","~$trace","~$re-frame.trace","^A","^A"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$reagent-id","^<","~$console","^=","~$app-db","^;","~$dispose!","^<","~$add-on-dispose!","^<","~$make-reaction","^<","~$get-handler","^?","~$first-in-vector","^>","~$deref?","^<","~$ratom?","^<","~$debug-enabled?","^<","~$clear-handlers","^?","~$register-handler","^?"],"~:defs",["^ ","~$to-seq",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^8","~:line",181,"~:column",7,"~:end-line",181,"~:end-column",13,"~:arglists",["~#list",["~$quote",["^[",[["~$x"]]]]],"~:doc","Coerces x to a seq if it isn't one already"],"^7","~$re-frame.subs/to-seq","^U","re_frame/subs.cljc","^Y",13,"~:method-params",["^[",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^[",[null,null]],"^W",1,"~:variadic?",false,"^V",181,"~:ret-tag","~$clj","^X",181,"~:max-fixed-arity",1,"~:fn-var",true,"^Z",["^[",["^10",["^[",[["~$x"]]]]],"^11","Coerces x to a seq if it isn't one already"],"~$cache-and-return",["^ ","^S",null,"^T",["^ ","^U","^8","^V",42,"^W",7,"^X",42,"^Y",23,"^Z",["^[",["^10",["^[",[["~$query-v","~$dynv","~$r"]]]]],"^11","cache the reaction r"],"^7","~$re-frame.subs/cache-and-return","^U","re_frame/subs.cljc","^Y",23,"^13",["^[",[["^1<","^1=","~$r"]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",42,"^X",42,"^19",3,"^1:",true,"^Z",["^[",["^10",["^[",[["^1<","^1=","~$r"]]]]],"^11","cache the reaction r"],"~$deref-input-signals",["^ ","^S",null,"^T",["^ ","^U","^8","^V",188,"^W",8,"^X",188,"^Y",27,"~:private",true,"^Z",["^[",["^10",["^[",[["~$signals","~$query-id"]]]]]],"^1@",true,"^7","~$re-frame.subs/deref-input-signals","^U","re_frame/subs.cljc","^Y",27,"^13",["^[",[["^1A","^1B"]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",188,"^17",["^6",["~$cljs.core/LazySeq","^18","~$any","~$cljs.core/IList"]],"^X",188,"^19",2,"^1:",true,"^Z",["^[",["^10",["^[",[["^1A","^1B"]]]]]],"~$subscribe",["^ ","^S",null,"^T",["^ ","^U","^8","^V",74,"^W",7,"^X",74,"^Y",16,"^Z",["^[",["^10",["^[",[["~$query"],["^1H","^1="]]]]],"^11","Given a `query`, returns a Reagent `reaction` which, over\n  time, reactively delivers a stream of values. So in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` is an optional 3rd argument, which is a vector of further input\n  signals (atoms, reactions, etc), NOT values. This argument exists for\n  historical reasons and is borderline deprecated these days.\n\n  Example Usage:\n  --------------\n\n    (subscribe [:items])\n    (subscribe [:items \"blue\" :small])\n    (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (function) for the `query-id` given.\n\n  Hint\n  ----\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n     (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  De-duplication\n  --------------\n\n  XXX\n  ","~:top-fn",["^ ","^16",false,"~:fixed-arity",2,"^19",2,"^13",["^[",[["^1H"],["^1H","^1="]]],"^Z",["^[",[["^1H"],["^1H","^1="]]],"^15",["^[",[null,null]]]],"^7","~$re-frame.subs/subscribe","^U","re_frame/subs.cljc","^Y",16,"^1I",["^ ","^16",false,"^1J",2,"^19",2,"^13",["^[",[["^1H"],["^1H","^1="]]],"^Z",["^[",[["^1H"],["^1H","^1="]]],"^15",["^[",[null,null]]],"^13",["^[",[["^1H"],["^1H","^1="]]],"^14",null,"^1J",2,"^15",["^[",[null,null]],"^W",1,"^16",false,"~:methods",[["^ ","^1J",1,"^16",false,"~:tag",["^6",[null,"^1E"]]],["^ ","^1J",2,"^16",false,"^1M",["^6",[null,"^1E"]]]],"^V",74,"^X",74,"^19",2,"^1:",true,"^Z",["^[",[["^1H"],["^1H","^1="]]],"^11","Given a `query`, returns a Reagent `reaction` which, over\n  time, reactively delivers a stream of values. So in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` is an optional 3rd argument, which is a vector of further input\n  signals (atoms, reactions, etc), NOT values. This argument exists for\n  historical reasons and is borderline deprecated these days.\n\n  Example Usage:\n  --------------\n\n    (subscribe [:items])\n    (subscribe [:items \"blue\" :small])\n    (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (function) for the `query-id` given.\n\n  Hint\n  ----\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n     (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  De-duplication\n  --------------\n\n  XXX\n  "],"~$reg-sub",["^ ","^S",null,"^T",["^ ","^U","^8","^V",200,"^W",7,"^X",200,"^Y",14,"^Z",["^[",["^10",["^[",[["^1B","~$&","~$args"]]]]],"^11","For a given `query-id`, register two functions: a `computation` function and an `input signals` function.\n  \n  During program execution, a call to `subscribe`, such as `(subscribe [:sub-id 3 \"blue\"])`,\n  will create a new `:sub-id` node in the Signal Graph. And, at that time, re-frame\n  needs to know how to create the node.   By calling `reg-sub`, you are registering \n  'the template' or 'the mechanism' by which nodes in the Signal Graph can be created. \n\n  Repeating: calling `reg-sub` does not create a node. It only creates the template\n  from which nodes can be created later. \n  \n  `reg-sub` arguments are:  \n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways) \n    - a function which computes the value of this kind of node \n\n  The `computation function` is always the last argument supplied and it is expected to have the signature: \n    `(input-values, query-vector) -> a-value`\n  \n  When `computation function` is called, the `query-vector` argument will be the vector supplied to the \n  the `subscribe` which caused the node to be created. So, if the call was `(subscribe [:sub-id 3 \"blue\"])`, \n  then the `query-vector` supplied to the computaton function will be `[:sub-id 3 \"blue\"]`.\n\n  The arguments supplied between the `query-id` and the `computation-function` can vary in 3 ways, \n  but whatever is there defines the `input signals` part of the template, controlling what input \n values \"flow into\" the `computation function` gets when it is called. \n\n  `reg-sub` can be called in one of three ways, because there are three ways to define the input signals part.\n  But note, the 2nd method, in which a `signal-fn` is explicitly supplied, is the most canonical and instructive. The other \n  two are really just sugary variations. \n\n  1. No input signals given:\n      ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n\n     In the absence of an explicit `input-fn`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     is given as the 1st argument when `a-computation-fn` is called.   \n \n\n  2. A signal function is explicitly supplied:\n     ```clj\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here\n       computation-fn)\n     ```\n     \n     This is the most canonical and instructive of the three variations.\n     \n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many, or a map with the signals as the values.\n\n     The values from returned nominated signals will be supplied as the 1st argument to  \n     the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns, \n     this value will be either a singleton, sequence or map of them (paralleling\n     the structure returned by the `signal-fn`).\n\n     This example `signal-fn` returns a vector of input signals.\n       ```clj\n       (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n       ```\n     The associated computation function must be written\n     to expect a vector of values for its first argument:\n       ```clj\n       (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n         ....)\n        ```\n\n     If, on the other hand, the signal function was simpler and returned a singleton, like this:\n        ```clj\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n        ```\n     then the associated computation function must be written to expect a single value\n     as the 1st argument:\n        ```clj\n        (fn [a query-vec]       ;; 1st argument is a single value\n          ...)\n        ```\n \n     Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n       ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n     is the equivalent of using this\n     2nd variation and explicitly suppling a `signal-fn` which returns `app-db`:\n     ```clj\n     (reg-sub\n       :query-id\n       (fn [_ _]  re-frame/app-db)   ;; <--- explicit input-fn \n       a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n \n  3. Syntax Sugar\n\n     ```clj\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n         {:a a :b b}))\n     ```\n\n     This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n     `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n     If you supply only one pair a singleton will be supplied to the computation function, \n     as if you had supplied a `signal-fn` returning only a single value:\n\n     ```clj\n     (reg-sub\n       :a-sub\n       :<- [:a-sub]\n       (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n         ...))\n     ```\n\n  For further understanding, read `/docs`, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs\n  ","^1I",["^ ","^16",true,"^1J",1,"^19",1,"^13",[["^[",["^1B","^1O"]]],"^Z",["^[",[["^1B","~$&","^1O"]]],"^15",["^[",[null]]]],"^7","~$re-frame.subs/reg-sub","^U","re_frame/subs.cljc","^Y",14,"^1I",["^ ","^16",true,"^1J",1,"^19",1,"^13",[["^[",["^1B","^1O"]]],"^Z",["^[",[["^1B","~$&","^1O"]]],"^15",["^[",[null]]],"^13",[["^[",["^1B","^1O"]]],"^14",null,"^1J",1,"^15",["^[",[null]],"^W",1,"^16",true,"^1L",[["^ ","^1J",1,"^16",true,"^1M","^1E"]],"^V",200,"^17","^1E","^X",200,"^19",1,"^1:",true,"^Z",["^[",[["^1B","~$&","^1O"]]],"^11","For a given `query-id`, register two functions: a `computation` function and an `input signals` function.\n  \n  During program execution, a call to `subscribe`, such as `(subscribe [:sub-id 3 \"blue\"])`,\n  will create a new `:sub-id` node in the Signal Graph. And, at that time, re-frame\n  needs to know how to create the node.   By calling `reg-sub`, you are registering \n  'the template' or 'the mechanism' by which nodes in the Signal Graph can be created. \n\n  Repeating: calling `reg-sub` does not create a node. It only creates the template\n  from which nodes can be created later. \n  \n  `reg-sub` arguments are:  \n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways) \n    - a function which computes the value of this kind of node \n\n  The `computation function` is always the last argument supplied and it is expected to have the signature: \n    `(input-values, query-vector) -> a-value`\n  \n  When `computation function` is called, the `query-vector` argument will be the vector supplied to the \n  the `subscribe` which caused the node to be created. So, if the call was `(subscribe [:sub-id 3 \"blue\"])`, \n  then the `query-vector` supplied to the computaton function will be `[:sub-id 3 \"blue\"]`.\n\n  The arguments supplied between the `query-id` and the `computation-function` can vary in 3 ways, \n  but whatever is there defines the `input signals` part of the template, controlling what input \n values \"flow into\" the `computation function` gets when it is called. \n\n  `reg-sub` can be called in one of three ways, because there are three ways to define the input signals part.\n  But note, the 2nd method, in which a `signal-fn` is explicitly supplied, is the most canonical and instructive. The other \n  two are really just sugary variations. \n\n  1. No input signals given:\n      ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n\n     In the absence of an explicit `input-fn`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     is given as the 1st argument when `a-computation-fn` is called.   \n \n\n  2. A signal function is explicitly supplied:\n     ```clj\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here\n       computation-fn)\n     ```\n     \n     This is the most canonical and instructive of the three variations.\n     \n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many, or a map with the signals as the values.\n\n     The values from returned nominated signals will be supplied as the 1st argument to  \n     the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns, \n     this value will be either a singleton, sequence or map of them (paralleling\n     the structure returned by the `signal-fn`).\n\n     This example `signal-fn` returns a vector of input signals.\n       ```clj\n       (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n       ```\n     The associated computation function must be written\n     to expect a vector of values for its first argument:\n       ```clj\n       (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n         ....)\n        ```\n\n     If, on the other hand, the signal function was simpler and returned a singleton, like this:\n        ```clj\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n        ```\n     then the associated computation function must be written to expect a single value\n     as the 1st argument:\n        ```clj\n        (fn [a query-vec]       ;; 1st argument is a single value\n          ...)\n        ```\n \n     Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n       ```clj\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n     is the equivalent of using this\n     2nd variation and explicitly suppling a `signal-fn` which returns `app-db`:\n     ```clj\n     (reg-sub\n       :query-id\n       (fn [_ _]  re-frame/app-db)   ;; <--- explicit input-fn \n       a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n     ```\n \n  3. Syntax Sugar\n\n     ```clj\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n         {:a a :b b}))\n     ```\n\n     This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n     `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n     If you supply only one pair a singleton will be supplied to the computation function, \n     as if you had supplied a `signal-fn` returning only a single value:\n\n     ```clj\n     (reg-sub\n       :a-sub\n       :<- [:a-sub]\n       (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n         ...))\n     ```\n\n  For further understanding, read `/docs`, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs\n  "],"~$query->reaction",["^ ","^7","~$re-frame.subs/query->reaction","^U","re_frame/subs.cljc","^V",18,"^W",1,"^X",18,"^Y",21,"^T",["^ ","^U","^8","^V",18,"^W",6,"^X",18,"^Y",21],"^1M","~$cljs.core/Atom"],"~$clear-all-handlers!",["^ ","^S",null,"^T",["^ ","^U","^8","^V",36,"^W",7,"^X",36,"^Y",26,"^Z",["^[",["^10",["^[",[[]]]]],"^11","Unregisters all existing subscription handlers"],"^7","~$re-frame.subs/clear-all-handlers!","^U","re_frame/subs.cljc","^Y",26,"^13",["^[",[[]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",36,"^17",["^6",["^1E","~$clj-nil"]],"^X",36,"^19",0,"^1:",true,"^Z",["^[",["^10",["^[",[[]]]]],"^11","Unregisters all existing subscription handlers"],"~$cache-lookup",["^ ","^S",null,"^T",["^ ","^U","^8","^V",65,"^W",7,"^X",65,"^Y",19,"^Z",["^[",["^10",["^[",[["^1<"],["^1<","~$dyn-v"]]]]],"^1I",["^ ","^16",false,"^1J",2,"^19",2,"^13",["^[",[["^1<"],["^1<","^1X"]]],"^Z",["^[",[["^1<"],["^1<","^1X"]]],"^15",["^[",[null,null]]]],"^7","~$re-frame.subs/cache-lookup","^U","re_frame/subs.cljc","^Y",19,"^1I",["^ ","^16",false,"^1J",2,"^19",2,"^13",["^[",[["^1<"],["^1<","^1X"]]],"^Z",["^[",[["^1<"],["^1<","^1X"]]],"^15",["^[",[null,null]]],"^13",["^[",[["^1<"],["^1<","^1X"]]],"^14",null,"^1J",2,"^15",["^[",[null,null]],"^W",1,"^16",false,"^1L",[["^ ","^1J",1,"^16",false,"^1M","^1E"],["^ ","^1J",2,"^16",false,"^1M",["^6",["^1E","^1V"]]]],"^V",65,"^X",65,"^19",2,"^1:",true,"^Z",["^[",[["^1<"],["^1<","^1X"]]]],"~$map-vals",["^ ","^S",null,"^T",["^ ","^U","^8","^V",163,"^W",8,"^X",163,"^Y",16,"^1@",true,"^Z",["^[",["^10",["^[",[["~$f","~$m"]]]]],"^11","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"^1@",true,"^7","~$re-frame.subs/map-vals","^U","re_frame/subs.cljc","^Y",16,"^13",["^[",[["~$f","~$m"]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",163,"^17",["^6",["^18","^1E"]],"^X",163,"^19",2,"^1:",true,"^Z",["^[",["^10",["^[",[["~$f","~$m"]]]]],"^11","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"~$kind",["^ ","^7","~$re-frame.subs/kind","^U","re_frame/subs.cljc","^V",10,"^W",1,"^X",10,"^Y",10,"^T",["^ ","^U","^8","^V",10,"^W",6,"^X",10,"^Y",10],"^1M","~$cljs.core/Keyword"],"~$clear-subscription-cache!",["^ ","^S",null,"^T",["^ ","^U","^8","^V",20,"^W",7,"^X",20,"^Y",32,"^Z",["^[",["^10",["^[",[[]]]]],"^11","Causes all subscriptions to be removed from the cache.\n  Does this by:\n     1. running `on-dispose` on all cached subscriptions\n     2. Each `on-dispose` will perform the removal of themselves.\n\n  This is for development time use. Useful when reloading Figwheel code\n  after a React exception, because React components won't have been\n  cleaned up properly. And this, in turn, means the subscriptions within those\n  components won't have been cleaned up correctly. So this forces the issue."],"^7","~$re-frame.subs/clear-subscription-cache!","^U","re_frame/subs.cljc","^Y",32,"^13",["^[",[[]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",20,"^17",["^6",["^1E","^1V"]],"^X",20,"^19",0,"^1:",true,"^Z",["^[",["^10",["^[",[[]]]]],"^11","Causes all subscriptions to be removed from the cache.\n  Does this by:\n     1. running `on-dispose` on all cached subscriptions\n     2. Each `on-dispose` will perform the removal of themselves.\n\n  This is for development time use. Useful when reloading Figwheel code\n  after a React exception, because React components won't have been\n  cleaned up properly. And this, in turn, means the subscriptions within those\n  components won't have been cleaned up correctly. So this forces the issue."],"~$map-signals",["^ ","^S",null,"^T",["^ ","^U","^8","^V",171,"^W",7,"^X",171,"^Y",18,"^Z",["^[",["^10",["^[",[["~$f","^1A"]]]]],"^11","Runs f over signals. Signals may take several\n  forms, this function handles all of them."],"^7","~$re-frame.subs/map-signals","^U","re_frame/subs.cljc","^Y",18,"^13",["^[",[["~$f","^1A"]]],"^14",null,"^15",["^[",[null,null]],"^W",1,"^16",false,"^V",171,"^17",["^6",["^1D","^18","^1E","^1F"]],"^X",171,"^19",2,"^1:",true,"^Z",["^[",["^10",["^[",[["~$f","^1A"]]]]],"^11","Runs f over signals. Signals may take several\n  forms, this function handles all of them."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^@","^A","^A","^A"],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:dyn-v","~:tags","~:sub/run","~:else","~:<-","~:sub","~:sub/create","~:warn","~:value","~:operation","~:start","~:duration","~:query-v","~:cached?","~:sub/dispose","~:error","~:input-signals","~:end","~:reaction","~:op-type"]],"~:order",["^2@","^2B","^2D","^2N","^2<","^2I","^2G","^2M","^2E","^2F","^2L","^2A","^2H","^2J","^2;","^2>","^2K","^2?","^2=","^2C"]],"^11",null]