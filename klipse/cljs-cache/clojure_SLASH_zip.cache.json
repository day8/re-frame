["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",["~$replace","~$remove","~$next"]],"~:name","~$clojure.zip","~:imports",null,"~:requires",null,"~:uses",null,"~:defs",["^ ","~$rightmost",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^9","~:line",142,"~:column",7,"~:end-line",142,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^G",[["~$loc"]]]]],"~:doc","Returns the loc of the rightmost sibling of the node at this loc, or self"],"^8","~$clojure.zip/rightmost","~:variadic",false,"^A","clojure/zip.cljs","^E",16,"~:method-params",["^G",[["^I"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^C",1,"^B",142,"^D",142,"~:max-fixed-arity",1,"~:fn-var",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the rightmost sibling of the node at this loc, or self"],"~$insert-child",["^ ","^?",null,"^@",["^ ","^A","^9","^B",194,"^C",7,"^D",194,"^E",19,"^F",["^G",["^H",["^G",[["^I","~$item"]]]]],"^J","Inserts the item as the leftmost child of the node at this loc,\n  without moving"],"^8","~$clojure.zip/insert-child","^L",false,"^A","clojure/zip.cljs","^E",19,"^M",["^G",[["^I","^S"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",194,"^D",194,"^P",2,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the leftmost child of the node at this loc,\n  without moving"],"~$left",["^ ","^?",null,"^@",["^ ","^A","^9","^B",150,"^C",7,"^D",150,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the left sibling of the node at this loc, or nil"],"^8","~$clojure.zip/left","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",150,"^D",150,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the left sibling of the node at this loc, or nil"],"~$path",["^ ","^?",null,"^@",["^ ","^A","^9","^B",82,"^C",7,"^D",82,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of nodes leading to this loc"],"^8","~$clojure.zip/path","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",82,"^D",82,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of nodes leading to this loc"],"~$leftmost",["^ ","^?",null,"^@",["^ ","^A","^9","^B",157,"^C",7,"^D",157,"^E",15,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the leftmost sibling of the node at this loc, or self"],"^8","~$clojure.zip/leftmost","^L",false,"^A","clojure/zip.cljs","^E",15,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",157,"^D",157,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the leftmost sibling of the node at this loc, or self"],"~$append-child",["^ ","^?",null,"^@",["^ ","^A","^9","^B",200,"^C",7,"^D",200,"^E",19,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the rightmost child of the node at this loc,\n  without moving"],"^8","~$clojure.zip/append-child","^L",false,"^A","clojure/zip.cljs","^E",19,"^M",["^G",[["^I","^S"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",200,"^D",200,"^P",2,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the rightmost child of the node at this loc,\n  without moving"],"~$branch?",["^ ","^?",null,"^@",["^ ","^A","^9","^B",64,"^C",7,"^D",64,"^E",14,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns true if the node at loc is a branch"],"^8","~$clojure.zip/branch?","^L",false,"^A","clojure/zip.cljs","^E",14,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",64,"^D",64,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns true if the node at loc is a branch"],"~$children",["^ ","^?",null,"^@",["^ ","^A","^9","^B",69,"^C",7,"^D",69,"^E",15,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the children of node at loc, which must be a branch"],"^8","~$clojure.zip/children","^L",false,"^A","clojure/zip.cljs","^E",15,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",69,"^D",69,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the children of node at loc, which must be a branch"],"^6",["^ ","^?",null,"^@",["^ ","^A","^9","^B",237,"^C",7,"^D",237,"^E",13,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],"^8","~$clojure.zip/remove","^L",false,"^A","clojure/zip.cljs","^E",13,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",237,"^D",237,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],"~$down",["^ ","^?",null,"^@",["^ ","^A","^9","^B",98,"^C",7,"^D",98,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],"^8","~$clojure.zip/down","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",98,"^D",98,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],"^5",["^ ","^?",null,"^@",["^ ","^A","^9","^B",183,"^C",7,"^D",183,"^E",14,"^F",["^G",["^H",["^G",[["^I","~$node"]]]]],"^J","Replaces the node at this loc, without moving"],"^8","~$clojure.zip/replace","^L",false,"^A","clojure/zip.cljs","^E",14,"^M",["^G",[["^I","^18"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",183,"^D",183,"^P",2,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^18"]]]]],"^J","Replaces the node at this loc, without moving"],"~$zipper",["^ ","^?",null,"^@",["^ ","^A","^9","^B",18,"^C",7,"^D",18,"^E",13,"^F",["^G",["^H",["^G",[["^11","^13","~$make-node","~$root"]]]]],"^J","Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],"^8","~$clojure.zip/zipper","^L",false,"^A","clojure/zip.cljs","^E",13,"^M",["^G",[["^11","^13","^1;","^1<"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",18,"^D",18,"^P",4,"^Q",true,"^F",["^G",["^H",["^G",[["^11","^13","^1;","^1<"]]]]],"^J","Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],"~$end?",["^ ","^?",null,"^@",["^ ","^A","^9","^B",232,"^C",7,"^D",232,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns true if loc represents the end of a depth-first walk"],"^8","~$clojure.zip/end?","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",232,"^D",232,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns true if loc represents the end of a depth-first walk"],"~$edit",["^ ","^?",null,"^@",["^ ","^A","^9","^B",189,"^C",7,"^D",189,"^E",11,"^F",["^G",["^H",["^G",[["^I","~$f","~$&","~$args"]]]]],"^J","Replaces the node at this loc with the value of (f node args)","~:top-fn",["^ ","^L",true,"^P",2,"^M",[["^G",["^I","~$f","^1A"]]],"^F",["^G",[["^I","~$f","~$&","^1A"]]],"^O",["^G",[null]]]],"^8","~$clojure.zip/edit","^L",true,"^A","clojure/zip.cljs","^E",11,"^1B",["^ ","^L",true,"^P",2,"^M",[["^G",["^I","~$f","^1A"]]],"^F",["^G",[["^I","~$f","~$&","^1A"]]],"^O",["^G",[null]]],"^M",[["^G",["^I","~$f","^1A"]]],"^N",null,"^O",["^G",[null]],"^C",1,"^B",189,"^D",189,"^P",2,"^Q",true,"^F",["^G",[["^I","~$f","~$&","^1A"]]],"^J","Replaces the node at this loc with the value of (f node args)"],"^1;",["^ ","^?",null,"^@",["^ ","^A","^9","^B",76,"^C",7,"^D",76,"^E",16,"^F",["^G",["^H",["^G",[["^I","^18","^13"]]]]],"^J","Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],"^8","~$clojure.zip/make-node","^L",false,"^A","clojure/zip.cljs","^E",16,"^M",["^G",[["^I","^18","^13"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",76,"^D",76,"^P",3,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^18","^13"]]]]],"^J","Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],"~$vector-zip",["^ ","^?",null,"^@",["^ ","^A","^9","^B",42,"^C",7,"^D",42,"^E",17,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for nested vectors, given a root vector"],"^8","~$clojure.zip/vector-zip","^L",false,"^A","clojure/zip.cljs","^E",17,"^M",["^G",[["^1<"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",42,"^D",42,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for nested vectors, given a root vector"],"^18",["^ ","^?",null,"^@",["^ ","^A","^9","^B",60,"^C",7,"^D",60,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the node at loc"],"^8","~$clojure.zip/node","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",60,"^D",60,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the node at loc"],"~$up",["^ ","^?",null,"^@",["^ ","^A","^9","^B",111,"^C",7,"^D",111,"^E",9,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],"^8","~$clojure.zip/up","^L",false,"^A","clojure/zip.cljs","^E",9,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",111,"^D",111,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],"~$insert-right",["^ ","^?",null,"^@",["^ ","^A","^9","^B",174,"^C",7,"^D",174,"^E",19,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the right sibling of the node at this loc,\n  without moving"],"^8","~$clojure.zip/insert-right","^L",false,"^A","clojure/zip.cljs","^E",19,"^M",["^G",[["^I","^S"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",174,"^D",174,"^P",2,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the right sibling of the node at this loc,\n  without moving"],"~$rights",["^ ","^?",null,"^@",["^ ","^A","^9","^B",92,"^C",7,"^D",92,"^E",13,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the right siblings of this loc"],"^8","~$clojure.zip/rights","^L",false,"^A","clojure/zip.cljs","^E",13,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",92,"^D",92,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the right siblings of this loc"],"^1<",["^ ","^?",null,"^@",["^ ","^A","^9","^B",124,"^C",7,"^D",124,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","zips all the way up and returns the root node, reflecting any\n changes."],"^8","~$clojure.zip/root","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",124,"^D",124,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","zips all the way up and returns the root node, reflecting any\n changes."],"^7",["^ ","^?",null,"^@",["^ ","^A","^9","^B",206,"^C",7,"^D",206,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],"^8","~$clojure.zip/next","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",206,"^D",206,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],"~$seq-zip",["^ ","^?",null,"^@",["^ ","^A","^9","^B",34,"^C",7,"^D",34,"^E",14,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for nested sequences, given a root sequence"],"^8","~$clojure.zip/seq-zip","^L",false,"^A","clojure/zip.cljs","^E",14,"^M",["^G",[["^1<"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",34,"^D",34,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for nested sequences, given a root sequence"],"~$insert-left",["^ ","^?",null,"^@",["^ ","^A","^9","^B",165,"^C",7,"^D",165,"^E",18,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the left sibling of the node at this loc,\n without moving"],"^8","~$clojure.zip/insert-left","^L",false,"^A","clojure/zip.cljs","^E",18,"^M",["^G",[["^I","^S"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",165,"^D",165,"^P",2,"^Q",true,"^F",["^G",["^H",["^G",[["^I","^S"]]]]],"^J","Inserts the item as the left sibling of the node at this loc,\n without moving"],"~$prev",["^ ","^?",null,"^@",["^ ","^A","^9","^B",221,"^C",7,"^D",221,"^E",11,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],"^8","~$clojure.zip/prev","^L",false,"^A","clojure/zip.cljs","^E",11,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",221,"^D",221,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],"~$right",["^ ","^?",null,"^@",["^ ","^A","^9","^B",135,"^C",7,"^D",135,"^E",12,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the right sibling of the node at this loc, or nil"],"^8","~$clojure.zip/right","^L",false,"^A","clojure/zip.cljs","^E",12,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",135,"^D",135,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns the loc of the right sibling of the node at this loc, or nil"],"~$lefts",["^ ","^?",null,"^@",["^ ","^A","^9","^B",87,"^C",7,"^D",87,"^E",12,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the left siblings of this loc"],"^8","~$clojure.zip/lefts","^L",false,"^A","clojure/zip.cljs","^E",12,"^M",["^G",[["^I"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",87,"^D",87,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Returns a seq of the left siblings of this loc"],"~$xml-zip",["^ ","^?",null,"^@",["^ ","^A","^9","^B",50,"^C",7,"^D",50,"^E",14,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],"^8","~$clojure.zip/xml-zip","^L",false,"^A","clojure/zip.cljs","^E",14,"^M",["^G",[["^1<"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^B",50,"^D",50,"^P",1,"^Q",true,"^F",["^G",["^H",["^G",[["^1<"]]]]],"^J","Returns a zipper for xml elements (as from xml/parse),\n  given a root element"]],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^14","~$&","~:ppath","~:zip/branch?","^17","^1G","^I","~:r","~:zip/children","^12","^1M","^9","^1?","^>","^R","^U","^W","^Y","^[","^1A","~:content","^11","~:ns","^13","^8","^6","^L","^16","^1C","^A","^E","^1B","^1D","^T","^M","^5","^1:","^1I","^1K","^10","^1F","^Z","^1>","^O","~:l","~:zip/make-node","^C","~:author","^S","^1N","^1@","^B","^1O","^1S","^1U","^1;","^1E","~:pnodes","^18","~:changed?","^15","^1[","^1H","^1Q","^D","^1J","^1Y","^1W","^P","^1L","^1<","^1=","~:end","^7","^19","^F","^J","^1P","^1R","^1T","~:test","^1V","^1X","^X","^K","^1Z","^V","~$f"]],"~:order",["^24","^25","^28","^1=","^27","^8","^A","^E","^C","^B","^D","^F","^J","^2=","^9","^29","^1:","^11","^13","^1;","^1<","^1Q","^1P","^1F","^1E","^26","^1[","^1Z","^1G","^18","^I","^12","^14","^1D","^2:","^X","^W","~:l","^1Y","^1X","~:r","^1M","^1L","^23","^17","^16","^2;","^1I","^1H","^2<","^1N","^1W","^1V","^K","^>","^V","^U","^Z","^Y","^1S","^1R","^S","^1K","^1J","^19","^5","^1C","^1B","^1@","^L","^P","^M","^O","~$f","^1A","~$&","^T","^R","^10","^[","^1O","^7","^1U","^1T","^1?","^1>","^15","^6"]],"^J","Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"]