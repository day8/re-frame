{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"App-Structure/","text":"A Smaller App \u00b6 For simpler apps, you should put code for each layer into separate files: src \u251c\u2500\u2500 core.cljs <--- entry point, plus history, routing, etc \u251c\u2500\u2500 db.cljs <--- schema, validation, etc (data layer) \u251c\u2500\u2500 views.cljs <--- reagent views (view layer) \u251c\u2500\u2500 events.cljs <--- event handlers (control/update layer) \u2514\u2500\u2500 subs.cljs <--- subscription handlers (query layer) For a living example of this approach, look at the todomvc example . The Gotcha \u00b6 If you adopt this structure, there's a gotcha. events.cljs and subs.cljs will never be required by any other namespaces. To the Google Closure dependency mechanism, it appears as if these two namespaces are not needed and it doesn't load them. And, if the namespaces are not loaded, the registrations in these namespaces will never happen. And, then you'll be staring at your running app very puzzled about why none of your events handlers are registered. Once you twig to what's going on, the solution is easy. You must explicitly require both namespaces, events and subs , in your core namespace. Then they'll be loaded and the registrations ( reg-sub , reg-event-fx , etc) will occur as that loading happens. Larger Apps \u00b6 Assuming your larger apps have multiple \"panels\" (or \"views\") which are relatively independent, you might use this structure: src \u251c\u2500\u2500 core.cljs <--- entry point, plus history, routing, etc \u251c\u2500\u2500 panel-1 \u2502 \u251c\u2500\u2500 db.cljs <--- schema, validation, etc (data layer) \u2502 \u251c\u2500\u2500 subs.cljs <--- subscription handlers (query layer) \u2502 \u251c\u2500\u2500 views.cljs <--- reagent components (view layer) \u2502 \u2514\u2500\u2500 events.cljs <--- event handlers (control/update layer) \u251c\u2500\u2500 panel-2 \u2502 \u251c\u2500\u2500 db.cljs <--- schema, validation. etc (data layer) \u2502 \u251c\u2500\u2500 subs.cljs <--- subscription handlers (query layer) \u2502 \u251c\u2500\u2500 views.cljs <--- reagent components (view layer) \u2502 \u2514\u2500\u2500 events.cljs <--- event handlers (control/update layer) . . \u2514\u2500\u2500 panel-n Namespaced Ids \u00b6 As an app gets bigger, you'll tend to get clashes on ids - event-ids, or query-ids (subscriptions), etc. One panel will need to dispatch an :edit event and so will another, but the two panels will have different handlers. So, how do you avoid a clash? How do you distinguish between one :edit event and another? Your goal should be to use event-ids which encode both the event itself ( :edit ?) and the context ( :panel1 or :panel2 ?). Luckily, ClojureScript provides a nice easy solution: use keywords with a synthetic namespace . Perhaps something like :panel1/edit and :panel2/edit . You see, ClojureScript allows the namespace in a keyword to be a total fiction. I can have the keyword :panel1/edit even though panel1.cljs doesn't exist. Naturally, you'll take advantage of this by using keyword namespaces which are both unique and descriptive. Navigation \u00b6 How do I switch between different panels of a larger app? Your app-db could have an :active-panel key containing an id for the panel being displayed. When the user does something navigation-ish (selects a tab, a dropdown or something which changes the active panel), then the associated event and dispatch look like this: ( re-frame/reg-event-db :set-active-panel ( fn [ db [ _ value ]] ( assoc db :active-panel value ))) ( re-frame/dispatch [ :set-active-panel :panel1 ]) A high level reagent view has a subscription to :active-panel and will switch to the associated panel. ( re-frame/reg-sub :active-panel ( fn [ db _ ] ( :active-panel db ))) ( defn panel1 [] [ :div { :on-click # ( re-frame/dispatch [ :set-active-panel :panel2 ])} \"Here\" ]) ( defn panel2 [] [ :div \"There\" ]) ( defn high-level-view [] ( let [ active ( re-frame/subscribe [ :active-panel ])] ( fn [] [ :div [ :div.title \"Heading\" ] ( condp = @ active ;; or you could look up in a map :panel1 [ panel1 ] :panel2 [ panel2 ])])))","title":"App Structure"},{"location":"App-Structure/#a-smaller-app","text":"For simpler apps, you should put code for each layer into separate files: src \u251c\u2500\u2500 core.cljs <--- entry point, plus history, routing, etc \u251c\u2500\u2500 db.cljs <--- schema, validation, etc (data layer) \u251c\u2500\u2500 views.cljs <--- reagent views (view layer) \u251c\u2500\u2500 events.cljs <--- event handlers (control/update layer) \u2514\u2500\u2500 subs.cljs <--- subscription handlers (query layer) For a living example of this approach, look at the todomvc example .","title":"A Smaller App"},{"location":"App-Structure/#the-gotcha","text":"If you adopt this structure, there's a gotcha. events.cljs and subs.cljs will never be required by any other namespaces. To the Google Closure dependency mechanism, it appears as if these two namespaces are not needed and it doesn't load them. And, if the namespaces are not loaded, the registrations in these namespaces will never happen. And, then you'll be staring at your running app very puzzled about why none of your events handlers are registered. Once you twig to what's going on, the solution is easy. You must explicitly require both namespaces, events and subs , in your core namespace. Then they'll be loaded and the registrations ( reg-sub , reg-event-fx , etc) will occur as that loading happens.","title":"The Gotcha"},{"location":"App-Structure/#larger-apps","text":"Assuming your larger apps have multiple \"panels\" (or \"views\") which are relatively independent, you might use this structure: src \u251c\u2500\u2500 core.cljs <--- entry point, plus history, routing, etc \u251c\u2500\u2500 panel-1 \u2502 \u251c\u2500\u2500 db.cljs <--- schema, validation, etc (data layer) \u2502 \u251c\u2500\u2500 subs.cljs <--- subscription handlers (query layer) \u2502 \u251c\u2500\u2500 views.cljs <--- reagent components (view layer) \u2502 \u2514\u2500\u2500 events.cljs <--- event handlers (control/update layer) \u251c\u2500\u2500 panel-2 \u2502 \u251c\u2500\u2500 db.cljs <--- schema, validation. etc (data layer) \u2502 \u251c\u2500\u2500 subs.cljs <--- subscription handlers (query layer) \u2502 \u251c\u2500\u2500 views.cljs <--- reagent components (view layer) \u2502 \u2514\u2500\u2500 events.cljs <--- event handlers (control/update layer) . . \u2514\u2500\u2500 panel-n","title":"Larger Apps"},{"location":"App-Structure/#namespaced-ids","text":"As an app gets bigger, you'll tend to get clashes on ids - event-ids, or query-ids (subscriptions), etc. One panel will need to dispatch an :edit event and so will another, but the two panels will have different handlers. So, how do you avoid a clash? How do you distinguish between one :edit event and another? Your goal should be to use event-ids which encode both the event itself ( :edit ?) and the context ( :panel1 or :panel2 ?). Luckily, ClojureScript provides a nice easy solution: use keywords with a synthetic namespace . Perhaps something like :panel1/edit and :panel2/edit . You see, ClojureScript allows the namespace in a keyword to be a total fiction. I can have the keyword :panel1/edit even though panel1.cljs doesn't exist. Naturally, you'll take advantage of this by using keyword namespaces which are both unique and descriptive.","title":"Namespaced Ids"},{"location":"App-Structure/#navigation","text":"How do I switch between different panels of a larger app? Your app-db could have an :active-panel key containing an id for the panel being displayed. When the user does something navigation-ish (selects a tab, a dropdown or something which changes the active panel), then the associated event and dispatch look like this: ( re-frame/reg-event-db :set-active-panel ( fn [ db [ _ value ]] ( assoc db :active-panel value ))) ( re-frame/dispatch [ :set-active-panel :panel1 ]) A high level reagent view has a subscription to :active-panel and will switch to the associated panel. ( re-frame/reg-sub :active-panel ( fn [ db _ ] ( :active-panel db ))) ( defn panel1 [] [ :div { :on-click # ( re-frame/dispatch [ :set-active-panel :panel2 ])} \"Here\" ]) ( defn panel2 [] [ :div \"There\" ]) ( defn high-level-view [] ( let [ active ( re-frame/subscribe [ :active-panel ])] ( fn [] [ :div [ :div.title \"Heading\" ] ( condp = @ active ;; or you could look up in a map :panel1 [ panel1 ] :panel2 [ panel2 ])])))","title":"Navigation"},{"location":"Coeffects/","text":"Coeffects \u00b6 This tutorial explains coeffects . It explains what they are, how they can be \"injected\", and how to manage them in tests. What Are They? \u00b6 Event handlers compute how the world should change in response to an event and, to do that, they need to first know the current state of the world. coeffects is the current state of the world, as data, as presented to an event handler. Many event handlers only need application state to do their job - that's as much of \"the world\" as they need to know about. To make this common case easy to program, there's a specific registration function, called reg-event-db , which delivers ONLY the coeffect db to the event handler (and event of course). Such an event handler will have this signature: ( fn [ db event ] ... return updated db ) But event handlers sometimes need to know more about the world OR have more inputs than just application state. Sometimes they need \"inputs\" like a random number, or a GUID, or the current datetime. Perhaps they need access to LocalStore, or Cookies, or a DataScript connection. We refer to these inputs collectively as the event handler's coeffects . When more than application state is needed, we use the registration function reg-event-fx and the event handler has a signature like this: ( fn [ coeffects event ] ;; first arg is often abbreviated to cofx ... return a map of effects ) Notice how previously the first arg was db and now it is coeffects . coeffects is a map, and it contains a :db key which is the current application state. But it can contain other keys holding data about other aspects of the world. So coeffects is a superset of db . It is a bigger world to compute against. A Motivating Example \u00b6 Imagine you had an event handler which needed to \"know\" a value in LocalStore, in order to compute an event's effect. It could be written to access data directly from LocalStore: ( reg-event-db :load-defaults ( fn [ db _ ] ( let [ val ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Problem ( assoc db :defaults val )))) This works, but there's a cost. Because it has directly accessed LocalStore, this event handler is not pure, and impure functions cause well-documented paper cuts, and paper cuts have a way of accumulating non-linearly. How We Want It \u00b6 Our goal in this tutorial is to rewrite this event handler so that it only uses data from arguments (coeffects!). This will take a few steps. The first is that we switch to using reg-event-fx (instead of reg-event-db ). Event handlers registered via reg-event-fx are slightly different to those registered via reg-event-db . -fx handlers get two arguments, but the first is not db . Instead it is an argument which we will call cofx (that's a nice distinct name which will aid communication). Previous tutorials showed there's a :db key in cofx . We now want cofx to have other keys and values, like this: ( reg-event-fx ;; note: -fx :load-defaults ( fn [ cofx event ] ;; cofx means coeffects ( let [ val ( :local-store cofx ) ;; <-- get data from cofx db ( :db cofx )] ;; <-- more data from cofx { :db ( assoc db :defaults val )}))) ;; returns an effect Notice how cofx magically contains a :local-store key with the right value. Nice! But how do we make this magic happen? Abracadabra \u00b6 Each time an event is \"handled\", a brand new context (map) is created, and within that context is a :coeffects key which is a further map (initially empty). That pristine context value (containing, in turn, a pristine :coeffects map) is threaded through the :before function of each interceptor (in the event handler chain) before it finally reaches the registered event handler, which sits on the end of the chain, itself wrapped up in an interceptor. We know this story well from a previous tutorial. These :before functions have the opportunity to assoc into the :coeffects map (within the context ), cumulatively adding to what it holds. Later, our event handler, which sits on the end of the chain, finds that its first cofx argument contains just the right data, like, for example, a value for the key :local-store . So, it is the event handler's Interceptor chain which can add to the \"world\" eventually \"seen\" by an event handler. Which Interceptors? \u00b6 If Interceptors put data in :coeffects , then we'll need to add the right ones when we register our event handler. Something like this (this handler is the same as before, except for one detail): ( reg-event-fx :load-defaults [ ( inject-cofx :local-store \"defaults-key\" ) ] ;; <-- this is new ( fn [ cofx event ] ( let [ val ( :local-store cofx ) db ( :db cofx )] { :db ( assoc db :defaults val )}))) Look at that - my event handler now has a new Interceptor which will inject (assoc) the right key/value pair ( :local-store ) into context's :coeffects , which itself is the map which goes on to be the first argument to our event handler (aka cofx ). inject-cofx \u00b6 inject-cofx is part of the re-frame API. It is a function which returns an Interceptor whose :before function loads a key/value pair into a context's :coeffects map. inject-cofx takes either one or two arguments. The first is always the id of the coeffect required (called a cofx-id ). The 2nd is an optional additional value. So, in the case above, the cofx-id was :local-store and the additional value was \"defaults-key\" which was presumably the LocalStore key. More inject-cofx \u00b6 Here's some other usage examples: (inject-cofx :random-int 10) (inject-cofx :guid) (inject-cofx :now) I could create an event handler which has access to 3 coeffects: ( reg-event-fx :some-id [( inject-cofx :random-int 10 ) ( inject-cofx :now ) ( inject-cofx :local-store \"blah\" )] ;; 3 ( fn [ cofx _ ] ... in here I can access cofx 's keys :now :local-store and :random-int )) But that's probably just greedy. And so, to the final piece in the puzzle: how does inject-cofx know what to do when it is given :now or :local-store ? Each cofx-id requires a different action. Meet reg-cofx \u00b6 This function is also part of the re-frame API. It allows you to associate a cofx-id (like :now or :local-store ) with a handler function that injects the right key/value pair. The function you register will be passed two arguments: a :coeffects map (to which it should add a key/value pair), and optionally, the additional value supplied to inject-cofx and it is expected to return a modified :coeffects map. Example Of reg-cofx \u00b6 Above, we wrote an event handler that wanted :now data to be available. Here is how a handler could be registered for :now : ( reg-cofx ;; registration function :now ;; what cofx-id are we registering ( fn [ coeffects _ ] ;; second parameter not used in this case ( assoc coeffects :now ( js.Date. )))) ;; add :now key, with value The outcome is: because that cofx handler above is now registered for :now , I can add an Interceptor to an event handler which looks like (inject-cofx :now) which means within that event handler I can access a :now value from cofx As a result, my event handler is pure. Another Example Of reg-cofx \u00b6 This: ( reg-cofx ;; new registration function :local-store ( fn [ coeffects local-store-key ] ( assoc coeffects :local-store ( js->clj ( .getItem js/localStorage local-store-key ))))) With these two registrations in place, I could now use both (inject-cofx :now) and (inject-cofx :local-store \"blah\") in an event handler's interceptor chain. To put this another way: I can't use (inject-cofx :blah) UNLESS I have previously used reg-cofx to register a handler for :blah . Otherwise inject-cofx doesn't know how to inject a :blah . Secret Interceptors \u00b6 In a previous tutorial we learned that reg-events-db and reg-events-fx add default interceptors to the front of the interceptor chain specified during registration. We found they inserted an Interceptor called do-fx . I can now reveal that they also add (inject-cofx :db) at the front of each chain. Guess what that injects into the :coeffects of every event handler? This is how :db is always available to event handlers. Okay, so that was the last surprise. Now you know everything. If ever you wanted to use DataScript, instead of an atom-containing-a-map like app-db , you'd replace reg-event-db and reg-event-fx with your own registration functions and have them auto insert the DataScript connection. Testing \u00b6 During testing, you may want to stub out certain coeffects. You may, for example, want to test that an event handler works using a specific now . In your test, you'd mock out the cofx handler: ( reg-cofx :now ( fn [ coeffects _ ] ( assoc coeffects :now ( js/Date. 2016 1 1 ))) ;; then is `:now` If your test does alter registered coeffect handlers, and you are using cljs.test , then you can use a fixture to restore all coeffects at the end of your test: ( defn fixture-re-frame [] ( let [ restore-re-frame ( atom nil )] { :before # ( reset! restore-re-frame ( re-frame.core/make-restore-fn )) :after # ( @ restore-re-frame )})) ( use-fixtures :each ( fixture-re-frame )) re-frame.core/make-restore-fn creates a checkpoint for re-frame state (including registered handlers) to which you can return. The 5 Point Summary \u00b6 In note form: Event handlers should only source data from their arguments We want to \"inject\" required data into the first, cofx argument We use the (inject-cofx :key) interceptor in registration of the event handler It will look up the registered cofx handler for that :key to do the injection We must have previously registered a cofx handler via reg-cofx","title":"Coeffects"},{"location":"Coeffects/#coeffects","text":"This tutorial explains coeffects . It explains what they are, how they can be \"injected\", and how to manage them in tests.","title":"Coeffects"},{"location":"Coeffects/#what-are-they","text":"Event handlers compute how the world should change in response to an event and, to do that, they need to first know the current state of the world. coeffects is the current state of the world, as data, as presented to an event handler. Many event handlers only need application state to do their job - that's as much of \"the world\" as they need to know about. To make this common case easy to program, there's a specific registration function, called reg-event-db , which delivers ONLY the coeffect db to the event handler (and event of course). Such an event handler will have this signature: ( fn [ db event ] ... return updated db ) But event handlers sometimes need to know more about the world OR have more inputs than just application state. Sometimes they need \"inputs\" like a random number, or a GUID, or the current datetime. Perhaps they need access to LocalStore, or Cookies, or a DataScript connection. We refer to these inputs collectively as the event handler's coeffects . When more than application state is needed, we use the registration function reg-event-fx and the event handler has a signature like this: ( fn [ coeffects event ] ;; first arg is often abbreviated to cofx ... return a map of effects ) Notice how previously the first arg was db and now it is coeffects . coeffects is a map, and it contains a :db key which is the current application state. But it can contain other keys holding data about other aspects of the world. So coeffects is a superset of db . It is a bigger world to compute against.","title":"What Are They?"},{"location":"Coeffects/#a-motivating-example","text":"Imagine you had an event handler which needed to \"know\" a value in LocalStore, in order to compute an event's effect. It could be written to access data directly from LocalStore: ( reg-event-db :load-defaults ( fn [ db _ ] ( let [ val ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Problem ( assoc db :defaults val )))) This works, but there's a cost. Because it has directly accessed LocalStore, this event handler is not pure, and impure functions cause well-documented paper cuts, and paper cuts have a way of accumulating non-linearly.","title":"A Motivating Example"},{"location":"Coeffects/#how-we-want-it","text":"Our goal in this tutorial is to rewrite this event handler so that it only uses data from arguments (coeffects!). This will take a few steps. The first is that we switch to using reg-event-fx (instead of reg-event-db ). Event handlers registered via reg-event-fx are slightly different to those registered via reg-event-db . -fx handlers get two arguments, but the first is not db . Instead it is an argument which we will call cofx (that's a nice distinct name which will aid communication). Previous tutorials showed there's a :db key in cofx . We now want cofx to have other keys and values, like this: ( reg-event-fx ;; note: -fx :load-defaults ( fn [ cofx event ] ;; cofx means coeffects ( let [ val ( :local-store cofx ) ;; <-- get data from cofx db ( :db cofx )] ;; <-- more data from cofx { :db ( assoc db :defaults val )}))) ;; returns an effect Notice how cofx magically contains a :local-store key with the right value. Nice! But how do we make this magic happen?","title":"How We Want It"},{"location":"Coeffects/#abracadabra","text":"Each time an event is \"handled\", a brand new context (map) is created, and within that context is a :coeffects key which is a further map (initially empty). That pristine context value (containing, in turn, a pristine :coeffects map) is threaded through the :before function of each interceptor (in the event handler chain) before it finally reaches the registered event handler, which sits on the end of the chain, itself wrapped up in an interceptor. We know this story well from a previous tutorial. These :before functions have the opportunity to assoc into the :coeffects map (within the context ), cumulatively adding to what it holds. Later, our event handler, which sits on the end of the chain, finds that its first cofx argument contains just the right data, like, for example, a value for the key :local-store . So, it is the event handler's Interceptor chain which can add to the \"world\" eventually \"seen\" by an event handler.","title":"Abracadabra"},{"location":"Coeffects/#which-interceptors","text":"If Interceptors put data in :coeffects , then we'll need to add the right ones when we register our event handler. Something like this (this handler is the same as before, except for one detail): ( reg-event-fx :load-defaults [ ( inject-cofx :local-store \"defaults-key\" ) ] ;; <-- this is new ( fn [ cofx event ] ( let [ val ( :local-store cofx ) db ( :db cofx )] { :db ( assoc db :defaults val )}))) Look at that - my event handler now has a new Interceptor which will inject (assoc) the right key/value pair ( :local-store ) into context's :coeffects , which itself is the map which goes on to be the first argument to our event handler (aka cofx ).","title":"Which Interceptors?"},{"location":"Coeffects/#inject-cofx","text":"inject-cofx is part of the re-frame API. It is a function which returns an Interceptor whose :before function loads a key/value pair into a context's :coeffects map. inject-cofx takes either one or two arguments. The first is always the id of the coeffect required (called a cofx-id ). The 2nd is an optional additional value. So, in the case above, the cofx-id was :local-store and the additional value was \"defaults-key\" which was presumably the LocalStore key.","title":"inject-cofx"},{"location":"Coeffects/#more-inject-cofx","text":"Here's some other usage examples: (inject-cofx :random-int 10) (inject-cofx :guid) (inject-cofx :now) I could create an event handler which has access to 3 coeffects: ( reg-event-fx :some-id [( inject-cofx :random-int 10 ) ( inject-cofx :now ) ( inject-cofx :local-store \"blah\" )] ;; 3 ( fn [ cofx _ ] ... in here I can access cofx 's keys :now :local-store and :random-int )) But that's probably just greedy. And so, to the final piece in the puzzle: how does inject-cofx know what to do when it is given :now or :local-store ? Each cofx-id requires a different action.","title":"More inject-cofx"},{"location":"Coeffects/#meet-reg-cofx","text":"This function is also part of the re-frame API. It allows you to associate a cofx-id (like :now or :local-store ) with a handler function that injects the right key/value pair. The function you register will be passed two arguments: a :coeffects map (to which it should add a key/value pair), and optionally, the additional value supplied to inject-cofx and it is expected to return a modified :coeffects map.","title":"Meet reg-cofx"},{"location":"Coeffects/#example-of-reg-cofx","text":"Above, we wrote an event handler that wanted :now data to be available. Here is how a handler could be registered for :now : ( reg-cofx ;; registration function :now ;; what cofx-id are we registering ( fn [ coeffects _ ] ;; second parameter not used in this case ( assoc coeffects :now ( js.Date. )))) ;; add :now key, with value The outcome is: because that cofx handler above is now registered for :now , I can add an Interceptor to an event handler which looks like (inject-cofx :now) which means within that event handler I can access a :now value from cofx As a result, my event handler is pure.","title":"Example Of reg-cofx"},{"location":"Coeffects/#another-example-of-reg-cofx","text":"This: ( reg-cofx ;; new registration function :local-store ( fn [ coeffects local-store-key ] ( assoc coeffects :local-store ( js->clj ( .getItem js/localStorage local-store-key ))))) With these two registrations in place, I could now use both (inject-cofx :now) and (inject-cofx :local-store \"blah\") in an event handler's interceptor chain. To put this another way: I can't use (inject-cofx :blah) UNLESS I have previously used reg-cofx to register a handler for :blah . Otherwise inject-cofx doesn't know how to inject a :blah .","title":"Another Example Of reg-cofx"},{"location":"Coeffects/#secret-interceptors","text":"In a previous tutorial we learned that reg-events-db and reg-events-fx add default interceptors to the front of the interceptor chain specified during registration. We found they inserted an Interceptor called do-fx . I can now reveal that they also add (inject-cofx :db) at the front of each chain. Guess what that injects into the :coeffects of every event handler? This is how :db is always available to event handlers. Okay, so that was the last surprise. Now you know everything. If ever you wanted to use DataScript, instead of an atom-containing-a-map like app-db , you'd replace reg-event-db and reg-event-fx with your own registration functions and have them auto insert the DataScript connection.","title":"Secret Interceptors"},{"location":"Coeffects/#testing","text":"During testing, you may want to stub out certain coeffects. You may, for example, want to test that an event handler works using a specific now . In your test, you'd mock out the cofx handler: ( reg-cofx :now ( fn [ coeffects _ ] ( assoc coeffects :now ( js/Date. 2016 1 1 ))) ;; then is `:now` If your test does alter registered coeffect handlers, and you are using cljs.test , then you can use a fixture to restore all coeffects at the end of your test: ( defn fixture-re-frame [] ( let [ restore-re-frame ( atom nil )] { :before # ( reset! restore-re-frame ( re-frame.core/make-restore-fn )) :after # ( @ restore-re-frame )})) ( use-fixtures :each ( fixture-re-frame )) re-frame.core/make-restore-fn creates a checkpoint for re-frame state (including registered handlers) to which you can return.","title":"Testing"},{"location":"Coeffects/#the-5-point-summary","text":"In note form: Event handlers should only source data from their arguments We want to \"inject\" required data into the first, cofx argument We use the (inject-cofx :key) interceptor in registration of the event handler It will look up the registered cofx handler for that :key to do the injection We must have previously registered a cofx handler via reg-cofx","title":"The 5 Point Summary"},{"location":"Debugging/","text":"We recomend you use: re-frame-10x or refrisk with clj-devtools This page describes techniques for debugging re-frame's event handlers. Event handlers are quite central to a re-frame app. Only event handlers can update app-db to \"step\" an application \"forward\" from one state to the next. The debug Interceptor \u00b6 You might wonder: is my event handler making the right changes to app-db ? During development, the built-in re-frame.core/debug interceptor can help. It writes to console.log : the event being processed, for example: [:attempt-world-record true] the changes made to db by the handler in processing the event debug uses clojure.data/diff to compare the value of app-db before and after the handler ran, showing what changed. clojure.data/diff returns a triple , the first two entries of which debug will display in console.log (the 3rd says what has not changed and isn't interesting). The output produced by clojure.data/diff can take some getting used to, but you should stick with it -- your effort will be rewarded. Using debug \u00b6 So, you will add this Interceptor like this: ( re-frame.core/reg-event-db :some-id [ re-frame.core/debug ] ;; <---- added here! some-handler-fn ) Except, of course, we need to be more deft - we only want debug in development builds. We don't want the overhead of those clojure.data/diff calculations in production. So, this is better: ( re-frame.core/reg-event-db :some-id [( when ^ boolean goog.DEBUG re-frame.core/debug )] ;; <---- conditional! some-handler-fn ) goog.DEBUG is a compile time constant provided by the Google Closure Compiler . It will be true when the build within project.clj is :optimization :none and false otherwise. Ha! I see a problem, you say. In production, that when is going to leave a nil in the interceptor vector. So the Interceptor vector will be [nil] . Surely that's a problem? Well, actually, no it isn't. re-frame filters out any nil from interceptor vectors. Too Much Repetition - Part 1 \u00b6 Each event handler has its own interceptor stack. That might be all very flexible, but does that mean we have to put this debug business on every single handler? That would be very repetitive. Yes, you will have to put it on each handler. And, yes, that could be repetitive, unless you take some steps. One thing you can do is to define standard interceptors at the top of the event.cljs namespace: ( def standard-interceptors [( when ^ boolean goog.DEBUG debug ) another-interceptor ]) And then, for any one event handler, the code would look like: ( re-frame.core/reg-event-db :some-id standard-interceptors ;; <--- use the common definition some-handler-fn ) or perhaps: ( re-frame.core/reg-event-db :some-id [ standard-interceptors specific-interceptor ] ;; mix with something specific some-handler-fn ) So that specific-interceptor could be something required for just this one event handler, and it can be combined with the standard ones. Wait on! \"I see a problem\", you say. standard-interceptors is a vector , and it is within another vector along side specific-interceptor - so that's nested vectors of interceptors! No problem, re-frame uses flatten to take out all the nesting - the result is a simple chain of interceptors. And, as we have discussed, nil s are removed. 3. Checking DB Integrity \u00b6 Always have a detailed schema for the data in app-db ! Why? First , schemas serve as invaluable documentation. When I come to a new app, the first thing I want to look at is the underlying information model - the schema of the data. I hope it is well commented and I expect it to be rigorous and complete, using Clojure spec or, perhaps, a Prismatic Schema . Second a good spec allows you to assert the integrity and correctness of the data in app-db . Because all the data is in one place, that means you are asserting the integrity of ALL the data in your app, at one time. All of it. When should we do this? Ideally, every time a change is made! Well, it turns out that only event handlers can change the value in app-db , so only an event handler could corrupt it. So, we'd like to recheck the integrity of app-db immediately after every event handler has run . All of it, every time. This allows us to catch any errors very early, easily assigning blame (to the rogue event handler). Schemas are typically put into db.cljs (see the todomvc example in the re-frame repo). Here's an example using Prismatic Schema (although a more modern choice would be to use Clojure spec ): ( ns my.namespace.db ( :require [ schema.core :as s ])) ;; As exactly as possible, describe the correct shape of app-db ;; Add a lot of helpful comments. This will be an important resource ;; for someone looking at your code for the first time. ( def schema { :a { :b s/Str :c s/Int } :d [{ :e s/Keyword :f [ s/Num ]}]}) And a function which will check a db value against that schema: ( defn valid-schema? \"validate the given db, writing any problems to console.error\" [ db ] ( let [ res ( s/check schema db )] ( if ( some? res ) ( .error js/console ( str \"schema problem: \" res ))))) Now, let's organise for valid-schema? to be run after every handler. We'll use the built-in after Interceptor factory function: ( def standard-interceptors [( when ^ boolean goog.DEBUG debug ) ( when ^ boolean goog.DEBUG ( after db/valid-schema? ))]) ;; <-- new Now, the instant a handler messes up the structure of app-db you'll be alerted. But this overhead won't be there in production. Too Much Repetition - Part 2 \u00b6 Above, we discussed a way of \"factoring out\" common interceptors into standard-interceptors . There's an additional technique we can use to ensure that all event handlers get certain Interceptors: you write a custom registration function -- a replacement for reg-event-db -- like this: ( defn my-reg-event-db ;; alternative to reg-event-db ([ id handler-fn ] ( re-frame.core/reg-event-db id standard-interceptors handler-fn )) ([ id interceptors handler-fn ] ( re-frame.core/reg-event-db id [ standard-interceptors interceptors ] handler-fn ))) Notice how this registration function inserts our standard interceptors every time. From now on, you can register your event handlers like this and know that the two standard Interceptors have been inserted: ( my-reg-event-db ;; <-- adds std interceptors automatically :some-id some-handler-fn ) What about the -fx variation? \u00b6 Above we created my-reg-event-db as a new registration function for -db handlers. Now, -db handlers take db and event arguments, and return a new db . So, they MUST return a new db value. But what if we tried to do the same for -fx handlers which, instead, return an effects map which may, or may not, contain a :db ? Our solution would have to allow for the absence of a new db value (by doing no validity check, because nothing was being changed). ( def debug? ^ boolean goog.DEBUG ) ( def standard-interceptors-fx [( when debug? debug ) ;; as before ( when debug? ( after # ( if % ( db/valid-schema? % )))]) ;; <-- different after and then: ( defn my-reg-event-fx ;; alternative to reg-event-db ([ id handler-fn ] ( re-frame.core/reg-event-fx id standard-interceptors-fx handler-fn )) ([ id interceptors handler-fn ] ( re-frame.core/reg-event-fx id [ standard-interceptors-fx interceptors ] handler-fn )))","title":"Debugging"},{"location":"Debugging/#the-debug-interceptor","text":"You might wonder: is my event handler making the right changes to app-db ? During development, the built-in re-frame.core/debug interceptor can help. It writes to console.log : the event being processed, for example: [:attempt-world-record true] the changes made to db by the handler in processing the event debug uses clojure.data/diff to compare the value of app-db before and after the handler ran, showing what changed. clojure.data/diff returns a triple , the first two entries of which debug will display in console.log (the 3rd says what has not changed and isn't interesting). The output produced by clojure.data/diff can take some getting used to, but you should stick with it -- your effort will be rewarded.","title":"The debug Interceptor"},{"location":"Debugging/#using-debug","text":"So, you will add this Interceptor like this: ( re-frame.core/reg-event-db :some-id [ re-frame.core/debug ] ;; <---- added here! some-handler-fn ) Except, of course, we need to be more deft - we only want debug in development builds. We don't want the overhead of those clojure.data/diff calculations in production. So, this is better: ( re-frame.core/reg-event-db :some-id [( when ^ boolean goog.DEBUG re-frame.core/debug )] ;; <---- conditional! some-handler-fn ) goog.DEBUG is a compile time constant provided by the Google Closure Compiler . It will be true when the build within project.clj is :optimization :none and false otherwise. Ha! I see a problem, you say. In production, that when is going to leave a nil in the interceptor vector. So the Interceptor vector will be [nil] . Surely that's a problem? Well, actually, no it isn't. re-frame filters out any nil from interceptor vectors.","title":"Using debug"},{"location":"Debugging/#too-much-repetition-part-1","text":"Each event handler has its own interceptor stack. That might be all very flexible, but does that mean we have to put this debug business on every single handler? That would be very repetitive. Yes, you will have to put it on each handler. And, yes, that could be repetitive, unless you take some steps. One thing you can do is to define standard interceptors at the top of the event.cljs namespace: ( def standard-interceptors [( when ^ boolean goog.DEBUG debug ) another-interceptor ]) And then, for any one event handler, the code would look like: ( re-frame.core/reg-event-db :some-id standard-interceptors ;; <--- use the common definition some-handler-fn ) or perhaps: ( re-frame.core/reg-event-db :some-id [ standard-interceptors specific-interceptor ] ;; mix with something specific some-handler-fn ) So that specific-interceptor could be something required for just this one event handler, and it can be combined with the standard ones. Wait on! \"I see a problem\", you say. standard-interceptors is a vector , and it is within another vector along side specific-interceptor - so that's nested vectors of interceptors! No problem, re-frame uses flatten to take out all the nesting - the result is a simple chain of interceptors. And, as we have discussed, nil s are removed.","title":"Too Much Repetition - Part 1"},{"location":"Debugging/#3-checking-db-integrity","text":"Always have a detailed schema for the data in app-db ! Why? First , schemas serve as invaluable documentation. When I come to a new app, the first thing I want to look at is the underlying information model - the schema of the data. I hope it is well commented and I expect it to be rigorous and complete, using Clojure spec or, perhaps, a Prismatic Schema . Second a good spec allows you to assert the integrity and correctness of the data in app-db . Because all the data is in one place, that means you are asserting the integrity of ALL the data in your app, at one time. All of it. When should we do this? Ideally, every time a change is made! Well, it turns out that only event handlers can change the value in app-db , so only an event handler could corrupt it. So, we'd like to recheck the integrity of app-db immediately after every event handler has run . All of it, every time. This allows us to catch any errors very early, easily assigning blame (to the rogue event handler). Schemas are typically put into db.cljs (see the todomvc example in the re-frame repo). Here's an example using Prismatic Schema (although a more modern choice would be to use Clojure spec ): ( ns my.namespace.db ( :require [ schema.core :as s ])) ;; As exactly as possible, describe the correct shape of app-db ;; Add a lot of helpful comments. This will be an important resource ;; for someone looking at your code for the first time. ( def schema { :a { :b s/Str :c s/Int } :d [{ :e s/Keyword :f [ s/Num ]}]}) And a function which will check a db value against that schema: ( defn valid-schema? \"validate the given db, writing any problems to console.error\" [ db ] ( let [ res ( s/check schema db )] ( if ( some? res ) ( .error js/console ( str \"schema problem: \" res ))))) Now, let's organise for valid-schema? to be run after every handler. We'll use the built-in after Interceptor factory function: ( def standard-interceptors [( when ^ boolean goog.DEBUG debug ) ( when ^ boolean goog.DEBUG ( after db/valid-schema? ))]) ;; <-- new Now, the instant a handler messes up the structure of app-db you'll be alerted. But this overhead won't be there in production.","title":"3. Checking DB Integrity"},{"location":"Debugging/#too-much-repetition-part-2","text":"Above, we discussed a way of \"factoring out\" common interceptors into standard-interceptors . There's an additional technique we can use to ensure that all event handlers get certain Interceptors: you write a custom registration function -- a replacement for reg-event-db -- like this: ( defn my-reg-event-db ;; alternative to reg-event-db ([ id handler-fn ] ( re-frame.core/reg-event-db id standard-interceptors handler-fn )) ([ id interceptors handler-fn ] ( re-frame.core/reg-event-db id [ standard-interceptors interceptors ] handler-fn ))) Notice how this registration function inserts our standard interceptors every time. From now on, you can register your event handlers like this and know that the two standard Interceptors have been inserted: ( my-reg-event-db ;; <-- adds std interceptors automatically :some-id some-handler-fn )","title":"Too Much Repetition - Part 2"},{"location":"Debugging/#what-about-the-fx-variation","text":"Above we created my-reg-event-db as a new registration function for -db handlers. Now, -db handlers take db and event arguments, and return a new db . So, they MUST return a new db value. But what if we tried to do the same for -fx handlers which, instead, return an effects map which may, or may not, contain a :db ? Our solution would have to allow for the absence of a new db value (by doing no validity check, because nothing was being changed). ( def debug? ^ boolean goog.DEBUG ) ( def standard-interceptors-fx [( when debug? debug ) ;; as before ( when debug? ( after # ( if % ( db/valid-schema? % )))]) ;; <-- different after and then: ( defn my-reg-event-fx ;; alternative to reg-event-db ([ id handler-fn ] ( re-frame.core/reg-event-fx id standard-interceptors-fx handler-fn )) ([ id interceptors handler-fn ] ( re-frame.core/reg-event-fx id [ standard-interceptors-fx interceptors ] handler-fn )))","title":"What about the -fx variation?"},{"location":"EffectfulHandlers/","text":"This tutorial shows you how to implement pure event handlers that side-effect. Yes, a surprising claim. Events Happen \u00b6 Events \"happen\" when they are dispatched. So, this makes an event happen: ( dispatch [ :repair-ming-vase true ]) Events are normally triggered by an external agent: the user clicks a button, or a server-pushed message arrives on a websocket. Handling The Happening \u00b6 Once dispatched, an event must be \"handled\" - which means it must be processed or actioned. Events are mutative by nature. If your application is in one state before an event is processed, it will be in a different state afterwards. And that state change is very desirable. Without the state change our application can't incorporate that button click, or the newly arrived websocket message. Without mutation, an app would just sit there, stuck. State change is how an application \"moves forward\" - how it does its job. Useful! On the other hand, control logic and state mutation tend to be the most complex and error prone part of an app. Your Handling \u00b6 To help wrangle this potential complexity, re-frame's introduction provided you with a simple programming model. It said you should call reg-event-db to associate an event id, with a function to do the handling: ( re-frame.core/reg-event-db ;; <-- call this to register a handler :set-flag ;; this is an event id ( fn [ db [ _ new-value ]] ;; this function does the handling ( assoc db :flag new-value ))) The function you register, handles events with a given id . And that handler fn is expected to be pure. Given the value in app-db as the first argument, and the event (vector) as the second argument, it is expected to provide a new value for app-db . Data in, a computation and data out. Pure. 90% Solution \u00b6 This paradigm provides a lovely solution 90% of the time, but there are times when it isn't enough. Here's an example from the messy 10%. To get its job done, this handler has to side effect: ( reg-event-db :my-event ( fn [ db [ _ bool ]] ( dispatch [ :do-something-else 3 ]) ;; oops, side-effect ( assoc db :send-spam new-val ))) That dispatch queues up another event to be processed. It changes the world. Just to be clear, this code works. The handler returns a new version of db , so tick, and that dispatch will itself be \"handled\" asynchronously very shortly after this handler finishes, double tick. So, you can \"get away with it\". But it ain't pure. And here's more carnage: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( GET \"http://json.my-endpoint.com/blah\" ;; dirty great big side-effect { :handler # ( dispatch [ :process-response %1 ]) :error-handler # ( dispatch [ :bad-response %1 ])}) ( assoc db :flag true ))) Again, this approach will work. But that dirty great big side-effect doesn't come for free. It's like a muddy monster truck has shown up in our field of white tulips. Bad, Why? \u00b6 The moment we stop writing pure functions there are well documented consequences: Cognitive load for the function's later readers goes up because they can no longer reason locally. Testing becomes more difficult and involves \"mocking\". How do we test that the http GET above is using the right URL? \"mocking\" should be mocked. It is a bad omen. And event replay-ability is lost. Regarding the 3rd point above, a re-frame application proceeds step by step, like a reduce. From the README: at any one time, the value in app-db is the result of performing a reduce over the entire collection of events dispatched in the app up until that time. The combining function for this reduce is the set of registered event handlers. Such a collection of events is replay-able which is a dream for debugging and testing. But only when all the handlers are pure. Handlers with side-effects (like that HTTP GET, or the dispatch ) pollute the replay, inserting extra events into it, etc., which ruins the process. The 2nd Kind Of Problem \u00b6 And there's the other kind of purity problem: ( reg-event-db :load-localstore ( fn [ db _ ] ( let [ val ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Problem ( assoc db :defaults val )))) You'll notice the event handler obtains data from LocalStore. Although this handler has no side effect - it doesn't need to change the world - that action of obtaining data from somewhere other than its arguments, means it isn't pure. Effects And Coeffects \u00b6 When striving for pure event handlers there are two considerations : Effects - what your event handler does to the world (aka side-effects) Coeffects - the data your event handler requires from the world in order to do its computation (aka side-causes ) We'll need a solution for both. Why Does This Happen? \u00b6 It is inevitable that, say, 10% of your event handlers have effects and coeffects. They have to implement the control logic of your re-frame app, which means dealing with the outside, mutative world of servers, databases, window.location, LocalStore, cookies, etc. There's just no getting away from living in a mutative world, which sounds pretty ominous. Is that it? Are we doomed to impurity? Well, luckily a small twist in the tale makes a profound difference. We will look at side-effects first. Instead of creating event handlers which do side-effects , we'll instead get them to cause side-effects . Doing vs Causing \u00b6 I proudly claim that this event handler is pure: ( reg-event-db :my-event ( fn [ db _ ] ( assoc db :flag true ))) Takes a db value, computes and returns a db value. No coeffects or effects. Yep, that's Pure! Yes, all true, but ... this purity is only possible because re-frame is doing the necessary side-effecting. Wait on. What \"necessary side-effecting\"? Well, application state is stored in app-db , right? And it is a ratom. And after each event handler runs, it must be reset! to the newly returned value. Notice reset! . That, right there, is the \"necessary side effecting\". We get to live in our ascetic functional world because re-frame is looking after the \"necessary side-effects\" on app-db . Et tu, React? \u00b6 Turns out it's the same pattern with Reagent/React. We get to write a nice pure component, like: ( defn say-hi [ name ] [ :div \"Hello \" name ]) and Reagent/React mutates the DOM for us. The framework is looking after the \"necessary side-effects\". Pattern Structure \u00b6 Pause and look back at say-hi . I'd like you to view it through the following lens: it is a pure function which returns a description of the side-effects required . It says: add a div element to the DOM. Notice that the description is declarative. We don't tell React how to do it. Notice also that it is data. Hiccup is just vectors and maps. This is a big, important concept. While we can't get away from certain side-effects, we can program using pure functions which describe side-effects, declaratively, in data and let the backing framework look after the \"doing\" of them. Efficiently. Discreetly. Let's use this pattern to solve the side-effecting event-handler problem. Effects: The Two Step Plan \u00b6 From here, two steps: Work out how event handlers can declaratively describe side-effects, in data. Work out how re-frame can do the \"necessary side-effecting\". Efficiently and discreetly. Step 1 Of Plan \u00b6 So, how would it look if event handlers returned side-effects, declaratively, in data? Here is an impure, side effecting handler: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( dispatch [ :do-something-else 3 ]) ;; <-- Eeek, side-effect ( assoc db :flag true ))) Here it is re-written so as to be pure: ( reg-event-fx ;; <1> :my-event ( fn [{ :keys [ db ]} [ _ a ]] ;; <2> { :db ( assoc db :flag true ) ;; <3> :dispatch [ :do-something-else 3 ]})) Notes: <1> we're using reg-event-fx instead of reg-event-db to register (that's -db vs -fx ) <2> the first parameter is no longer just db . It is a map from which we are destructuring db , i.e. it is a map which contains a :db key. <3> The handler is returning a data structure (map) which describes two side-effects: a change to application state, via the :db key a further event, via the :dispatch key Above, the impure handler did a dispatch side-effect, while the pure handler described a dispatch side-effect. Another Example \u00b6 The impure way: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( GET \"http://json.my-endpoint.com/blah\" ;; dirty great big side-effect { :handler # ( dispatch [ :process-response %1 ]) :error-handler # ( dispatch [ :bad-response %1 ])}) ( assoc db :flag true ))) the pure, descriptive alternative: ( reg-event-fx :my-event ( fn [{ :keys [ db ]} [ _ a ]] { :http { :method :get :url \"http://json.my-endpoint.com/blah\" :on-success [ :process-blah-response ] :on-fail [ :failed-blah ]} :db ( assoc db :flag true )})) Again, the old way did a side-effect (Booo!) and the new way describes , declaratively, in data, the side-effects required (Yaaa!). More on side effects in a minute, but let's double back to coeffects. The Coeffects \u00b6 So far we've written our new style -fx handlers like this: ( reg-event-fx :my-event ( fn [{ :keys [ db ]} event ] ;; <-- destructuring to get db { ... })) It is now time to name that first argument: ( reg-event-fx :my-event ( fn [ cofx event ] ;; <--- thy name be cofx { ... })) When you use the -fx form of registration, the first argument of your handler will be a map of coeffects which we name cofx . In that map will be the complete set of \"inputs\" required by your function. The complete set of computational resources (data) needed to perform its computation. But how? This will be explained in an upcoming tutorial, I promise, but for the moment, take it as a magical given. One of the keys in cofx will likely be :db and that will be the value of app-db . Remember this impure handler from before: ( reg-event-db ;; a -db registration :load-localstore ( fn [ db _ ] ;; db first argument ( let [ defaults ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Eeek!! ( assoc db :defaults defaults )))) It was impure because it obtained an input from other than its arguments. We'd now rewrite it as a pure handler, like this: ( reg-event-fx ;; notice the -fx :load-localstore ( fn [ cofx _ ] ;; cofx is a map containing inputs ( let [ defaults ( :local-store cofx )] ;; <-- use it here { :db ( assoc ( :db cofx ) :defaults defaults )}))) ;; returns effects map So, by some magic, not yet revealed, LocalStore will be queried before this handler runs and the required value from it will be placed into cofx under the key :local-store for the handler to use. That process leaves the handler itself pure because it only sources data from arguments. Variations On A Theme \u00b6 -db handlers and -fx handlers are conceptually the same. They only differ numerically. -db handlers take one coeffect called db , and they return only one effect (db again). Whereas -fx handlers take potentially many coeffects (a map of them) and they return potentially many effects (a map of them). So, One vs Many. Just to be clear, the following two handlers achieve the same thing: ( reg-event-db :set-flag ( fn [ db [ _ new-value ]] ( assoc db :flag new-value ))) vs ( reg-event-fx :set-flag ( fn [ cofx [ _ new-value ]] { :db ( assoc ( :db cofx ) :flag new-value )})) Obviously the -db variation is simpler and you'd use it whenever you can. The -fx version is more flexible, so it will sometimes have its place. Summary \u00b6 90% of the time, simple -db handlers are the right tool to use. But about 10% of the time, our handlers need additional inputs (coeffects) or they need to cause additional side-effects (effects). That's when you reach for -fx handlers. -fx handlers allow us to return effects, declaratively in data. In the next tutorial, we'll shine a light on interceptors which are the mechanism by which event handlers are executed. That knowledge will give us a springboard to then, as a next step, better understand coeffects and effects. We'll soon be writing our own.","title":"Effectful Handlers"},{"location":"EffectfulHandlers/#events-happen","text":"Events \"happen\" when they are dispatched. So, this makes an event happen: ( dispatch [ :repair-ming-vase true ]) Events are normally triggered by an external agent: the user clicks a button, or a server-pushed message arrives on a websocket.","title":"Events Happen"},{"location":"EffectfulHandlers/#handling-the-happening","text":"Once dispatched, an event must be \"handled\" - which means it must be processed or actioned. Events are mutative by nature. If your application is in one state before an event is processed, it will be in a different state afterwards. And that state change is very desirable. Without the state change our application can't incorporate that button click, or the newly arrived websocket message. Without mutation, an app would just sit there, stuck. State change is how an application \"moves forward\" - how it does its job. Useful! On the other hand, control logic and state mutation tend to be the most complex and error prone part of an app.","title":"Handling The Happening"},{"location":"EffectfulHandlers/#your-handling","text":"To help wrangle this potential complexity, re-frame's introduction provided you with a simple programming model. It said you should call reg-event-db to associate an event id, with a function to do the handling: ( re-frame.core/reg-event-db ;; <-- call this to register a handler :set-flag ;; this is an event id ( fn [ db [ _ new-value ]] ;; this function does the handling ( assoc db :flag new-value ))) The function you register, handles events with a given id . And that handler fn is expected to be pure. Given the value in app-db as the first argument, and the event (vector) as the second argument, it is expected to provide a new value for app-db . Data in, a computation and data out. Pure.","title":"Your Handling"},{"location":"EffectfulHandlers/#90-solution","text":"This paradigm provides a lovely solution 90% of the time, but there are times when it isn't enough. Here's an example from the messy 10%. To get its job done, this handler has to side effect: ( reg-event-db :my-event ( fn [ db [ _ bool ]] ( dispatch [ :do-something-else 3 ]) ;; oops, side-effect ( assoc db :send-spam new-val ))) That dispatch queues up another event to be processed. It changes the world. Just to be clear, this code works. The handler returns a new version of db , so tick, and that dispatch will itself be \"handled\" asynchronously very shortly after this handler finishes, double tick. So, you can \"get away with it\". But it ain't pure. And here's more carnage: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( GET \"http://json.my-endpoint.com/blah\" ;; dirty great big side-effect { :handler # ( dispatch [ :process-response %1 ]) :error-handler # ( dispatch [ :bad-response %1 ])}) ( assoc db :flag true ))) Again, this approach will work. But that dirty great big side-effect doesn't come for free. It's like a muddy monster truck has shown up in our field of white tulips.","title":"90% Solution"},{"location":"EffectfulHandlers/#bad-why","text":"The moment we stop writing pure functions there are well documented consequences: Cognitive load for the function's later readers goes up because they can no longer reason locally. Testing becomes more difficult and involves \"mocking\". How do we test that the http GET above is using the right URL? \"mocking\" should be mocked. It is a bad omen. And event replay-ability is lost. Regarding the 3rd point above, a re-frame application proceeds step by step, like a reduce. From the README: at any one time, the value in app-db is the result of performing a reduce over the entire collection of events dispatched in the app up until that time. The combining function for this reduce is the set of registered event handlers. Such a collection of events is replay-able which is a dream for debugging and testing. But only when all the handlers are pure. Handlers with side-effects (like that HTTP GET, or the dispatch ) pollute the replay, inserting extra events into it, etc., which ruins the process.","title":"Bad, Why?"},{"location":"EffectfulHandlers/#the-2nd-kind-of-problem","text":"And there's the other kind of purity problem: ( reg-event-db :load-localstore ( fn [ db _ ] ( let [ val ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Problem ( assoc db :defaults val )))) You'll notice the event handler obtains data from LocalStore. Although this handler has no side effect - it doesn't need to change the world - that action of obtaining data from somewhere other than its arguments, means it isn't pure.","title":"The 2nd Kind Of Problem"},{"location":"EffectfulHandlers/#effects-and-coeffects","text":"When striving for pure event handlers there are two considerations : Effects - what your event handler does to the world (aka side-effects) Coeffects - the data your event handler requires from the world in order to do its computation (aka side-causes ) We'll need a solution for both.","title":"Effects And Coeffects"},{"location":"EffectfulHandlers/#why-does-this-happen","text":"It is inevitable that, say, 10% of your event handlers have effects and coeffects. They have to implement the control logic of your re-frame app, which means dealing with the outside, mutative world of servers, databases, window.location, LocalStore, cookies, etc. There's just no getting away from living in a mutative world, which sounds pretty ominous. Is that it? Are we doomed to impurity? Well, luckily a small twist in the tale makes a profound difference. We will look at side-effects first. Instead of creating event handlers which do side-effects , we'll instead get them to cause side-effects .","title":"Why Does This Happen?"},{"location":"EffectfulHandlers/#doing-vs-causing","text":"I proudly claim that this event handler is pure: ( reg-event-db :my-event ( fn [ db _ ] ( assoc db :flag true ))) Takes a db value, computes and returns a db value. No coeffects or effects. Yep, that's Pure! Yes, all true, but ... this purity is only possible because re-frame is doing the necessary side-effecting. Wait on. What \"necessary side-effecting\"? Well, application state is stored in app-db , right? And it is a ratom. And after each event handler runs, it must be reset! to the newly returned value. Notice reset! . That, right there, is the \"necessary side effecting\". We get to live in our ascetic functional world because re-frame is looking after the \"necessary side-effects\" on app-db .","title":"Doing vs Causing"},{"location":"EffectfulHandlers/#et-tu-react","text":"Turns out it's the same pattern with Reagent/React. We get to write a nice pure component, like: ( defn say-hi [ name ] [ :div \"Hello \" name ]) and Reagent/React mutates the DOM for us. The framework is looking after the \"necessary side-effects\".","title":"Et tu, React?"},{"location":"EffectfulHandlers/#pattern-structure","text":"Pause and look back at say-hi . I'd like you to view it through the following lens: it is a pure function which returns a description of the side-effects required . It says: add a div element to the DOM. Notice that the description is declarative. We don't tell React how to do it. Notice also that it is data. Hiccup is just vectors and maps. This is a big, important concept. While we can't get away from certain side-effects, we can program using pure functions which describe side-effects, declaratively, in data and let the backing framework look after the \"doing\" of them. Efficiently. Discreetly. Let's use this pattern to solve the side-effecting event-handler problem.","title":"Pattern Structure"},{"location":"EffectfulHandlers/#effects-the-two-step-plan","text":"From here, two steps: Work out how event handlers can declaratively describe side-effects, in data. Work out how re-frame can do the \"necessary side-effecting\". Efficiently and discreetly.","title":"Effects: The Two Step Plan"},{"location":"EffectfulHandlers/#step-1-of-plan","text":"So, how would it look if event handlers returned side-effects, declaratively, in data? Here is an impure, side effecting handler: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( dispatch [ :do-something-else 3 ]) ;; <-- Eeek, side-effect ( assoc db :flag true ))) Here it is re-written so as to be pure: ( reg-event-fx ;; <1> :my-event ( fn [{ :keys [ db ]} [ _ a ]] ;; <2> { :db ( assoc db :flag true ) ;; <3> :dispatch [ :do-something-else 3 ]})) Notes: <1> we're using reg-event-fx instead of reg-event-db to register (that's -db vs -fx ) <2> the first parameter is no longer just db . It is a map from which we are destructuring db , i.e. it is a map which contains a :db key. <3> The handler is returning a data structure (map) which describes two side-effects: a change to application state, via the :db key a further event, via the :dispatch key Above, the impure handler did a dispatch side-effect, while the pure handler described a dispatch side-effect.","title":"Step 1 Of Plan"},{"location":"EffectfulHandlers/#another-example","text":"The impure way: ( reg-event-db :my-event ( fn [ db [ _ a ]] ( GET \"http://json.my-endpoint.com/blah\" ;; dirty great big side-effect { :handler # ( dispatch [ :process-response %1 ]) :error-handler # ( dispatch [ :bad-response %1 ])}) ( assoc db :flag true ))) the pure, descriptive alternative: ( reg-event-fx :my-event ( fn [{ :keys [ db ]} [ _ a ]] { :http { :method :get :url \"http://json.my-endpoint.com/blah\" :on-success [ :process-blah-response ] :on-fail [ :failed-blah ]} :db ( assoc db :flag true )})) Again, the old way did a side-effect (Booo!) and the new way describes , declaratively, in data, the side-effects required (Yaaa!). More on side effects in a minute, but let's double back to coeffects.","title":"Another Example"},{"location":"EffectfulHandlers/#the-coeffects","text":"So far we've written our new style -fx handlers like this: ( reg-event-fx :my-event ( fn [{ :keys [ db ]} event ] ;; <-- destructuring to get db { ... })) It is now time to name that first argument: ( reg-event-fx :my-event ( fn [ cofx event ] ;; <--- thy name be cofx { ... })) When you use the -fx form of registration, the first argument of your handler will be a map of coeffects which we name cofx . In that map will be the complete set of \"inputs\" required by your function. The complete set of computational resources (data) needed to perform its computation. But how? This will be explained in an upcoming tutorial, I promise, but for the moment, take it as a magical given. One of the keys in cofx will likely be :db and that will be the value of app-db . Remember this impure handler from before: ( reg-event-db ;; a -db registration :load-localstore ( fn [ db _ ] ;; db first argument ( let [ defaults ( js->clj ( .getItem js/localStorage \"defaults-key\" ))] ;; <-- Eeek!! ( assoc db :defaults defaults )))) It was impure because it obtained an input from other than its arguments. We'd now rewrite it as a pure handler, like this: ( reg-event-fx ;; notice the -fx :load-localstore ( fn [ cofx _ ] ;; cofx is a map containing inputs ( let [ defaults ( :local-store cofx )] ;; <-- use it here { :db ( assoc ( :db cofx ) :defaults defaults )}))) ;; returns effects map So, by some magic, not yet revealed, LocalStore will be queried before this handler runs and the required value from it will be placed into cofx under the key :local-store for the handler to use. That process leaves the handler itself pure because it only sources data from arguments.","title":"The Coeffects"},{"location":"EffectfulHandlers/#variations-on-a-theme","text":"-db handlers and -fx handlers are conceptually the same. They only differ numerically. -db handlers take one coeffect called db , and they return only one effect (db again). Whereas -fx handlers take potentially many coeffects (a map of them) and they return potentially many effects (a map of them). So, One vs Many. Just to be clear, the following two handlers achieve the same thing: ( reg-event-db :set-flag ( fn [ db [ _ new-value ]] ( assoc db :flag new-value ))) vs ( reg-event-fx :set-flag ( fn [ cofx [ _ new-value ]] { :db ( assoc ( :db cofx ) :flag new-value )})) Obviously the -db variation is simpler and you'd use it whenever you can. The -fx version is more flexible, so it will sometimes have its place.","title":"Variations On A Theme"},{"location":"EffectfulHandlers/#summary","text":"90% of the time, simple -db handlers are the right tool to use. But about 10% of the time, our handlers need additional inputs (coeffects) or they need to cause additional side-effects (effects). That's when you reach for -fx handlers. -fx handlers allow us to return effects, declaratively in data. In the next tutorial, we'll shine a light on interceptors which are the mechanism by which event handlers are executed. That knowledge will give us a springboard to then, as a next step, better understand coeffects and effects. We'll soon be writing our own.","title":"Summary"},{"location":"Effects/","text":"Maybe 20% of the time, event handlers need to cause side effects. This tutorial explains how side effects are actioned, how you can create your own side effects, and how you can make side effects a noop in testing and event replays. Where Effects Come From \u00b6 When an event handler is registered via reg-event-fx , it must return effects. Like this: ( reg-event-fx ;; -fx registration, not -db registration :my-event ( fn [ cofx [ _ a ]] ;; 1st argument is coeffects, instead of db { :db ( assoc ( :db cofx ) :flag a ) :fx [[ :dispatch [ :do-something-else 3 ]]]})) ;; return effects -fx handlers return a description of the side-effects required, and that description is a map. The Effects Map \u00b6 An effects map contains instructions. Each key/value pair in the map is one instruction - the key uniquely identifies the particular side effect required, and the value for that key provides further data. The type of value depends on the specific side-effect. Here's the two instructions from the example above: { :db ( assoc db :flag a ) ;; side effect on app-db :fx [[ :dispatch [ :do-something-else 3 ]]]} ;; dispatch this event The :db key instructs that \"app-db\" should be reset! to the value supplied. And the :fx key instructs that an ordered list of other effects should be executed. In this case a :dispatch key instructs that an event should be dispatched. The value is the vector to dispatch. There are many other possible effects, like for example :dispatch-later , dispatch-n , :set-local-store , etc. And so on. And so on. Which brings us to a problem. Infinite Effects \u00b6 Although re-frame supplies a number of built-in effect handlers, the set of possible effects is open ended. What if you use PostgreSQL and want an effect which issues mutating queries? Or what if you want to send logs to Logentries or metrics to DataDog. Or write values to windows.location . Or save cookies. The list of effects is long and varied, with everyone needing to use a different combination. So effect handling has to be extensible. You need a way to define your own side effects. Extensible Side Effects \u00b6 re-frame provides a function reg-fx through which you can register your own Effect Handlers . Use it like this: ( reg-fx ;; <-- registration function :butterfly ;; <1> effect key ( fn [ value ] ;; <2> effect handler ... )) <1> Effect Key Later, when an effects map contains the key :butterfly , the function we are registering will be used to action it. <2> Effect handler The function which actions the side effect. Later, it will be called with one argument - the value associated with the key in the effects map. So, if an event handler returned these two effects: { :dispatch [ :save-maiden 42 ] :butterfly \"Flapping\" } ;; butterfly effect, but no chaos !! Then the function we registered for :butterfly would be called to handle that effect. And it would be called with the parameter \"Flapping\". So, terminology: :butterfly is an \"effect key\" and the function registered is an \"effect handler\". So re-frame has both event handlers and effect handlers and they are different, despite them both starting with e and ending in t !! Writing An Effect Handler \u00b6 A word of advice - make them as simple as possible, and then simplify them further. You don't want them containing any fancy logic. Why? Well, because they are all side-effecty they will be a pain to test rigorously. And the combination of fancy logic and limited testing always ends in tears. If not now, later. A second word of advice - when you create an effect handler, you also have to design (and document!) the structure of the value expected. When you do, realise that you are designing a nano DSL for value and try to make that design simple too. If you resist being terse and smart, and instead, favor slightly verbose and obvious, your future self will thank you. Create as little cognitive overhead as possible for the eventual readers of your effectful code. Right. So, this advice coming from the guy who named effects fx ... Oh, the hypocrisy. In my defence, here's the built-in effect handler for :db : ( reg-fx :db ( fn [ value ] ( reset! re-frame.db/app-db value ))) So, yeah, simple ... and, because of it, I can almost guarantee there's no bug in ... bang, crash, smoke, flames. Note The return value of an effect handler is ignored. :db Not Always Needed \u00b6 An effects map does not need to include the effect key :db . It is perfectly valid for an event handler to not change app-db . In fact, it is perfectly valid for an event handler to return an effects map of {} . Slightly puzzling, but not a problem. What Makes This Work? \u00b6 A silently inserted interceptor. Whenever you register an event handler via either reg-event-db or reg-event-fx , an interceptor, cunningly named do-fx , is inserted at the beginning of the chain. Example: if your event handler registration looked like this: ( reg-event-fx :some-id [ debug ( path :right )] ;; <-- two interceptors, apparently ( fn [ cofx _ ] {}) ;; <-- imagine returned effects here While it might look like you have registered with 2 interceptors, reg-event-fx will make it 3: [ do-fx debug ( path :right )] It silently inserts do-fx at the front, and this is a good thing. The placement of do-fx at the beginning of the interceptor chain means its :after function would be the final act when the chain is executed (forwards and then backwards, as described in the Interceptor Tutorial). In this final act, the :after function extracts :effects from context and simply iterates across the key/value pairs it contains, calling the registered \"effect handlers\" for each. For the record The FISA Court requires that we deny all claims that do-fx is secretly injected NSA surveillance-ware. We also note that you've been sloppy with your personal grooming again, including, but not limited to, forgetting to clean your teeth on one occassion last week. If ever you want to take control of the way effect handling is done, create your own alternative to reg-event-fx and, in it, inject your own version of the do-fx interceptor at the front of the interceptor chain. It is only a few lines of code. Order Of Effects? \u00b6 Prior to v1.1.0 , the answer is: no guarantees were provided about ordering. Actual order is an implementation detail upon which you should not rely. From v1.1.0 onwards , two things changed: re-frame guaranteed that the :db effect will always be actioned first, if present. But other than that, no guarantee is given for the other effects. a new effect called :fx was added, and it provides a way for effects to be ordered. In fact, with v1.1.0 best practice changed to event handlers should only return two effects :db and :fx , in which case :db was always done first and then :fx , and within :fx the ordering is sequential. This new approach is more about making it easier to compose event handlers from many smaller functions, but more specificity around ordering was a consequence. Effects With No Data \u00b6 Some effects have no associated data: ( reg-event-fx :some-id ( fn [ coeffect _ ] { :exit-fullscreen nil })) ;; <--- no data, use a nil In these cases, although it looks odd, just supply nil as the value for this key. The associated effect handler would look like: ( reg-fx :exit-fullscreen ( fn [ _ ] ;; we don't bother with that nil value ( .exitFullscreen js/document ))) Testing And Noops \u00b6 When you are running tests or replaying events, it is sometimes useful to stub out effects. This is easily done - you simply register a noop effect handler. Want to stub out the :dispatch effect? Do this: ( reg-fx :dispatch ( fn [ _ ] )) ;; a noop If your test does alter registered effect handlers, and you are using cljs.test , then you can use a fixture to restore all effect handlers at the end of your test: ( defn fixture-re-frame [] ( let [ restore-re-frame ( atom nil )] { :before # ( reset! restore-re-frame ( re-frame.core/make-restore-fn )) :after # ( @ restore-re-frame )})) ( use-fixtures :each ( fixture-re-frame )) re-frame.core/make-restore-fn creates a checkpoint for re-frame state (including registered handlers) to which you can return. Existing Effect Handlers \u00b6 re-frame's built-in effect handlers, like dispatch-n and dispatch-later , are detailed in the API document. And please review the External-Resources document for a list of 3rd party Effect Handlers. Summary \u00b6 The 4 Point Summary in note form: Event handlers should only return a description of required effects They return a map like {:effect1 value1 :effect2 value2} Keys of this map can refer to builtin effect handlers (see below) or custom ones We use reg-fx to register our own effect handlers, built-in ones are already registered","title":"Effects"},{"location":"Effects/#where-effects-come-from","text":"When an event handler is registered via reg-event-fx , it must return effects. Like this: ( reg-event-fx ;; -fx registration, not -db registration :my-event ( fn [ cofx [ _ a ]] ;; 1st argument is coeffects, instead of db { :db ( assoc ( :db cofx ) :flag a ) :fx [[ :dispatch [ :do-something-else 3 ]]]})) ;; return effects -fx handlers return a description of the side-effects required, and that description is a map.","title":"Where Effects Come From"},{"location":"Effects/#the-effects-map","text":"An effects map contains instructions. Each key/value pair in the map is one instruction - the key uniquely identifies the particular side effect required, and the value for that key provides further data. The type of value depends on the specific side-effect. Here's the two instructions from the example above: { :db ( assoc db :flag a ) ;; side effect on app-db :fx [[ :dispatch [ :do-something-else 3 ]]]} ;; dispatch this event The :db key instructs that \"app-db\" should be reset! to the value supplied. And the :fx key instructs that an ordered list of other effects should be executed. In this case a :dispatch key instructs that an event should be dispatched. The value is the vector to dispatch. There are many other possible effects, like for example :dispatch-later , dispatch-n , :set-local-store , etc. And so on. And so on. Which brings us to a problem.","title":"The Effects Map"},{"location":"Effects/#infinite-effects","text":"Although re-frame supplies a number of built-in effect handlers, the set of possible effects is open ended. What if you use PostgreSQL and want an effect which issues mutating queries? Or what if you want to send logs to Logentries or metrics to DataDog. Or write values to windows.location . Or save cookies. The list of effects is long and varied, with everyone needing to use a different combination. So effect handling has to be extensible. You need a way to define your own side effects.","title":"Infinite Effects"},{"location":"Effects/#extensible-side-effects","text":"re-frame provides a function reg-fx through which you can register your own Effect Handlers . Use it like this: ( reg-fx ;; <-- registration function :butterfly ;; <1> effect key ( fn [ value ] ;; <2> effect handler ... )) <1> Effect Key Later, when an effects map contains the key :butterfly , the function we are registering will be used to action it. <2> Effect handler The function which actions the side effect. Later, it will be called with one argument - the value associated with the key in the effects map. So, if an event handler returned these two effects: { :dispatch [ :save-maiden 42 ] :butterfly \"Flapping\" } ;; butterfly effect, but no chaos !! Then the function we registered for :butterfly would be called to handle that effect. And it would be called with the parameter \"Flapping\". So, terminology: :butterfly is an \"effect key\" and the function registered is an \"effect handler\". So re-frame has both event handlers and effect handlers and they are different, despite them both starting with e and ending in t !!","title":"Extensible Side Effects"},{"location":"Effects/#writing-an-effect-handler","text":"A word of advice - make them as simple as possible, and then simplify them further. You don't want them containing any fancy logic. Why? Well, because they are all side-effecty they will be a pain to test rigorously. And the combination of fancy logic and limited testing always ends in tears. If not now, later. A second word of advice - when you create an effect handler, you also have to design (and document!) the structure of the value expected. When you do, realise that you are designing a nano DSL for value and try to make that design simple too. If you resist being terse and smart, and instead, favor slightly verbose and obvious, your future self will thank you. Create as little cognitive overhead as possible for the eventual readers of your effectful code. Right. So, this advice coming from the guy who named effects fx ... Oh, the hypocrisy. In my defence, here's the built-in effect handler for :db : ( reg-fx :db ( fn [ value ] ( reset! re-frame.db/app-db value ))) So, yeah, simple ... and, because of it, I can almost guarantee there's no bug in ... bang, crash, smoke, flames. Note The return value of an effect handler is ignored.","title":"Writing An Effect Handler"},{"location":"Effects/#db-not-always-needed","text":"An effects map does not need to include the effect key :db . It is perfectly valid for an event handler to not change app-db . In fact, it is perfectly valid for an event handler to return an effects map of {} . Slightly puzzling, but not a problem.","title":":db Not Always Needed"},{"location":"Effects/#what-makes-this-work","text":"A silently inserted interceptor. Whenever you register an event handler via either reg-event-db or reg-event-fx , an interceptor, cunningly named do-fx , is inserted at the beginning of the chain. Example: if your event handler registration looked like this: ( reg-event-fx :some-id [ debug ( path :right )] ;; <-- two interceptors, apparently ( fn [ cofx _ ] {}) ;; <-- imagine returned effects here While it might look like you have registered with 2 interceptors, reg-event-fx will make it 3: [ do-fx debug ( path :right )] It silently inserts do-fx at the front, and this is a good thing. The placement of do-fx at the beginning of the interceptor chain means its :after function would be the final act when the chain is executed (forwards and then backwards, as described in the Interceptor Tutorial). In this final act, the :after function extracts :effects from context and simply iterates across the key/value pairs it contains, calling the registered \"effect handlers\" for each. For the record The FISA Court requires that we deny all claims that do-fx is secretly injected NSA surveillance-ware. We also note that you've been sloppy with your personal grooming again, including, but not limited to, forgetting to clean your teeth on one occassion last week. If ever you want to take control of the way effect handling is done, create your own alternative to reg-event-fx and, in it, inject your own version of the do-fx interceptor at the front of the interceptor chain. It is only a few lines of code.","title":"What Makes This Work?"},{"location":"Effects/#order-of-effects","text":"Prior to v1.1.0 , the answer is: no guarantees were provided about ordering. Actual order is an implementation detail upon which you should not rely. From v1.1.0 onwards , two things changed: re-frame guaranteed that the :db effect will always be actioned first, if present. But other than that, no guarantee is given for the other effects. a new effect called :fx was added, and it provides a way for effects to be ordered. In fact, with v1.1.0 best practice changed to event handlers should only return two effects :db and :fx , in which case :db was always done first and then :fx , and within :fx the ordering is sequential. This new approach is more about making it easier to compose event handlers from many smaller functions, but more specificity around ordering was a consequence.","title":"Order Of Effects?"},{"location":"Effects/#effects-with-no-data","text":"Some effects have no associated data: ( reg-event-fx :some-id ( fn [ coeffect _ ] { :exit-fullscreen nil })) ;; <--- no data, use a nil In these cases, although it looks odd, just supply nil as the value for this key. The associated effect handler would look like: ( reg-fx :exit-fullscreen ( fn [ _ ] ;; we don't bother with that nil value ( .exitFullscreen js/document )))","title":"Effects With No Data"},{"location":"Effects/#testing-and-noops","text":"When you are running tests or replaying events, it is sometimes useful to stub out effects. This is easily done - you simply register a noop effect handler. Want to stub out the :dispatch effect? Do this: ( reg-fx :dispatch ( fn [ _ ] )) ;; a noop If your test does alter registered effect handlers, and you are using cljs.test , then you can use a fixture to restore all effect handlers at the end of your test: ( defn fixture-re-frame [] ( let [ restore-re-frame ( atom nil )] { :before # ( reset! restore-re-frame ( re-frame.core/make-restore-fn )) :after # ( @ restore-re-frame )})) ( use-fixtures :each ( fixture-re-frame )) re-frame.core/make-restore-fn creates a checkpoint for re-frame state (including registered handlers) to which you can return.","title":"Testing And Noops"},{"location":"Effects/#existing-effect-handlers","text":"re-frame's built-in effect handlers, like dispatch-n and dispatch-later , are detailed in the API document. And please review the External-Resources document for a list of 3rd party Effect Handlers.","title":"Existing Effect Handlers"},{"location":"Effects/#summary","text":"The 4 Point Summary in note form: Event handlers should only return a description of required effects They return a map like {:effect1 value1 :effect2 value2} Keys of this map can refer to builtin effect handlers (see below) or custom ones We use reg-fx to register our own effect handlers, built-in ones are already registered","title":"Summary"},{"location":"External-Resources/","text":"Alternative Explanations \u00b6 An overview of re-frame by purelyfunctional.tv On naming things and app-db structure by purelyfunctional.tv Reagent \u00b6 To get a good grounding in Reagent, please be sure to review the docs: Reagent site Reagent README For inspiration, perhaps look at one of our other projects: re-com . Video Training \u00b6 Commercial grade video training for re-frame and Reagent: Jacek Schae purelyfunctional.tv Lambda Island Videos Clojure Hacker IDE Support \u00b6 Cursive - has direct support for some re-frame features, including keyword sourcing. Emacs support Templates \u00b6 re-frame-template - To generate a client side SPA. Good for getting started. Luminus - Generates an integrated client and server re-natal - React Native apps Debugging re-frame-10x - A debugging dashboard for re-frame re-frisk - A library for visualizing re-frame data and events. Examples and Applications Using re-frame \u00b6 Heardicon - create your own coat of arms The Workshub client is open source and the repo is available here RealWorld - a well commented codebase with CRUD, auth, advanced patterns, etc) that implements to the RealWorld Spec and API . RealWorld - react native version BlueGenes - searching and analysing genomic data, by the University of Cambridge Memento a private note-taking app. Uses compojure-api, PostgreSQL and token auth. How to create decentralised apps with re-frame and Ethereum - Tutorial with links to code and live example. Braid - A new approach to group chat, designed around conversations and tags instead of rooms. Elfeed-cljsrn - A mobile client for Elfeed rss reader, built with React Native. Memory Hole - A small issue tracking app written with Luminus and re-frame. imperimetric - Webapp for converting texts with some system of measurement to another, such as imperial to metric. boodle - A simple SPA for accounting. It uses, among others, re-frame, http-kit, compojure-api and it runs on PostgreSQL. status-react - A mobile OS for Ethereum. Server, SPA + React Native App Catlantis - React Native App about cats Lymchat - React Native App to learn different cultures ventas - Ecommerce platform made with a full-clojure stack ONS Structural Search - Structural search engine for data cubes Life counter - Simple life counter PWA for 2 players Network Token - A basic SPA for the district0x token contribution smart contract on the Ethereum blockchain MemeFactory - A decentralized platform for creating, issuing, and trading verifiably rare digital collectibles on the Ethereum blockchain Name Bazaar - A peer-to-peer marketplace for exchanging names registered through the Ethereum Name Service LIPAS - A full-stack implementation of Finland's national sports facility geographic information system PuppetAPI - An application to create mock APIs and real-time testing Effect and CoEffect Handlers \u00b6 async-flow-fx - manage a boot process dominated by async http-fx - performing HTTP request tasks (via cljs-ajax) fetch-fx - performing HTTP request tasks (via js/fetch ) re-frame-forward-events-fx - slightly exotic cookie-fx - set and get cookies document-fx - set and get on js/document attributes clipboard-fx - write to the system clipboard re-frame-youtube-fx - YouTube iframe API wrapper re-frame-web3-fx - Ethereum Web3 API re-frame-google-analytics-fx - Google Analytics API re-frame-storage - Local Storage based persistence re-frame-storage-fx - Another take on Local Storage persistence re-frame-firebase - Firebase DB API sse-fx - fx/cofx handlers for EventSource and SSE Forms \u00b6 Fork Form Library. Inspired by formik. re-form free-form re-frame-forms Routing \u00b6 Bidirectional using Silk and Pushy Tools, Techniques & Libraries \u00b6 re-fill - routing and more re-frame-undo - An undo library for re-frame re-frame-test - Advanced testing utilities Animation using react-flip-move re-thread - A library for running re-frame applications in Web Workers. re-frame-datatable - DataTable UI component built for use with re-frame. Stately: State Machines also https://www.youtube.com/watch?v=klqorRUPluw re-learn - Data driven tutorials for educating users of your reagent / re-frame app subgraph - Reactive graph database for re-frame re-graph - GraphQL client for re-frame martian - Swagger-compatible API client that abstracts away from HTTP with re-frame bindings re-pressed - A keyboard event library for re-frame re-pollsive - A polling event library for re-frame breaking-point - Quickly define screen breakpoints for re-frame re-frame-flow - A graph based visualization tool for re-frame event chains Suites \u00b6 reflet - Fast multi-model db, mix graph/non-graph data, graph queries/mutations, hierarchical FSMs, JS/DOM interop utils, component APIs, novel visual debugging React Native re-natal : Bootstrap ClojureScript React Native apps cljsrn-re-frame-workers : A library supporting react-native-workers with re-frame for ClojureScript and React Native. re-navigate : Example of React Native Navigation with re-frame/re-natal Other \u00b6 re-posh is re-frame + Datalog Videos \u00b6 A three part video series A Video Tour of the Source Code of Ninja Tools Funding Circle Clojure Meetup: Modular Users Interfaces with Re-frame Build your next single page app in ClojureScript and re-frame Clojurescript re-frame Tutorial Part 1 - Events and Event Handlers From 0 to prototype using ClojureScript, re-frame and friends: Martin Clausen Re-usable GUI Components with Re-frame and Atomic Design - Mark Nutter clojureD 2018: \"Reframing your next Single Page App\" by Kenneth Kalmer Server Side Rendering \u00b6 isomorphic-rendering Prerenderer - Server pre-rendering library using NodeJS that works with re-frame 0.6.0 (later versions untested) Rationale Part 1 Part 2 Part 3 Release Announcement Server Side Rendering with re-frame - Blog post on rendering re-frame views with Clojure. Rendering Reagent on the Server Using Hiccup - Blog post on rendering Reagent with Clojure. Prerendering a re-frame app with Chrome Headless - Blog post on prerendering a re-frame app using etaoin and Chrome Headless.","title":"Resources"},{"location":"External-Resources/#alternative-explanations","text":"An overview of re-frame by purelyfunctional.tv On naming things and app-db structure by purelyfunctional.tv","title":"Alternative Explanations"},{"location":"External-Resources/#reagent","text":"To get a good grounding in Reagent, please be sure to review the docs: Reagent site Reagent README For inspiration, perhaps look at one of our other projects: re-com .","title":"Reagent"},{"location":"External-Resources/#video-training","text":"Commercial grade video training for re-frame and Reagent: Jacek Schae purelyfunctional.tv Lambda Island Videos Clojure Hacker","title":"Video Training"},{"location":"External-Resources/#ide-support","text":"Cursive - has direct support for some re-frame features, including keyword sourcing. Emacs support","title":"IDE Support"},{"location":"External-Resources/#templates","text":"re-frame-template - To generate a client side SPA. Good for getting started. Luminus - Generates an integrated client and server re-natal - React Native apps","title":"Templates"},{"location":"External-Resources/#examples-and-applications-using-re-frame","text":"Heardicon - create your own coat of arms The Workshub client is open source and the repo is available here RealWorld - a well commented codebase with CRUD, auth, advanced patterns, etc) that implements to the RealWorld Spec and API . RealWorld - react native version BlueGenes - searching and analysing genomic data, by the University of Cambridge Memento a private note-taking app. Uses compojure-api, PostgreSQL and token auth. How to create decentralised apps with re-frame and Ethereum - Tutorial with links to code and live example. Braid - A new approach to group chat, designed around conversations and tags instead of rooms. Elfeed-cljsrn - A mobile client for Elfeed rss reader, built with React Native. Memory Hole - A small issue tracking app written with Luminus and re-frame. imperimetric - Webapp for converting texts with some system of measurement to another, such as imperial to metric. boodle - A simple SPA for accounting. It uses, among others, re-frame, http-kit, compojure-api and it runs on PostgreSQL. status-react - A mobile OS for Ethereum. Server, SPA + React Native App Catlantis - React Native App about cats Lymchat - React Native App to learn different cultures ventas - Ecommerce platform made with a full-clojure stack ONS Structural Search - Structural search engine for data cubes Life counter - Simple life counter PWA for 2 players Network Token - A basic SPA for the district0x token contribution smart contract on the Ethereum blockchain MemeFactory - A decentralized platform for creating, issuing, and trading verifiably rare digital collectibles on the Ethereum blockchain Name Bazaar - A peer-to-peer marketplace for exchanging names registered through the Ethereum Name Service LIPAS - A full-stack implementation of Finland's national sports facility geographic information system PuppetAPI - An application to create mock APIs and real-time testing","title":"Examples and Applications Using re-frame"},{"location":"External-Resources/#effect-and-coeffect-handlers","text":"async-flow-fx - manage a boot process dominated by async http-fx - performing HTTP request tasks (via cljs-ajax) fetch-fx - performing HTTP request tasks (via js/fetch ) re-frame-forward-events-fx - slightly exotic cookie-fx - set and get cookies document-fx - set and get on js/document attributes clipboard-fx - write to the system clipboard re-frame-youtube-fx - YouTube iframe API wrapper re-frame-web3-fx - Ethereum Web3 API re-frame-google-analytics-fx - Google Analytics API re-frame-storage - Local Storage based persistence re-frame-storage-fx - Another take on Local Storage persistence re-frame-firebase - Firebase DB API sse-fx - fx/cofx handlers for EventSource and SSE","title":"Effect and CoEffect Handlers"},{"location":"External-Resources/#forms","text":"Fork Form Library. Inspired by formik. re-form free-form re-frame-forms","title":"Forms"},{"location":"External-Resources/#routing","text":"Bidirectional using Silk and Pushy","title":"Routing"},{"location":"External-Resources/#tools-techniques-libraries","text":"re-fill - routing and more re-frame-undo - An undo library for re-frame re-frame-test - Advanced testing utilities Animation using react-flip-move re-thread - A library for running re-frame applications in Web Workers. re-frame-datatable - DataTable UI component built for use with re-frame. Stately: State Machines also https://www.youtube.com/watch?v=klqorRUPluw re-learn - Data driven tutorials for educating users of your reagent / re-frame app subgraph - Reactive graph database for re-frame re-graph - GraphQL client for re-frame martian - Swagger-compatible API client that abstracts away from HTTP with re-frame bindings re-pressed - A keyboard event library for re-frame re-pollsive - A polling event library for re-frame breaking-point - Quickly define screen breakpoints for re-frame re-frame-flow - A graph based visualization tool for re-frame event chains","title":"Tools, Techniques &amp; Libraries"},{"location":"External-Resources/#suites","text":"reflet - Fast multi-model db, mix graph/non-graph data, graph queries/mutations, hierarchical FSMs, JS/DOM interop utils, component APIs, novel visual debugging","title":"Suites"},{"location":"External-Resources/#other","text":"re-posh is re-frame + Datalog","title":"Other"},{"location":"External-Resources/#videos","text":"A three part video series A Video Tour of the Source Code of Ninja Tools Funding Circle Clojure Meetup: Modular Users Interfaces with Re-frame Build your next single page app in ClojureScript and re-frame Clojurescript re-frame Tutorial Part 1 - Events and Event Handlers From 0 to prototype using ClojureScript, re-frame and friends: Martin Clausen Re-usable GUI Components with Re-frame and Atomic Design - Mark Nutter clojureD 2018: \"Reframing your next Single Page App\" by Kenneth Kalmer","title":"Videos"},{"location":"External-Resources/#server-side-rendering","text":"isomorphic-rendering Prerenderer - Server pre-rendering library using NodeJS that works with re-frame 0.6.0 (later versions untested) Rationale Part 1 Part 2 Part 3 Release Announcement Server Side Rendering with re-frame - Blog post on rendering re-frame views with Clojure. Rendering Reagent on the Server Using Hiccup - Blog post on rendering Reagent with Clojure. Prerendering a re-frame app with Chrome Headless - Blog post on prerendering a re-frame app using etaoin and Chrome Headless.","title":"Server Side Rendering"},{"location":"Interceptors/","text":"This tutorial explains re-frame Interceptors . Until now, they have been a hidden detail but, as we are about to find out, they are both important and useful. Why Interceptors? \u00b6 There's two reasons. We want simple event handlers . Interceptors allow us nicely to look after \"cross-cutting\" concerns like undo, tracing and validation. They help us to factor out commonality, hide complexity and introduce further steps into the \"Derived Data, Flowing\" story promoted by re-frame. So, you'll want to use Interceptors because they solve problems, and help you to write nice code. Under the covers, Interceptors provide the mechanism underneath Domino 2 (event handling) and Domino 3 (effect handling). They are a central concept and understanding them better will serve you well, even if you don't need to directly use them very often. What Do Interceptors Do? \u00b6 They wrap. Specifically, they wrap event handlers. Imagine your event handler is like a piece of ham. An interceptor would be like bread on either side of your ham, which makes a sandwich. And two Interceptors, in a chain, would be like you put another pair of bread slices around the outside of the existing sandwich to make a sandwich of the sandwich. Now it is a very thick sandwich. Interceptors wrap on both sides of an event handler, layer after layer. Wait, I know That Pattern! \u00b6 Interceptors implement middleware , but differently. Traditional middleware - often seen in web servers - creates a data processing pipeline (to process arriving HTTP requests) via the nested composition of higher order functions. The result is a \"stack\" of functions. Data representing a request flows through this pipeline, first forwards from one end to the other, and then backwards (as the response). Interceptors achieve the same outcome by assembling functions, as data, in a collection - a chain of interceptors, rather than a stack of middleware. Data can then be iteratively pipelined, first forwards through the functions in the chain, and then backwards along the same chain. Because the interceptor pipeline is composed via a collection (data!), rather than higher order functions, it is a more flexible arrangement. What's In The Pipeline? \u00b6 Data. It flows through the pipeline being progressively transformed. Fine. But what data? With a web server, the middleware \"stack\" progressively transforms an HTTP request in one direction, and, then in the backwards sweep, it progressively produces a response . In re-frame, the forward sweep progressively creates coeffects (inputs to the event handler that you write), while the backwards sweep processes the effects (outputs from the event handler you write). I'll pause while you read that sentence again. That's the key concept, right there. Show Me \u00b6 At the time when you register an event handler, you can provide a chain of interceptors too. Using a 3-arity registration function: ( reg-event-db :some-id [ in1 in2 ] ;; <-- a chain of 2 interceptors (a vector of 2 interceptors) ( fn [ db v ] ;; <-- the handler here, as before .... ))) Each Event Handler can have its own tailored interceptor chain, provided at registration-time. Handlers Are Interceptors Too \u00b6 You could see that registration above as associating :some-id with two things: a chain of 2 interceptors [in1 in2] an event handler . Except, the event handler is turned into an interceptor too (we'll see how shortly). So, actually , :some-id is only associated with one thing: a 3-chain of interceptors, with the event handler wrapped in an interceptor, called say ih , and put on the end of the other two, forming a vector of three interceptors: [in1 in2 ih] . But wait, there's more. The registration function itself, reg-event-db , actually takes this 3-chain and inserts its own standard interceptors, called say std1 and std2 (which do useful things, again more soon) at the front, so ACTUALLY , there's about 5 interceptors in the chain: [std1 std2 in1 in2 ih] So, ultimately, that event registration associates the event id :some-id with just a chain of interceptors. Nothing more. Later, when a (dispatch [:some-id ...]) happens, that 5-chain of interceptors will be \"executed\". And that's how an event gets handled. The Links Of The Chain \u00b6 Each interceptor has this form: { :id :something ;; decorative only - can be ignored :comment { ... } ;; also decorative, optional :before ( fn [ context ] ... ) ;; returns a possibly modified `context` :after ( fn [ context ] ... )} ;; returns a possibly modified `context` That's essentially a map of two functions. Now imagine a vector of these maps - that's an interceptor chain. Above we imagined an interceptor chain of [std1 std2 in1 in2 ih] . Now we know that this is really a vector of 5 maps: [{...} {...} {...} {...} {...}] where each of the 5 maps have a :before and :after fn. Sometimes, the :before and :after functions are noops - they take a context and return that context unchanged - think identity . To \"execute\" an interceptor chain: create a context (which is a map with a certain structure, described below) iterate forwards over the chain, calling the :before function on each interceptor, threading context through each call. iterate over the chain in the opposite (backwards) direction calling the :after function on each interceptor and threading context through all the calls Remember that the last interceptor in the chain is the event handler itself (wrapped up to be the :before ). That's it. That's how an event gets handled. This is how Dominoes 2 and 3 happen. What Is Context? \u00b6 Some data called a context is threaded through all the calls. This value is passed as the argument to every :before and :after function and it is returned by each function, possibly modified. A context is a map with this structure: { :coeffects { :event [ :some-id :some-param ] :db <original contents of app-db> } :effects { :db <new value for app-db> :dispatch [ :an-event-id :param1 ]} :queue <a collection of further interceptors> :stack <a collection of interceptors already walked> } context has a :coeffects key and an :effects key which, if this was a web server, would be somewhat analogous to request and response respectively. :coeffects will contain the inputs required by the event handler (sitting presumably on the end of the chain). So that's data like the :event being processed, and the initial state of db . The handler-returned side effects are put into :effects including, but not limited to, a new value for app-db . The first few interceptors in a chain (the ones inserted by reg-event-db ) have :before functions which prime the :coeffects by adding in :event , and :db . Of course, other interceptors can add further to :coeffects . Perhaps the event handler needs data from localstore, or a random number, or a DataScript connection. Interceptors can accumulate interesting information into :coeffects , via their :before function. Equally, some interceptors in the chain will have an :after function which processes the side effects accumulated into :effects including, but not limited to, updates to app-db . Threading the Context \u00b6 Above, we imagined an interceptor chain like: [std1 std2 in1 in2 ih] . One way to imagine the whole event handling process would be to see it written like this: ;; start by creating a context map ( let [ context { :coeffects {} :effects {} ... }] ( -> context ;; Thread `context` through all the `:before` functions. ;; This phase is usually concerned with building up `:coeffects` (( :before std1 ) ) ;; noop (( :before std2 ) ) ;; adds `:event` and `:db` to `:coeffects` (( :before in1 ) ) (( :before in2 ) ) (( :before ih ) ) ;; Domino 2 - handler called & return value put into `:effects` ;; Now backwards through the `:after` functions ;; This phase is usually concerned with building up or processing `:effects` ;; But could involve side effects like logging, or undo/redo state actions, etc (( :after ih ) ) ;; noop (( :after in2 ) ) (( :after in1 ) ) (( :after std2 ) ) ;; noop (( :after std1 ) ) ;; Domino 3 - all the `:effects` are processed Infographics \u00b6 Self Modifying \u00b6 There's something not shown in the above schematic. Through both stages (the :before sweep and the :after sweep), context also contains a :queue key which is the queue interceptors yet to be processed, and a :stack key which is vector of of the interceptors already done. In advanced cases, these two values, within a context , can be modified by the :before and :after functions through which the context is threaded. So interceptors can be dynamically added and removed from :queue and :stack by Interceptors already in the chain. Credit \u00b6 All truths are easy to understand once they are discovered -- Galileo Galilei This elegant and flexible arrangement was originally designed by the Pedestal Team . Thanks! Let's Write An Interceptor \u00b6 Dunno about you, but I'm easily offended by underscores. Imagine we had a view which did this: ( dispatch [ :delete-item 42 ]) We'd have to write this event handler: ( reg-event-db :delete-item ( fn [ db [ _ key-to-delete ]] ;; <---- Arrgggghhh underscore ( dissoc db key-to-delete ))) Do you see it there? That _ in the event destructuring!!! Almost mocking us with that passive aggressive, understated thing it has going on!! Co-workers have said I'm \"being overly sensitive\", perhaps even pixel-ist, but you can see it too, right? Of course you can. What a relief it would be to not have it there, but how? We'll write an interceptor: trim-event Once we have written trim-event , our registration will change to look like this: ( reg-event-db :delete-item [ trim-event ] ;; <--- interceptor added ( fn [ db [ key-to-delete ]] ;; <---yaaah! no leading underscore ( dissoc db key-to-delete ))) trim-event will need to change the :coeffects map (within context ). Specifically, it will be changing the :event value within the :coeffects . :event will start off as [:delete-item 42] , but will end up [42] by the time it is supplied to the handler. trim-event will remove that leading :delete-item because, by the time the event is being processed, we already know what id it has. And, so here it is: ( def trim-event ( re-frame.core/->interceptor :id :trim-event :before ( fn [ context ] ( let [ trim-fn ( fn [ event ] ( -> event rest vec ))] ( update-in context [ :coeffects :event ] trim-fn ))))) As you read this, look back to what a context looks like. Notes: We use the API function ->interceptor to create an interceptor (which is just a map) Our interceptor only has a :before function Our :before is given context . It modifies it and returns it. There is no :after for this Interceptor. It has nothing to do with the backwards processing flow of :effects . It is concerned only with :coeffects in the forward flow. Wrapping Handlers \u00b6 We're going well. Let's do an advanced wrapping. Earlier, in the \"Handlers Are Interceptors Too\" section, I explained that event handlers are wrapped in an Interceptor and placed on the end of an Interceptor chain. Remember the whole [std1 std2 in1 in2 ih] thing? We'll now look at the ih bit. How does an event handler get wrapped to be an Interceptor? Reminder - there's two kinds of event handler: the -db variety registered by reg-event-db the -fx variety registered by reg-event-fx I'll now show how to wrap the -db variety. Reminder: here's what a -db handler looks like: ( fn [ db event ] ;; takes two params ( assoc db :flag true )) ;; returns a new db So, we'll be writing a function which takes a -db handler as an argument, and returns an Interceptor which wraps that handler: ( defn db-handler->interceptor [ db-handler-fn ] ( re-frame.core/->interceptor ;; an API function supplied by re-frame :id :db-handler ;; ids are decorative only :before ( fn [ context ] ;; this interceptor only has a `:before ( let [{ :keys [ db event ]} ( :coeffects context ) ;; extract db and event from coeffects new-db ( db-handler-fn db event )] ;; call the event handler ( assoc-in context [ :effects :db ] new-db )))))) ;; put db back into :effects, as `:db` effect Notes: Notice how this wrapper extracts data from the context's :coeffects and then calls the handler with that data (a handler must be called with two args: db and event ) Equally notice how this wrapping takes the return value from db-handler-fn handler and puts it into context's :effects The modified context (it has a new :effects ) is returned This is all done in :before . There is no :after (it is a noop). But this could have been reversed with the work happening in :after and :before a noop. Shrug. Remember that this Interceptor will be on the end of a chain. Feeling confident? Try writing the wrapper for -fx handlers - it is just a small variation. Summary \u00b6 In this tutorial, we've learned: 1. When you register an event handler, you can supply a collection of Interceptors : ( reg-event-db :some-id [ in1 in2 ] ;; <-- a chain of 2 interceptors ( fn [ db v ] ;; <-- real handler here .... ))) 2. When you are registering an event handler, you are associating an event id with a chain of interceptors including: the ones you supply (optional) in1 and in2 an extra one on the end, which wraps the event handler itself (we called it ih ) a couple at the beginning of the chain std1 & std2 , put there by the reg-event-db or reg-event-fx . the entire interceptor chain might end up a vector of 5 - [std1 std2 in1 in2 ih] 3. An Interceptor Chain is executed in two stages. First a forwards sweep in which all :before functions are called, and then second, a backwards sweep in which the :after functions are called. A context map will be threaded through all these calls. An Interceptor chain is a reified \"call stack\". 4. Interceptors do interesting things to context : add to :coeffects (data inputs to the handler) process side :effects (returned by a handler) produce logs further process In the next Tutorial, we'll look at (side) Effects in more depth. Later again, we'll look at Coeffects. Appendix - Built-in Interceptors \u00b6 re-frame comes with some built-in Interceptors: debug : log each event as it is processed. Shows incremental clojure.data/diff reports. trim-v : a convenience. More readable handlers. And some Interceptor factories (functions that return Interceptors): enrich : perform additional computations (validations?), after the handler has run. More derived data flowing. after : perform side effects, after a handler has run. Eg: use it to report if the data in app-db matches a schema. path : a convenience. Simplifies our handlers. Acts almost like update-in . In addition, a Library like re-frame-undo provides an Interceptor factory called undoable which checkpoints app state. To use them, first require them: ( ns my.core ( :require [ re-frame.core :refer [ debug path ]])","title":"Interceptors"},{"location":"Interceptors/#why-interceptors","text":"There's two reasons. We want simple event handlers . Interceptors allow us nicely to look after \"cross-cutting\" concerns like undo, tracing and validation. They help us to factor out commonality, hide complexity and introduce further steps into the \"Derived Data, Flowing\" story promoted by re-frame. So, you'll want to use Interceptors because they solve problems, and help you to write nice code. Under the covers, Interceptors provide the mechanism underneath Domino 2 (event handling) and Domino 3 (effect handling). They are a central concept and understanding them better will serve you well, even if you don't need to directly use them very often.","title":"Why Interceptors?"},{"location":"Interceptors/#what-do-interceptors-do","text":"They wrap. Specifically, they wrap event handlers. Imagine your event handler is like a piece of ham. An interceptor would be like bread on either side of your ham, which makes a sandwich. And two Interceptors, in a chain, would be like you put another pair of bread slices around the outside of the existing sandwich to make a sandwich of the sandwich. Now it is a very thick sandwich. Interceptors wrap on both sides of an event handler, layer after layer.","title":"What Do Interceptors Do?"},{"location":"Interceptors/#wait-i-know-that-pattern","text":"Interceptors implement middleware , but differently. Traditional middleware - often seen in web servers - creates a data processing pipeline (to process arriving HTTP requests) via the nested composition of higher order functions. The result is a \"stack\" of functions. Data representing a request flows through this pipeline, first forwards from one end to the other, and then backwards (as the response). Interceptors achieve the same outcome by assembling functions, as data, in a collection - a chain of interceptors, rather than a stack of middleware. Data can then be iteratively pipelined, first forwards through the functions in the chain, and then backwards along the same chain. Because the interceptor pipeline is composed via a collection (data!), rather than higher order functions, it is a more flexible arrangement.","title":"Wait, I know That Pattern!"},{"location":"Interceptors/#whats-in-the-pipeline","text":"Data. It flows through the pipeline being progressively transformed. Fine. But what data? With a web server, the middleware \"stack\" progressively transforms an HTTP request in one direction, and, then in the backwards sweep, it progressively produces a response . In re-frame, the forward sweep progressively creates coeffects (inputs to the event handler that you write), while the backwards sweep processes the effects (outputs from the event handler you write). I'll pause while you read that sentence again. That's the key concept, right there.","title":"What's In The Pipeline?"},{"location":"Interceptors/#show-me","text":"At the time when you register an event handler, you can provide a chain of interceptors too. Using a 3-arity registration function: ( reg-event-db :some-id [ in1 in2 ] ;; <-- a chain of 2 interceptors (a vector of 2 interceptors) ( fn [ db v ] ;; <-- the handler here, as before .... ))) Each Event Handler can have its own tailored interceptor chain, provided at registration-time.","title":"Show Me"},{"location":"Interceptors/#handlers-are-interceptors-too","text":"You could see that registration above as associating :some-id with two things: a chain of 2 interceptors [in1 in2] an event handler . Except, the event handler is turned into an interceptor too (we'll see how shortly). So, actually , :some-id is only associated with one thing: a 3-chain of interceptors, with the event handler wrapped in an interceptor, called say ih , and put on the end of the other two, forming a vector of three interceptors: [in1 in2 ih] . But wait, there's more. The registration function itself, reg-event-db , actually takes this 3-chain and inserts its own standard interceptors, called say std1 and std2 (which do useful things, again more soon) at the front, so ACTUALLY , there's about 5 interceptors in the chain: [std1 std2 in1 in2 ih] So, ultimately, that event registration associates the event id :some-id with just a chain of interceptors. Nothing more. Later, when a (dispatch [:some-id ...]) happens, that 5-chain of interceptors will be \"executed\". And that's how an event gets handled.","title":"Handlers Are Interceptors Too"},{"location":"Interceptors/#the-links-of-the-chain","text":"Each interceptor has this form: { :id :something ;; decorative only - can be ignored :comment { ... } ;; also decorative, optional :before ( fn [ context ] ... ) ;; returns a possibly modified `context` :after ( fn [ context ] ... )} ;; returns a possibly modified `context` That's essentially a map of two functions. Now imagine a vector of these maps - that's an interceptor chain. Above we imagined an interceptor chain of [std1 std2 in1 in2 ih] . Now we know that this is really a vector of 5 maps: [{...} {...} {...} {...} {...}] where each of the 5 maps have a :before and :after fn. Sometimes, the :before and :after functions are noops - they take a context and return that context unchanged - think identity . To \"execute\" an interceptor chain: create a context (which is a map with a certain structure, described below) iterate forwards over the chain, calling the :before function on each interceptor, threading context through each call. iterate over the chain in the opposite (backwards) direction calling the :after function on each interceptor and threading context through all the calls Remember that the last interceptor in the chain is the event handler itself (wrapped up to be the :before ). That's it. That's how an event gets handled. This is how Dominoes 2 and 3 happen.","title":"The Links Of The Chain"},{"location":"Interceptors/#what-is-context","text":"Some data called a context is threaded through all the calls. This value is passed as the argument to every :before and :after function and it is returned by each function, possibly modified. A context is a map with this structure: { :coeffects { :event [ :some-id :some-param ] :db <original contents of app-db> } :effects { :db <new value for app-db> :dispatch [ :an-event-id :param1 ]} :queue <a collection of further interceptors> :stack <a collection of interceptors already walked> } context has a :coeffects key and an :effects key which, if this was a web server, would be somewhat analogous to request and response respectively. :coeffects will contain the inputs required by the event handler (sitting presumably on the end of the chain). So that's data like the :event being processed, and the initial state of db . The handler-returned side effects are put into :effects including, but not limited to, a new value for app-db . The first few interceptors in a chain (the ones inserted by reg-event-db ) have :before functions which prime the :coeffects by adding in :event , and :db . Of course, other interceptors can add further to :coeffects . Perhaps the event handler needs data from localstore, or a random number, or a DataScript connection. Interceptors can accumulate interesting information into :coeffects , via their :before function. Equally, some interceptors in the chain will have an :after function which processes the side effects accumulated into :effects including, but not limited to, updates to app-db .","title":"What Is Context?"},{"location":"Interceptors/#threading-the-context","text":"Above, we imagined an interceptor chain like: [std1 std2 in1 in2 ih] . One way to imagine the whole event handling process would be to see it written like this: ;; start by creating a context map ( let [ context { :coeffects {} :effects {} ... }] ( -> context ;; Thread `context` through all the `:before` functions. ;; This phase is usually concerned with building up `:coeffects` (( :before std1 ) ) ;; noop (( :before std2 ) ) ;; adds `:event` and `:db` to `:coeffects` (( :before in1 ) ) (( :before in2 ) ) (( :before ih ) ) ;; Domino 2 - handler called & return value put into `:effects` ;; Now backwards through the `:after` functions ;; This phase is usually concerned with building up or processing `:effects` ;; But could involve side effects like logging, or undo/redo state actions, etc (( :after ih ) ) ;; noop (( :after in2 ) ) (( :after in1 ) ) (( :after std2 ) ) ;; noop (( :after std1 ) ) ;; Domino 3 - all the `:effects` are processed","title":"Threading the Context"},{"location":"Interceptors/#infographics","text":"","title":"Infographics"},{"location":"Interceptors/#self-modifying","text":"There's something not shown in the above schematic. Through both stages (the :before sweep and the :after sweep), context also contains a :queue key which is the queue interceptors yet to be processed, and a :stack key which is vector of of the interceptors already done. In advanced cases, these two values, within a context , can be modified by the :before and :after functions through which the context is threaded. So interceptors can be dynamically added and removed from :queue and :stack by Interceptors already in the chain.","title":"Self Modifying"},{"location":"Interceptors/#credit","text":"All truths are easy to understand once they are discovered -- Galileo Galilei This elegant and flexible arrangement was originally designed by the Pedestal Team . Thanks!","title":"Credit"},{"location":"Interceptors/#lets-write-an-interceptor","text":"Dunno about you, but I'm easily offended by underscores. Imagine we had a view which did this: ( dispatch [ :delete-item 42 ]) We'd have to write this event handler: ( reg-event-db :delete-item ( fn [ db [ _ key-to-delete ]] ;; <---- Arrgggghhh underscore ( dissoc db key-to-delete ))) Do you see it there? That _ in the event destructuring!!! Almost mocking us with that passive aggressive, understated thing it has going on!! Co-workers have said I'm \"being overly sensitive\", perhaps even pixel-ist, but you can see it too, right? Of course you can. What a relief it would be to not have it there, but how? We'll write an interceptor: trim-event Once we have written trim-event , our registration will change to look like this: ( reg-event-db :delete-item [ trim-event ] ;; <--- interceptor added ( fn [ db [ key-to-delete ]] ;; <---yaaah! no leading underscore ( dissoc db key-to-delete ))) trim-event will need to change the :coeffects map (within context ). Specifically, it will be changing the :event value within the :coeffects . :event will start off as [:delete-item 42] , but will end up [42] by the time it is supplied to the handler. trim-event will remove that leading :delete-item because, by the time the event is being processed, we already know what id it has. And, so here it is: ( def trim-event ( re-frame.core/->interceptor :id :trim-event :before ( fn [ context ] ( let [ trim-fn ( fn [ event ] ( -> event rest vec ))] ( update-in context [ :coeffects :event ] trim-fn ))))) As you read this, look back to what a context looks like. Notes: We use the API function ->interceptor to create an interceptor (which is just a map) Our interceptor only has a :before function Our :before is given context . It modifies it and returns it. There is no :after for this Interceptor. It has nothing to do with the backwards processing flow of :effects . It is concerned only with :coeffects in the forward flow.","title":"Let's Write An Interceptor"},{"location":"Interceptors/#wrapping-handlers","text":"We're going well. Let's do an advanced wrapping. Earlier, in the \"Handlers Are Interceptors Too\" section, I explained that event handlers are wrapped in an Interceptor and placed on the end of an Interceptor chain. Remember the whole [std1 std2 in1 in2 ih] thing? We'll now look at the ih bit. How does an event handler get wrapped to be an Interceptor? Reminder - there's two kinds of event handler: the -db variety registered by reg-event-db the -fx variety registered by reg-event-fx I'll now show how to wrap the -db variety. Reminder: here's what a -db handler looks like: ( fn [ db event ] ;; takes two params ( assoc db :flag true )) ;; returns a new db So, we'll be writing a function which takes a -db handler as an argument, and returns an Interceptor which wraps that handler: ( defn db-handler->interceptor [ db-handler-fn ] ( re-frame.core/->interceptor ;; an API function supplied by re-frame :id :db-handler ;; ids are decorative only :before ( fn [ context ] ;; this interceptor only has a `:before ( let [{ :keys [ db event ]} ( :coeffects context ) ;; extract db and event from coeffects new-db ( db-handler-fn db event )] ;; call the event handler ( assoc-in context [ :effects :db ] new-db )))))) ;; put db back into :effects, as `:db` effect Notes: Notice how this wrapper extracts data from the context's :coeffects and then calls the handler with that data (a handler must be called with two args: db and event ) Equally notice how this wrapping takes the return value from db-handler-fn handler and puts it into context's :effects The modified context (it has a new :effects ) is returned This is all done in :before . There is no :after (it is a noop). But this could have been reversed with the work happening in :after and :before a noop. Shrug. Remember that this Interceptor will be on the end of a chain. Feeling confident? Try writing the wrapper for -fx handlers - it is just a small variation.","title":"Wrapping Handlers"},{"location":"Interceptors/#summary","text":"In this tutorial, we've learned: 1. When you register an event handler, you can supply a collection of Interceptors : ( reg-event-db :some-id [ in1 in2 ] ;; <-- a chain of 2 interceptors ( fn [ db v ] ;; <-- real handler here .... ))) 2. When you are registering an event handler, you are associating an event id with a chain of interceptors including: the ones you supply (optional) in1 and in2 an extra one on the end, which wraps the event handler itself (we called it ih ) a couple at the beginning of the chain std1 & std2 , put there by the reg-event-db or reg-event-fx . the entire interceptor chain might end up a vector of 5 - [std1 std2 in1 in2 ih] 3. An Interceptor Chain is executed in two stages. First a forwards sweep in which all :before functions are called, and then second, a backwards sweep in which the :after functions are called. A context map will be threaded through all these calls. An Interceptor chain is a reified \"call stack\". 4. Interceptors do interesting things to context : add to :coeffects (data inputs to the handler) process side :effects (returned by a handler) produce logs further process In the next Tutorial, we'll look at (side) Effects in more depth. Later again, we'll look at Coeffects.","title":"Summary"},{"location":"Interceptors/#appendix-built-in-interceptors","text":"re-frame comes with some built-in Interceptors: debug : log each event as it is processed. Shows incremental clojure.data/diff reports. trim-v : a convenience. More readable handlers. And some Interceptor factories (functions that return Interceptors): enrich : perform additional computations (validations?), after the handler has run. More derived data flowing. after : perform side effects, after a handler has run. Eg: use it to report if the data in app-db matches a schema. path : a convenience. Simplifies our handlers. Acts almost like update-in . In addition, a Library like re-frame-undo provides an Interceptor factory called undoable which checkpoints app state. To use them, first require them: ( ns my.core ( :require [ re-frame.core :refer [ debug path ]])","title":"Appendix - Built-in Interceptors"},{"location":"Loading-Initial-Data/","text":"Bootstrapping Application State \u00b6 To bootstrap a re-frame application, you need to: register handlers: subscription (via reg-sub ) events (via reg-event-db or reg-event-fx ) effects (via reg-fx ) coeffects (via reg-cofx ) kickstart reagent (views) Load the right initial data into app-db which might, for example, be a merge of: Some default values Values stored in LocalStorage Values obtained via service calls to server Point 3 is the interesting bit and will be the main focus of this page, but let's work our way through them ... 1. Register Handlers \u00b6 re-frame's various handlers all work in the same way. You declare and register your handlers in the one step, like this \"event handler\" example: ( re-frame/reg-event-db ;; event handler will be registered automatically :some-id ( fn [ db [ _ value ]] ... do some state change based on db and value )) As a result, there's nothing further you need to do because handler registration happens as a direct result of loading the code (presumably via a <script> tag in your HTML file). 2. Kick Start Reagent \u00b6 Create a function main which does a reagent/render of your root reagent component main-panel : ( defn main-panel ;; my top level reagent component [] [ :div \"Hello DDATWD\" ]) ( defn ^ :export main ;; call this to bootstrap your app [] ( reagent.dom/render [ main-panel ] ( js/document.getElementById \"app\" ))) Mounting the top level component main-panel will trigger a cascade of child component creation. The full DOM tree will be rendered. 3. Loading Initial Data \u00b6 Let's rewrite our main-panel component to use a subscription. In effect, we want it to source and render some data held in app-db . First, we'll create the subscription handler: ( re-frame.core/reg-sub ;; a new subscription handler :name ;; usage (subscribe [:name]) ( fn [ db _ ] ( :display-name db ))) ;; extracts `:display-name` from app-db And now we use that subscription: ( defn main-panel [] ( let [ name ( re-frame.core/subscribe [ :name ])] ;; <--- a subscription <--- [ :div \"Hello \" @ name ]))) ;; <--- use the result of the subscription The user of our app will see funny things if that (subscribe [:name]) doesn't deliver good data. But how do we ensure \"good data\"? That will require: 1. getting data into app-db ; and 2. not get into trouble if that data isn't yet in app-db . For example, the data may have to come from a server and there's latency. Note: app-db initially contains {} Getting Data Into app-db \u00b6 Only event handlers can change app-db . Those are the rules!! Indeed, even initial values must be put in app-db via an event handler. Here's an event handler for that purpose: ( re-frame.core/reg-event-db :initialise-db ;; usage: (dispatch [:initialise-db]) ( fn [ _ _ ] ;; Ignore both params (db and event) { :display-name \"DDATWD\" ;; return a new value for app-db :items [ 1 2 3 4 ]})) You'll notice that this handler does nothing other than to return a map . That map will become the new value within app-db . We'll need to dispatch an :initialise-db event to get it to execute. main seems like the natural place: ( defn ^ :export main [] ( re-frame.core/dispatch [ :initialise-db ]) ;; <--- this is new ( reagent.dom/render [ main-panel ] ( js/document.getElementById \"app\" ))) But remember, event handlers execute async. So although there's a dispatch within main , the event is simply queued, and the handler for :initialise-db will not be run until sometime after main has finished. But how long after? And is there a race condition? The component main-panel (which assumes good data) might be rendered before the :initialise-db event handler has put good data into app-db . We don't want any rendering (of main-panel ) until after app-db has been correctly initialised. Okay, so that's enough of teasing-out the issues. Let's see a quick sketch of the entire pattern. It is very straight-forward. The Pattern \u00b6 ( re-frame.core/reg-sub ;; supplied main-panel with data :name ;; usage (subscribe [:name]) ( fn [ db _ ] ( :display-name db ))) ( re-frame.core/reg-sub ;; we can check if there is data :initialised? ;; usage (subscribe [:initialised?]) ( fn [ db _ ] ( not ( empty? db )))) ;; do we have data ( re-frame.core/reg-event-db :initialise-db ( fn [ db _ ] ( assoc db :display-name \"Jane Doe\" ))) ( defn main-panel ;; the top level of our app [] ( let [ name ( re-frame.core/subscribe [ :name ])] ;; we need there to be good data [ :div \"Hello \" @ name ]))) ( defn top-panel ;; this is new [] ( let [ ready? ( re-frame.core/subscribe [ :initialised? ])] ( if-not @ ready? ;; do we have good data? [ :div \"Initialising ...\" ] ;; tell them we are working on it [ main-panel ]))) ;; all good, render this component ( defn ^ :export main ;; call this to bootstrap your app [] ( re-frame.core/dispatch [ :initialise-db ]) ( reagent.dom/render [ top-panel ] ( js/document.getElementById \"app\" ))) Scales Up \u00b6 This pattern scales up easily. For example, imagine a more complicated scenario in which your app is not fully initialised until 2 backend services supply data. Your main might look like this: ( defn ^ :export main ;; call this to bootstrap your app [] ( re-frame.core/dispatch [ :initialise-db ]) ;; basics ( re-frame.core/dispatch [ :load-from-service-1 ]) ;; ask for data from service-1 ( re-frame.core/dispatch [ :load-from-service-2 ]) ;; ask for data from service-2 ( reagent.dom/render [ top-panel ] ( js/document.getElementById \"app\" ))) Your :initialised? test then becomes more like this sketch: ( re-frame.core/reg-sub :initialised? ;; usage (subscribe [:initialised?]) ( fn [ db _ ] ( and ( not ( empty? db )) ( :service1-answered? db ) ( :service2-answered? db ))))) This assumes boolean flags are set in app-db when data was loaded from these services. Cheating - Synchronous Dispatch \u00b6 In simple cases, you can simplify matters by using dispatch-sync (instead of dispatch ) in the main function. This technique can be seen in the TodoMVC Example . dispatch queues an event for later processing, but dispatch-sync acts like a function call and handles an event immediately. That's useful for initial data load we are considering, particularly for simple apps. Using dispatch-sync guarantees that initial state will be in place before any views are mounted, so we know they'll subscribe to sensible values. We don't need a guard like top-panel (introduced above). But don't get into the habit of using dispatch-sync everywhere. It is the right tool in this context and, sometimes, when writing tests, but dispatch is the staple you should use everywhere else. Loading Initial Data From Services \u00b6 Above, in our example main , we imagined using (re-frame/dispatch [:load-from-service-1]) to request data from a backend services. How would we write the handler for this event? The next Tutorial will show you how.","title":"Loading Initial Data"},{"location":"Loading-Initial-Data/#bootstrapping-application-state","text":"To bootstrap a re-frame application, you need to: register handlers: subscription (via reg-sub ) events (via reg-event-db or reg-event-fx ) effects (via reg-fx ) coeffects (via reg-cofx ) kickstart reagent (views) Load the right initial data into app-db which might, for example, be a merge of: Some default values Values stored in LocalStorage Values obtained via service calls to server Point 3 is the interesting bit and will be the main focus of this page, but let's work our way through them ...","title":"Bootstrapping Application State"},{"location":"Loading-Initial-Data/#1-register-handlers","text":"re-frame's various handlers all work in the same way. You declare and register your handlers in the one step, like this \"event handler\" example: ( re-frame/reg-event-db ;; event handler will be registered automatically :some-id ( fn [ db [ _ value ]] ... do some state change based on db and value )) As a result, there's nothing further you need to do because handler registration happens as a direct result of loading the code (presumably via a <script> tag in your HTML file).","title":"1. Register Handlers"},{"location":"Loading-Initial-Data/#2-kick-start-reagent","text":"Create a function main which does a reagent/render of your root reagent component main-panel : ( defn main-panel ;; my top level reagent component [] [ :div \"Hello DDATWD\" ]) ( defn ^ :export main ;; call this to bootstrap your app [] ( reagent.dom/render [ main-panel ] ( js/document.getElementById \"app\" ))) Mounting the top level component main-panel will trigger a cascade of child component creation. The full DOM tree will be rendered.","title":"2. Kick Start Reagent"},{"location":"Loading-Initial-Data/#3-loading-initial-data","text":"Let's rewrite our main-panel component to use a subscription. In effect, we want it to source and render some data held in app-db . First, we'll create the subscription handler: ( re-frame.core/reg-sub ;; a new subscription handler :name ;; usage (subscribe [:name]) ( fn [ db _ ] ( :display-name db ))) ;; extracts `:display-name` from app-db And now we use that subscription: ( defn main-panel [] ( let [ name ( re-frame.core/subscribe [ :name ])] ;; <--- a subscription <--- [ :div \"Hello \" @ name ]))) ;; <--- use the result of the subscription The user of our app will see funny things if that (subscribe [:name]) doesn't deliver good data. But how do we ensure \"good data\"? That will require: 1. getting data into app-db ; and 2. not get into trouble if that data isn't yet in app-db . For example, the data may have to come from a server and there's latency. Note: app-db initially contains {}","title":"3. Loading Initial Data"},{"location":"Loading-Initial-Data/#getting-data-into-app-db","text":"Only event handlers can change app-db . Those are the rules!! Indeed, even initial values must be put in app-db via an event handler. Here's an event handler for that purpose: ( re-frame.core/reg-event-db :initialise-db ;; usage: (dispatch [:initialise-db]) ( fn [ _ _ ] ;; Ignore both params (db and event) { :display-name \"DDATWD\" ;; return a new value for app-db :items [ 1 2 3 4 ]})) You'll notice that this handler does nothing other than to return a map . That map will become the new value within app-db . We'll need to dispatch an :initialise-db event to get it to execute. main seems like the natural place: ( defn ^ :export main [] ( re-frame.core/dispatch [ :initialise-db ]) ;; <--- this is new ( reagent.dom/render [ main-panel ] ( js/document.getElementById \"app\" ))) But remember, event handlers execute async. So although there's a dispatch within main , the event is simply queued, and the handler for :initialise-db will not be run until sometime after main has finished. But how long after? And is there a race condition? The component main-panel (which assumes good data) might be rendered before the :initialise-db event handler has put good data into app-db . We don't want any rendering (of main-panel ) until after app-db has been correctly initialised. Okay, so that's enough of teasing-out the issues. Let's see a quick sketch of the entire pattern. It is very straight-forward.","title":"Getting Data Into app-db"},{"location":"Loading-Initial-Data/#the-pattern","text":"( re-frame.core/reg-sub ;; supplied main-panel with data :name ;; usage (subscribe [:name]) ( fn [ db _ ] ( :display-name db ))) ( re-frame.core/reg-sub ;; we can check if there is data :initialised? ;; usage (subscribe [:initialised?]) ( fn [ db _ ] ( not ( empty? db )))) ;; do we have data ( re-frame.core/reg-event-db :initialise-db ( fn [ db _ ] ( assoc db :display-name \"Jane Doe\" ))) ( defn main-panel ;; the top level of our app [] ( let [ name ( re-frame.core/subscribe [ :name ])] ;; we need there to be good data [ :div \"Hello \" @ name ]))) ( defn top-panel ;; this is new [] ( let [ ready? ( re-frame.core/subscribe [ :initialised? ])] ( if-not @ ready? ;; do we have good data? [ :div \"Initialising ...\" ] ;; tell them we are working on it [ main-panel ]))) ;; all good, render this component ( defn ^ :export main ;; call this to bootstrap your app [] ( re-frame.core/dispatch [ :initialise-db ]) ( reagent.dom/render [ top-panel ] ( js/document.getElementById \"app\" )))","title":"The Pattern"},{"location":"Loading-Initial-Data/#scales-up","text":"This pattern scales up easily. For example, imagine a more complicated scenario in which your app is not fully initialised until 2 backend services supply data. Your main might look like this: ( defn ^ :export main ;; call this to bootstrap your app [] ( re-frame.core/dispatch [ :initialise-db ]) ;; basics ( re-frame.core/dispatch [ :load-from-service-1 ]) ;; ask for data from service-1 ( re-frame.core/dispatch [ :load-from-service-2 ]) ;; ask for data from service-2 ( reagent.dom/render [ top-panel ] ( js/document.getElementById \"app\" ))) Your :initialised? test then becomes more like this sketch: ( re-frame.core/reg-sub :initialised? ;; usage (subscribe [:initialised?]) ( fn [ db _ ] ( and ( not ( empty? db )) ( :service1-answered? db ) ( :service2-answered? db ))))) This assumes boolean flags are set in app-db when data was loaded from these services.","title":"Scales Up"},{"location":"Loading-Initial-Data/#cheating-synchronous-dispatch","text":"In simple cases, you can simplify matters by using dispatch-sync (instead of dispatch ) in the main function. This technique can be seen in the TodoMVC Example . dispatch queues an event for later processing, but dispatch-sync acts like a function call and handles an event immediately. That's useful for initial data load we are considering, particularly for simple apps. Using dispatch-sync guarantees that initial state will be in place before any views are mounted, so we know they'll subscribe to sensible values. We don't need a guard like top-panel (introduced above). But don't get into the habit of using dispatch-sync everywhere. It is the right tool in this context and, sometimes, when writing tests, but dispatch is the staple you should use everywhere else.","title":"Cheating - Synchronous Dispatch"},{"location":"Loading-Initial-Data/#loading-initial-data-from-services","text":"Above, in our example main , we imagined using (re-frame/dispatch [:load-from-service-1]) to request data from a backend services. How would we write the handler for this event? The next Tutorial will show you how.","title":"Loading Initial Data From Services"},{"location":"Performance-Problems/","text":"Things to watch out for ... Using = On Big Structures \u00b6 Reagent uses = to compare the previous value of a prop with the new value of that prop, when it determines if a component needs rerendering. Make sure you have a good understanding of this . In the worst case, if those props are big data structures which differ only in some tiny, leaf aspect, then a lot of CPU cycles will be spent doing the = comparison only to eventually work out that, indeed, the answer is false . This problem is exacerbated when components return a lot of hiccup, because lots of hiccup normally means lots of = work. Any rerender with those characteristics could end up chewing a lot of CPU cycles. An Example Of This Problem \u00b6 Imagine you were rendering a 19 by 19 \"Go\" board. And imagine that you have a high level board renderer component which creates hiccup for the 361 subcomponents (19 x 19 grid), and that it provides 3 props to each child: grid x coord grid y coord a chunk of data representing the current game state, from which each of the 361 individual grid components is expected to extract the data they need to render their grid position. This arrangement could be slow. First , you have a parent component returning hiccup for 361 sub-components and that's a lot of hiccup!! Sure, it might not be much code - just a couple of nested for , but the hiccup data structure built will be substantial. Second , after the board renderer returns all this hiccup, for every one of those 361 sub-components, Reagent must then check the 3 props to see if they are = to the value last rendered (to determine if they, in turn, need to be rerendered), and the comparison on the 3rd prop (game state) might be deep and expensive. Worse, we do the same expensive check 361 times in a row, and every time we get a false (because games state is not = to last time). Third , because Reagent gets 361 falses , it will further rerender all 361 sub-components even though 360 of them produce the same hiccup as last time - only one position in the grid has changed. So, when a new stone is placed on the board, and the game state changes, that triggers a large amount of unnecessary calculation, just to figure out that there's only a rendering change at one point in the 19x19 grid. So, that's how you can get a performance problem: lots of hiccup, mixed with time-consuming = tests on big props. Solutions To This Problem \u00b6 The solution is to not do the unnecessary work. Duh! Produce only the hiccup that is needed. Don't unnecessarily pass around big complicated state in props, unless you really need to. In the Go example described above, for each new stone placed, only one point in the Go board actually needs to be rerendered, and yet our code asked Reagent to chew a lot of CPU to figure that out. These kinds of tweaks would improve performance: don't give the entire game state to each of the 361 subcomponents and then ask them to extract what they need. Instead, give each just the state it needs, and nothing more. That will make the = process faster. It will also allow for Reagent to figure out that 360 of the subcomponents have the same props as last time, and don't need rerendering. And, so, only one sub-component will be rerendered when the parent \"board level\" component rerenders. Also, could you render the board row by row? So that less hiccup is produced by any one component? Can those rows subscribe to just the data for their row, so they only rerender when the row-data changes; they only generate hiccup when something really has changed? 3. Are you Using a React key ? \u00b6 Correctly using React keys can also make a huge difference to performance. Some resources: http://stackoverflow.com/questions/27863039/key-property-inside-component-function http://stackoverflow.com/a/37186230/5215391 https://groups.google.com/d/msg/reagent-project/J1ELaLV20MU/iutebA-JEgAJ 4. Callback Functions \u00b6 Consider this div : [ :div { :on-mouse-over ( fn [ event ] .... ) } \"hello\" ] On every render, that :on-mouse-over function will be regenerated, and the one generated \"this time\" will NOT test = to the one generated \"last time\". It will appear to be a new function. React will conclude that it must replace this event handler. Most of the time, this is not an issue. But if you are generating a LOT of DOM this small inefficiency can add up. To work around the problem, lift the function generation out of the render. Use a Form-2 function like this: ( defn my-component [] ( let [ mouse-over-cb ( fn [ event ] .... ) ] ;; created once ( fn [] ;; rendered many times [ :div { :on-mouse-over mouse-over-cb }])) Now, React will see that mouse-over-cb is the same as last time. It won't think the event handler has been replaced. But like I say, don't be too paranoid about this, it is unlikely to be an issue unless you have something like a table with a lot of identical cells. Use The Trace, Luke \u00b6 If you want to know exactly what's going on, get some X-Ray vision from the official tracer . See exactly what subscriptions are running, what views are getting re-rendered, etc. You may be surprised by what you see.","title":"Eek! Performance Problems"},{"location":"Performance-Problems/#using-on-big-structures","text":"Reagent uses = to compare the previous value of a prop with the new value of that prop, when it determines if a component needs rerendering. Make sure you have a good understanding of this . In the worst case, if those props are big data structures which differ only in some tiny, leaf aspect, then a lot of CPU cycles will be spent doing the = comparison only to eventually work out that, indeed, the answer is false . This problem is exacerbated when components return a lot of hiccup, because lots of hiccup normally means lots of = work. Any rerender with those characteristics could end up chewing a lot of CPU cycles.","title":"Using = On Big Structures"},{"location":"Performance-Problems/#an-example-of-this-problem","text":"Imagine you were rendering a 19 by 19 \"Go\" board. And imagine that you have a high level board renderer component which creates hiccup for the 361 subcomponents (19 x 19 grid), and that it provides 3 props to each child: grid x coord grid y coord a chunk of data representing the current game state, from which each of the 361 individual grid components is expected to extract the data they need to render their grid position. This arrangement could be slow. First , you have a parent component returning hiccup for 361 sub-components and that's a lot of hiccup!! Sure, it might not be much code - just a couple of nested for , but the hiccup data structure built will be substantial. Second , after the board renderer returns all this hiccup, for every one of those 361 sub-components, Reagent must then check the 3 props to see if they are = to the value last rendered (to determine if they, in turn, need to be rerendered), and the comparison on the 3rd prop (game state) might be deep and expensive. Worse, we do the same expensive check 361 times in a row, and every time we get a false (because games state is not = to last time). Third , because Reagent gets 361 falses , it will further rerender all 361 sub-components even though 360 of them produce the same hiccup as last time - only one position in the grid has changed. So, when a new stone is placed on the board, and the game state changes, that triggers a large amount of unnecessary calculation, just to figure out that there's only a rendering change at one point in the 19x19 grid. So, that's how you can get a performance problem: lots of hiccup, mixed with time-consuming = tests on big props.","title":"An Example Of This Problem"},{"location":"Performance-Problems/#solutions-to-this-problem","text":"The solution is to not do the unnecessary work. Duh! Produce only the hiccup that is needed. Don't unnecessarily pass around big complicated state in props, unless you really need to. In the Go example described above, for each new stone placed, only one point in the Go board actually needs to be rerendered, and yet our code asked Reagent to chew a lot of CPU to figure that out. These kinds of tweaks would improve performance: don't give the entire game state to each of the 361 subcomponents and then ask them to extract what they need. Instead, give each just the state it needs, and nothing more. That will make the = process faster. It will also allow for Reagent to figure out that 360 of the subcomponents have the same props as last time, and don't need rerendering. And, so, only one sub-component will be rerendered when the parent \"board level\" component rerenders. Also, could you render the board row by row? So that less hiccup is produced by any one component? Can those rows subscribe to just the data for their row, so they only rerender when the row-data changes; they only generate hiccup when something really has changed?","title":"Solutions To This Problem"},{"location":"Performance-Problems/#3-are-you-using-a-react-key","text":"Correctly using React keys can also make a huge difference to performance. Some resources: http://stackoverflow.com/questions/27863039/key-property-inside-component-function http://stackoverflow.com/a/37186230/5215391 https://groups.google.com/d/msg/reagent-project/J1ELaLV20MU/iutebA-JEgAJ","title":"3. Are you Using a React key?"},{"location":"Performance-Problems/#4-callback-functions","text":"Consider this div : [ :div { :on-mouse-over ( fn [ event ] .... ) } \"hello\" ] On every render, that :on-mouse-over function will be regenerated, and the one generated \"this time\" will NOT test = to the one generated \"last time\". It will appear to be a new function. React will conclude that it must replace this event handler. Most of the time, this is not an issue. But if you are generating a LOT of DOM this small inefficiency can add up. To work around the problem, lift the function generation out of the render. Use a Form-2 function like this: ( defn my-component [] ( let [ mouse-over-cb ( fn [ event ] .... ) ] ;; created once ( fn [] ;; rendered many times [ :div { :on-mouse-over mouse-over-cb }])) Now, React will see that mouse-over-cb is the same as last time. It won't think the event handler has been replaced. But like I say, don't be too paranoid about this, it is unlikely to be an issue unless you have something like a table with a lot of identical cells.","title":"4. Callback Functions"},{"location":"Performance-Problems/#use-the-trace-luke","text":"If you want to know exactly what's going on, get some X-Ray vision from the official tracer . See exactly what subscriptions are running, what views are getting re-rendered, etc. You may be surprised by what you see.","title":"Use The Trace, Luke"},{"location":"Solve-the-CPU-hog-problem/","text":"Sometimes a handler has a lot of CPU intensive work to do, and getting through it will take a while. When a handler hogs the CPU, nothing else can happen. Browsers only give us one thread of execution and that CPU-hogging handler owns it, and it isn't giving it up. The UI will be frozen and there will be no processing of any other handlers (eg: on-success of POSTs), etc, etc. Nothing. And a frozen UI is a problem. GUI repaints are not happening. And user interactions are not being processed. How are we to show progress updates like \"Hey, X% completed\"? Or how can we handle the user clicking on that \"Cancel\" button trying to stop this long-running process? We need a means by which long-running handlers can hand control back for \"other\" processing every so often, while still continuing on with their computation. The re-frame Solution \u00b6 First , all long-running, CPU-hogging processes are put in event handlers. Not in subscriptions. Not in components. Not hard to do, but worth establishing as a rule, right up front. Second , you must be able to break up that CPU work into chunks. You need a way to do part of the work, pause, then resume from where you left off (more in a minute). In a perfect world, each chunk would take something like 16ms (60 fps). If you go longer, say 50ms or 100ms, it is no train smash, but UI responsiveness will degrade and animations, like busy spinners, will get jerky. Shorter is better, but less than 16ms delivers no added smoothness. Third , within our handler, after it completes one unit (chunk) of work, it should not continue straight on with the next. Instead, it should do a dispatch to itself and, in the event vector, include something like the following: a flag to say the work is not finished the working state so far; and what chunk to do next. A Sketch \u00b6 Here's an -fx handler which counts up to some number in chunks: ( re-frame.core/reg-event-fx :count-to ( fn [{ db :db } [ _ first-time so-far finish-at ]] ( if first-time ;; We are at the beginning, so: ;; - modify db, causing popup of Modal saying \"Working ...\" ;; - begin iterative dispatch. Give initial version of \"so-far\" { :dispatch [ :count-to false { :counter 0 } finish-at ] ;; dispatch to self :db ( assoc db :we-are-working true )} ( if ( > ( :counter so-far ) finish-at ) ;; We are finished: ;; - take away the state which causes the modal to be up ;; - store the result of the calculation { :db ( -> db ( assoc :fruits-of-labour ( :counter so-far )) ;; remember the result ( assoc :we-are-working false ))} ;; no more modal ;; Still more work to do ;; - run the calculation ;; - redispatch, passing in new running state ( let [ new-so-far ( update so-far :counter inc )] { :dispatch [ :count-to false new-so-far finish-at ]})))) Why Does A Redispatch Work? \u00b6 A dispatched event is handled asynchronously. It is queued and not actioned straight away. And here's the key: After handling current events, re-frame yields control to the browser , allowing it to render any pending DOM changes, etc. After it is finished, the browser will hand control back to the re-frame router loop, which will then handle any other queued events which, in our case, would include the event we just dispatched to perform the next chunk of work. When the next dispatch is handled, a next chunk of work will be done, and then another dispatch will happen. And so on. dispatch after dispatch . Chunk after chunk. In 16ms increments if we are very careful (or some small amount of time less than, say, 100ms). But with the browser getting a look-in after each iteration. Variations \u00b6 As we go, the handler could be updating some value in app-db which indicates progress, and this state would then be rendered into the UI. At a certain point, when all the work is done, the handler will likely put the fruits of its computational labour into app-db and clear any flags which might, for example, cause a modal dialog to be showing progress. And the process would then be done. Cancel Button \u00b6 It is a flexible pattern. For example, it can be tweaked to handle a \"Cancel' button ... If there was a \u201cCancel\u201d button to be clicked, we might (dispatch [:cancel-it]) and then have this event\u2019s handler tweak the app-db by adding :abandonment-required flags. When a chunk-processing-handler next begins, it could check for this :abandonment-required flag, and, if found, stop the CPU intensive process (and clear the abandonment flags). When the abandonment-flags are set, the UI could show \"Abandoning process ...\" and thus appear responsive to the user's click on \u201cCancel\u201d. That's just one approach. You can adapt the pattern as necessary. Further Notes \u00b6 Going to this trouble is completely unnecessary if the long-running task involves I/O (GET, POST, HTML5 database action?) because the browser will handle I/O in another thread and give UI activities plenty of look in. You only need to go to this trouble if it is your code which is hogging the CPU. Forcing A One Off Render \u00b6 Imagine you have a process which takes, say, 5 seconds, and chunking is just too much effort. You lazily decide to leave the UI unresponsive for that short period. Except, you aren't totally lazy. If there was a button which kicked off this 5 second process, and the user clicks it, you\u2019d like the UI to show a response. Perhaps it could show a modal popup thing saying \u201cDoing X for you\u201d. At this point, you still have a small problem to solve. You want the UI to show your modal message before you then hog the CPU for 5 seconds. Updating the UI means altering app-db . Remember, the UI is a function of the data in app-db . Only changes to app-db cause UI changes. So, to show that Modal, you\u2019ll need to assoc some value into app-db and have that new value change what is rendered in your reagent components. You might be tempted to do this: ( re-frame.core/reg-event-db :process-x ( fn [ db event-v ] ( assoc db :processing-X true ) ;; update state, so reagent components render a modal ( do-long-process-x ))) ;; hog the CPU But that is just plain wrong. That assoc into db is not returned (and it must be for a -db handler). And, even if that did somehow work, then you continue hogging the thread with do-long-process-x . There's no chance for any UI updates because the handler never gives up control. This handler owns the thread right through. Ahhh, you think. I know what to do! I'll use that pattern I read about in the Wiki, and re-dispatch within an -fx handler: ( re-frame.core/reg-event-fx :process-x ( fn [{ db :db } event-v ] { :dispatch [ :do-work-process-x ] ;; do processing later, give CPU back to browser. :db ( assoc db :processing-X true )})) ;; so the modal gets rendered ( re-frame.core/reg-event-db :do-work-process-x ( fn [ db _ ] ( do-long-process-x db ))) ;; return a new db, presumably containing work done So close. But it still won\u2019t work. There's a little wrinkle. That event handler for :process-x will indeed give back control to the browser. BUT, because of the way reagent works, that assoc on db won't trigger DOM updates until the next animation frame runs, which is 16ms away. So, you will be yielding control to the browser, but for next 16ms there won't appear to be anything to do. And, by then, your CPU hogging code will have got control back, and will keep control for the next 5 seconds. That nice little Dialog telling you the button was clicked and action is being taken won't show. In these kinds of cases, where you are only going to give the UI one chance to update (not a repeated chance every few milliseconds), then you had better be sure the DOM is fully synced. To do this, you put metadata on the event being dispatched: ( re-frame.core/reg-event-fx :process-x ( fn [{ db :db } event-v ] { :dispatch ^ :flush-dom [ :do-work-process-x ] ;; <--- NOW WITH METADATA :db ( assoc db :processing-X true )})) ;; so the modal gets rendered Notice the ^:flush-dom metadata on the event being dispatched. Use that when you want the UI to be fully updated before the event dispatch is handled. You only need this technique when you: want the DOM to be fully updated because you are going to hog the CPU for a while and not give it back. One chunk of work. If you handle via multiple chunks you don't have to do this, because you are repeatedly handing back control to the browser/UI. Its just when you are going to tie up the CPU for a one, longish chunk.","title":"Solve the CPU hog problem"},{"location":"Solve-the-CPU-hog-problem/#the-re-frame-solution","text":"First , all long-running, CPU-hogging processes are put in event handlers. Not in subscriptions. Not in components. Not hard to do, but worth establishing as a rule, right up front. Second , you must be able to break up that CPU work into chunks. You need a way to do part of the work, pause, then resume from where you left off (more in a minute). In a perfect world, each chunk would take something like 16ms (60 fps). If you go longer, say 50ms or 100ms, it is no train smash, but UI responsiveness will degrade and animations, like busy spinners, will get jerky. Shorter is better, but less than 16ms delivers no added smoothness. Third , within our handler, after it completes one unit (chunk) of work, it should not continue straight on with the next. Instead, it should do a dispatch to itself and, in the event vector, include something like the following: a flag to say the work is not finished the working state so far; and what chunk to do next.","title":"The re-frame Solution"},{"location":"Solve-the-CPU-hog-problem/#a-sketch","text":"Here's an -fx handler which counts up to some number in chunks: ( re-frame.core/reg-event-fx :count-to ( fn [{ db :db } [ _ first-time so-far finish-at ]] ( if first-time ;; We are at the beginning, so: ;; - modify db, causing popup of Modal saying \"Working ...\" ;; - begin iterative dispatch. Give initial version of \"so-far\" { :dispatch [ :count-to false { :counter 0 } finish-at ] ;; dispatch to self :db ( assoc db :we-are-working true )} ( if ( > ( :counter so-far ) finish-at ) ;; We are finished: ;; - take away the state which causes the modal to be up ;; - store the result of the calculation { :db ( -> db ( assoc :fruits-of-labour ( :counter so-far )) ;; remember the result ( assoc :we-are-working false ))} ;; no more modal ;; Still more work to do ;; - run the calculation ;; - redispatch, passing in new running state ( let [ new-so-far ( update so-far :counter inc )] { :dispatch [ :count-to false new-so-far finish-at ]}))))","title":"A Sketch"},{"location":"Solve-the-CPU-hog-problem/#why-does-a-redispatch-work","text":"A dispatched event is handled asynchronously. It is queued and not actioned straight away. And here's the key: After handling current events, re-frame yields control to the browser , allowing it to render any pending DOM changes, etc. After it is finished, the browser will hand control back to the re-frame router loop, which will then handle any other queued events which, in our case, would include the event we just dispatched to perform the next chunk of work. When the next dispatch is handled, a next chunk of work will be done, and then another dispatch will happen. And so on. dispatch after dispatch . Chunk after chunk. In 16ms increments if we are very careful (or some small amount of time less than, say, 100ms). But with the browser getting a look-in after each iteration.","title":"Why Does A Redispatch Work?"},{"location":"Solve-the-CPU-hog-problem/#variations","text":"As we go, the handler could be updating some value in app-db which indicates progress, and this state would then be rendered into the UI. At a certain point, when all the work is done, the handler will likely put the fruits of its computational labour into app-db and clear any flags which might, for example, cause a modal dialog to be showing progress. And the process would then be done.","title":"Variations"},{"location":"Solve-the-CPU-hog-problem/#cancel-button","text":"It is a flexible pattern. For example, it can be tweaked to handle a \"Cancel' button ... If there was a \u201cCancel\u201d button to be clicked, we might (dispatch [:cancel-it]) and then have this event\u2019s handler tweak the app-db by adding :abandonment-required flags. When a chunk-processing-handler next begins, it could check for this :abandonment-required flag, and, if found, stop the CPU intensive process (and clear the abandonment flags). When the abandonment-flags are set, the UI could show \"Abandoning process ...\" and thus appear responsive to the user's click on \u201cCancel\u201d. That's just one approach. You can adapt the pattern as necessary.","title":"Cancel Button"},{"location":"Solve-the-CPU-hog-problem/#further-notes","text":"Going to this trouble is completely unnecessary if the long-running task involves I/O (GET, POST, HTML5 database action?) because the browser will handle I/O in another thread and give UI activities plenty of look in. You only need to go to this trouble if it is your code which is hogging the CPU.","title":"Further Notes"},{"location":"Solve-the-CPU-hog-problem/#forcing-a-one-off-render","text":"Imagine you have a process which takes, say, 5 seconds, and chunking is just too much effort. You lazily decide to leave the UI unresponsive for that short period. Except, you aren't totally lazy. If there was a button which kicked off this 5 second process, and the user clicks it, you\u2019d like the UI to show a response. Perhaps it could show a modal popup thing saying \u201cDoing X for you\u201d. At this point, you still have a small problem to solve. You want the UI to show your modal message before you then hog the CPU for 5 seconds. Updating the UI means altering app-db . Remember, the UI is a function of the data in app-db . Only changes to app-db cause UI changes. So, to show that Modal, you\u2019ll need to assoc some value into app-db and have that new value change what is rendered in your reagent components. You might be tempted to do this: ( re-frame.core/reg-event-db :process-x ( fn [ db event-v ] ( assoc db :processing-X true ) ;; update state, so reagent components render a modal ( do-long-process-x ))) ;; hog the CPU But that is just plain wrong. That assoc into db is not returned (and it must be for a -db handler). And, even if that did somehow work, then you continue hogging the thread with do-long-process-x . There's no chance for any UI updates because the handler never gives up control. This handler owns the thread right through. Ahhh, you think. I know what to do! I'll use that pattern I read about in the Wiki, and re-dispatch within an -fx handler: ( re-frame.core/reg-event-fx :process-x ( fn [{ db :db } event-v ] { :dispatch [ :do-work-process-x ] ;; do processing later, give CPU back to browser. :db ( assoc db :processing-X true )})) ;; so the modal gets rendered ( re-frame.core/reg-event-db :do-work-process-x ( fn [ db _ ] ( do-long-process-x db ))) ;; return a new db, presumably containing work done So close. But it still won\u2019t work. There's a little wrinkle. That event handler for :process-x will indeed give back control to the browser. BUT, because of the way reagent works, that assoc on db won't trigger DOM updates until the next animation frame runs, which is 16ms away. So, you will be yielding control to the browser, but for next 16ms there won't appear to be anything to do. And, by then, your CPU hogging code will have got control back, and will keep control for the next 5 seconds. That nice little Dialog telling you the button was clicked and action is being taken won't show. In these kinds of cases, where you are only going to give the UI one chance to update (not a repeated chance every few milliseconds), then you had better be sure the DOM is fully synced. To do this, you put metadata on the event being dispatched: ( re-frame.core/reg-event-fx :process-x ( fn [{ db :db } event-v ] { :dispatch ^ :flush-dom [ :do-work-process-x ] ;; <--- NOW WITH METADATA :db ( assoc db :processing-X true )})) ;; so the modal gets rendered Notice the ^:flush-dom metadata on the event being dispatched. Use that when you want the UI to be fully updated before the event dispatch is handled. You only need this technique when you: want the DOM to be fully updated because you are going to hog the CPU for a while and not give it back. One chunk of work. If you handle via multiple chunks you don't have to do this, because you are repeatedly handing back control to the browser/UI. Its just when you are going to tie up the CPU for a one, longish chunk.","title":"Forcing A One Off Render"},{"location":"Subscribing-To-External-Data/","text":"This document will soon be retired, and you probably shouldn't be reading it. It may mislead you. It documents an approach we experiemented with early, before realising it was probably wrong, but we haven't yet transfered the knowledge it contains to some other, less central place. So here is still sits. The RIGHT WAY in think can be found in FAQs like: 1. https://day8.github.io/re-frame/FAQs/LoadOnMount/ 2. https://day8.github.io/re-frame/FAQs/PollADatabaseEvery60/ 3. https://github.com/day8/re-frame-http-fx Subscribing to External Data \u00b6 In Talking To Servers we learned how to communicate with servers using both pure and effectful handlers. This is great, but what if you want to query external data using subscriptions the same way you query data stored in app-db ? This tutorial will show you how. There Can Be Only One!! \u00b6 re-frame apps have a single source of data called app-db . The re-frame README asks you to imagine app-db as something of an in-memory database. You query it (via subscriptions) and transactionally update it (via event handlers). Components Don't Know, Don't Care \u00b6 Components never know the structure of your app-db , much less its existence. Instead, they subscribe , declaratively, to data, like this (subscribe [:something \"blah\"]) , and that allows Components to obtain a stream of updates to \"something\", while knowing nothing about the source of the data. A 2nd Source \u00b6 All good but ... SPAs are seldom completely self contained data-wise. There's a continuum between apps which are 100% standalone data-wise, and those where remote data is utterly central to the app's function. In this page, we're exploring the remote-data-centric end of this continuum. And just to be clear, when I'm talking about remote data, I'm thinking of data luxuriating in remote databases like firebase, rethinkdb, PostgreSQL, Datomic, etc - data sources that an app must query and mutate. So, the question is: how would we integrate this kind of remote data into an app when re-frame seems to have only one source of data: app-db ? How do we introduce a second or even third source of data? How should we subscribe to this remote data, and how would we update it? By way of explanation, let's make the question specific: how could we wire up a Component which displays a collection of items , when those items come from a remote database? In your mind's eye, imagine this kind of query against that remote database: select id, price, description from items where type=\"see through\" . Via A Subscription \u00b6 In re-frame , Components always obtain data via a subscription. Always. So, our Component which shows items is going to ( let [ items ( re-frame/subscribe [ :items \"see through\" ]) ... and the subscription handler will deliver them. Which, in turn, means our code must have a subscription handler defined: ( re-frame/reg-sub :items ( fn [ db [ _ item-type ] ... )) Which is fine ... except we haven't really solved this problem yet, have we? We've just transferred the problem away from the Component and into the subscription handler? Well, yes, we have, and isn't that a fine thing!! That's precisely what we want from our subscription handlers ... to manage how the data is sourced ... to hide that from the Component. The Subscription Handler's Job \u00b6 Right, so let's write the subscription handler. There'll be code in a minute but, first, let's describe how the subscription handler will work: Upon being required to provide items, it has to issue a query to the remote database. Perhaps this will be done via a RESTful GET. Or via a firebase connection. Or by pushing a JSON representation of the query down a websocket. Something. And it is the subscription handler's job to know how it is done. This query be async - with the results arriving sometime \"later\". And when they eventually arrive, the handler must organise for the query results to be placed into app-db , at some known, particular path. In the meantime, the handler might want to ensure that the absence of results is also communicated to the Component, allowing it to display \"Loading ...\". The Nine States of Design has some useful information on designing your application for different states that your data might be in. The subscription handler must return something to the Component. It should give back a reaction to that known, particular path within app-db , so that when the query results eventually arrive, they will flow through into the Component for display. The subscription handler will detect when the Component is destroyed and no longer requires the subscription. It will then clean up, getting rid of those now-unneeded items, and sorting out any stateful database connection issues. Notice what's happening here. In many respects, app-db is still acting as the single source of data. The subscription handler is organising for the right remote data to \"flow\" into app-db at a known, particular path, when it is needed by a Component. And, equally, for this data to be cleaned up when it is no longer required. Some Code \u00b6 Enough fluffing about with words, here's a code sketch for our subscription handler: ( re-frame/reg-sub-raw :items ( fn [ app-db [ _ type ]] ( let [ query-token ( issue-items-query! type :on-success # ( re-frame/dispatch [ :write-to [ :some :path ]]))] ( reagent.ratom/make-reaction ( fn [] ( get-in @ app-db [ :some :path ])) :on-dispose # ( do ( terminate-items-query! query-token ) ( re-frame/dispatch [ :cleanup [ :some :path ]])))))) A few things to notice: We are using the low level reg-sub-raw to register our handler (and not the more normal reg-sub ) so we can get an :on-dispose callback when the subscription is no longer needed. See the reg-sub-raw docs at the end of this tutorial You have to write issue-items-query! . Are you making a Restful GET? Are you writing JSON packets down a websocket? The query has to be made. We do not issue the query via a dispatch because, to me, it isn't an event. But we most certainly do handle the arrival of query results via a dispatch and associated event handler. That to me is an external event happening to the system. The event handler can curate the arriving data in whatever way makes sense. Maybe it does nothing more than to assoc into an app-db path, or maybe this is a rethinkdb changefeed subscription and your event handler will have to collate the newly arriving data with what has previously been returned. Do what needs to be done in that event handler, so that the right data will be put into the right path. We use Reagent's make-reaction function to create a reaction which will return that known, particular path within app-db where the query results are to be placed. We use the on-dispose callback on this reaction to do any cleanup work when the subscription is no longer needed. Clean up app-db ? Clean up the database connection? Any Good? \u00b6 It turns out that this is a surprisingly flexible and clean approach. And pretty damn obvious once someone points it out to you (which is a good sign). There's a lot to like about it. For example, if you are using rethinkdb, which supports queries which yield \"change feeds\" over time, rather than a one-off query result, you have to actively close such queries when they are no longer needed. That's easy to do in our cleanup code. We can source some data from both PostgreSQL and firebase in the one app, using the same pattern. All remote data access is done in the same way. Because query results are dispatched to an event handler, you have a lot of flexibility about how you process them. The whole set of pieces can be arranged and tweaked in many ways. For example, with a bit of work, we could keep a register of all currently used queries. And then, if ever we noticed that the app had gone offline, and then back online, we could organise to reissue all the queries again (with results flowing back into the same known paths), avoiding stale results. Also, notice that putting ALL interesting data into app-db has nice flow on effects. In particular, it means it is available to event handlers, should they need it when servicing events (event handlers get db as a parameter, right?). If this item data was held in a separate place, other than app-db , it wouldn't be available in this useful way. Warning: Undo/Redo \u00b6 This technique caches remote data in app-db . Be sure to exclude this cache area from any undo/redo operations using the available configuration options Query De-duplication \u00b6 In v0.8.0 of re-frame onwards, subscriptions are automatically de-duplicated. In prior versions, in cases where the same query is simultaneously issued from multiple places, you'd want to de-duplicate the queries. One possibility is to do this duplication in issue-items-query! itself. You can count the duplicate queries and only clear the data when that count goes to 0. Thanks To \u00b6 @nidu for his valuable review comments and insights The Alternative Approach \u00b6 Event handlers do most of the heavy lifting within re-frame apps. When buttons get clicked, or items get dragged 'n dropped, or tabs get chosen, they know how to transition the app from one state to the next. That's their job. And, when they make such a transition, it is quite reasonable to expect them to ALSO source the data needed in the new state. So there's definitely a case for NOT using the approach outlined above and, instead, making event handlers source data and plonk it into a certain part of app-db for use by subscriptions. In effect, there's definitely an argument that subscriptions should only ever source from app-db BUT that it is event handlers which start and stop the sourcing of data from remote places. Sorry, but you'll have to work out which of these two variations works best for you. Within this document the first alternative has been given more word count only because there's a few more tricks to make it work, not because it is necessarily preferred. Absolutely Never Do This \u00b6 Sometimes, because of their background with other JS frameworks, new re-framians feel like the Components themselves (the views) should have the responsibility of sourcing the data they need. They then use React lifecycle methods like :component-did-mount to load remote data. I believe this is absolutely the wrong way to do it. In re-frame, we want views to be as simple and dumb as possible. They turn data into HTML and nothing more. they absolutely do not do imperative stuff. Use one of the two alternatives described above.","title":"Subscribing to External Data"},{"location":"Subscribing-To-External-Data/#subscribing-to-external-data","text":"In Talking To Servers we learned how to communicate with servers using both pure and effectful handlers. This is great, but what if you want to query external data using subscriptions the same way you query data stored in app-db ? This tutorial will show you how.","title":"Subscribing to External Data"},{"location":"Subscribing-To-External-Data/#there-can-be-only-one","text":"re-frame apps have a single source of data called app-db . The re-frame README asks you to imagine app-db as something of an in-memory database. You query it (via subscriptions) and transactionally update it (via event handlers).","title":"There Can Be Only One!!"},{"location":"Subscribing-To-External-Data/#components-dont-know-dont-care","text":"Components never know the structure of your app-db , much less its existence. Instead, they subscribe , declaratively, to data, like this (subscribe [:something \"blah\"]) , and that allows Components to obtain a stream of updates to \"something\", while knowing nothing about the source of the data.","title":"Components Don't Know, Don't Care"},{"location":"Subscribing-To-External-Data/#a-2nd-source","text":"All good but ... SPAs are seldom completely self contained data-wise. There's a continuum between apps which are 100% standalone data-wise, and those where remote data is utterly central to the app's function. In this page, we're exploring the remote-data-centric end of this continuum. And just to be clear, when I'm talking about remote data, I'm thinking of data luxuriating in remote databases like firebase, rethinkdb, PostgreSQL, Datomic, etc - data sources that an app must query and mutate. So, the question is: how would we integrate this kind of remote data into an app when re-frame seems to have only one source of data: app-db ? How do we introduce a second or even third source of data? How should we subscribe to this remote data, and how would we update it? By way of explanation, let's make the question specific: how could we wire up a Component which displays a collection of items , when those items come from a remote database? In your mind's eye, imagine this kind of query against that remote database: select id, price, description from items where type=\"see through\" .","title":"A 2nd Source"},{"location":"Subscribing-To-External-Data/#via-a-subscription","text":"In re-frame , Components always obtain data via a subscription. Always. So, our Component which shows items is going to ( let [ items ( re-frame/subscribe [ :items \"see through\" ]) ... and the subscription handler will deliver them. Which, in turn, means our code must have a subscription handler defined: ( re-frame/reg-sub :items ( fn [ db [ _ item-type ] ... )) Which is fine ... except we haven't really solved this problem yet, have we? We've just transferred the problem away from the Component and into the subscription handler? Well, yes, we have, and isn't that a fine thing!! That's precisely what we want from our subscription handlers ... to manage how the data is sourced ... to hide that from the Component.","title":"Via A Subscription"},{"location":"Subscribing-To-External-Data/#the-subscription-handlers-job","text":"Right, so let's write the subscription handler. There'll be code in a minute but, first, let's describe how the subscription handler will work: Upon being required to provide items, it has to issue a query to the remote database. Perhaps this will be done via a RESTful GET. Or via a firebase connection. Or by pushing a JSON representation of the query down a websocket. Something. And it is the subscription handler's job to know how it is done. This query be async - with the results arriving sometime \"later\". And when they eventually arrive, the handler must organise for the query results to be placed into app-db , at some known, particular path. In the meantime, the handler might want to ensure that the absence of results is also communicated to the Component, allowing it to display \"Loading ...\". The Nine States of Design has some useful information on designing your application for different states that your data might be in. The subscription handler must return something to the Component. It should give back a reaction to that known, particular path within app-db , so that when the query results eventually arrive, they will flow through into the Component for display. The subscription handler will detect when the Component is destroyed and no longer requires the subscription. It will then clean up, getting rid of those now-unneeded items, and sorting out any stateful database connection issues. Notice what's happening here. In many respects, app-db is still acting as the single source of data. The subscription handler is organising for the right remote data to \"flow\" into app-db at a known, particular path, when it is needed by a Component. And, equally, for this data to be cleaned up when it is no longer required.","title":"The Subscription Handler's Job"},{"location":"Subscribing-To-External-Data/#some-code","text":"Enough fluffing about with words, here's a code sketch for our subscription handler: ( re-frame/reg-sub-raw :items ( fn [ app-db [ _ type ]] ( let [ query-token ( issue-items-query! type :on-success # ( re-frame/dispatch [ :write-to [ :some :path ]]))] ( reagent.ratom/make-reaction ( fn [] ( get-in @ app-db [ :some :path ])) :on-dispose # ( do ( terminate-items-query! query-token ) ( re-frame/dispatch [ :cleanup [ :some :path ]])))))) A few things to notice: We are using the low level reg-sub-raw to register our handler (and not the more normal reg-sub ) so we can get an :on-dispose callback when the subscription is no longer needed. See the reg-sub-raw docs at the end of this tutorial You have to write issue-items-query! . Are you making a Restful GET? Are you writing JSON packets down a websocket? The query has to be made. We do not issue the query via a dispatch because, to me, it isn't an event. But we most certainly do handle the arrival of query results via a dispatch and associated event handler. That to me is an external event happening to the system. The event handler can curate the arriving data in whatever way makes sense. Maybe it does nothing more than to assoc into an app-db path, or maybe this is a rethinkdb changefeed subscription and your event handler will have to collate the newly arriving data with what has previously been returned. Do what needs to be done in that event handler, so that the right data will be put into the right path. We use Reagent's make-reaction function to create a reaction which will return that known, particular path within app-db where the query results are to be placed. We use the on-dispose callback on this reaction to do any cleanup work when the subscription is no longer needed. Clean up app-db ? Clean up the database connection?","title":"Some Code"},{"location":"Subscribing-To-External-Data/#any-good","text":"It turns out that this is a surprisingly flexible and clean approach. And pretty damn obvious once someone points it out to you (which is a good sign). There's a lot to like about it. For example, if you are using rethinkdb, which supports queries which yield \"change feeds\" over time, rather than a one-off query result, you have to actively close such queries when they are no longer needed. That's easy to do in our cleanup code. We can source some data from both PostgreSQL and firebase in the one app, using the same pattern. All remote data access is done in the same way. Because query results are dispatched to an event handler, you have a lot of flexibility about how you process them. The whole set of pieces can be arranged and tweaked in many ways. For example, with a bit of work, we could keep a register of all currently used queries. And then, if ever we noticed that the app had gone offline, and then back online, we could organise to reissue all the queries again (with results flowing back into the same known paths), avoiding stale results. Also, notice that putting ALL interesting data into app-db has nice flow on effects. In particular, it means it is available to event handlers, should they need it when servicing events (event handlers get db as a parameter, right?). If this item data was held in a separate place, other than app-db , it wouldn't be available in this useful way.","title":"Any Good?"},{"location":"Subscribing-To-External-Data/#warning-undoredo","text":"This technique caches remote data in app-db . Be sure to exclude this cache area from any undo/redo operations using the available configuration options","title":"Warning: Undo/Redo"},{"location":"Subscribing-To-External-Data/#query-de-duplication","text":"In v0.8.0 of re-frame onwards, subscriptions are automatically de-duplicated. In prior versions, in cases where the same query is simultaneously issued from multiple places, you'd want to de-duplicate the queries. One possibility is to do this duplication in issue-items-query! itself. You can count the duplicate queries and only clear the data when that count goes to 0.","title":"Query De-duplication"},{"location":"Subscribing-To-External-Data/#thanks-to","text":"@nidu for his valuable review comments and insights","title":"Thanks To"},{"location":"Subscribing-To-External-Data/#the-alternative-approach","text":"Event handlers do most of the heavy lifting within re-frame apps. When buttons get clicked, or items get dragged 'n dropped, or tabs get chosen, they know how to transition the app from one state to the next. That's their job. And, when they make such a transition, it is quite reasonable to expect them to ALSO source the data needed in the new state. So there's definitely a case for NOT using the approach outlined above and, instead, making event handlers source data and plonk it into a certain part of app-db for use by subscriptions. In effect, there's definitely an argument that subscriptions should only ever source from app-db BUT that it is event handlers which start and stop the sourcing of data from remote places. Sorry, but you'll have to work out which of these two variations works best for you. Within this document the first alternative has been given more word count only because there's a few more tricks to make it work, not because it is necessarily preferred.","title":"The Alternative Approach"},{"location":"Subscribing-To-External-Data/#absolutely-never-do-this","text":"Sometimes, because of their background with other JS frameworks, new re-framians feel like the Components themselves (the views) should have the responsibility of sourcing the data they need. They then use React lifecycle methods like :component-did-mount to load remote data. I believe this is absolutely the wrong way to do it. In re-frame, we want views to be as simple and dumb as possible. They turn data into HTML and nothing more. they absolutely do not do imperative stuff. Use one of the two alternatives described above.","title":"Absolutely Never Do This"},{"location":"Talking-To-Servers/","text":"Talking To Servers \u00b6 This page describes how a re-frame app might \"talk\" to a backend HTTP server. We'll assume there's a json-returning server endpoint at \"http://json.my-endpoint.com/blah\". We want to GET from that endpoint and put a processed version of the returned json into app-db . Triggering The Request \u00b6 The user often does something to trigger the process. Here's a button which the user could click: ( defn request-it-button [] [ :div { :class \"button-class\" :on-click # ( dispatch [ :request-it ])} ;; get data from the server !! \"I want it, now!\" ]) Notice the on-click handler - it dispatch es the event [:request-it] . The Event Handler \u00b6 That :request-it event will need to be \"handled\", which means an event handler must be registered for it. We want this handler to: 1. Initiate the HTTP GET 2. Update a flag in app-db which will trigger a modal \"Loading ...\" message for the user to see We're going to create two versions of this event handler. First, we'll create a problematic version of the event handler and then, realising our sins, we'll write a second version which is a soaring paragon of virtue. Both versions will teach us something. Version 1 \u00b6 We're going to use the cljs-ajax library as the HTTP workhorse. Here's the event handler: ( ns my.app.events ;; <1> ( :require [ ajax.core :refer [ GET ]] [ re-frame.core :refer [ reg-event-db ])) ( reg-event-db ;; <-- register an event handler :request-it ;; <-- the event id ( fn ;; <-- the handler function [ db _ ] ;; kick off the GET, making sure to supply a callback for success and failure ( GET \"http://json.my-endpoint.com/blah\" { :handler # ( dispatch [ :process-response %1 ]) ;; <2> further dispatch !! :error-handler # ( dispatch [ :bad-response %1 ])}) ;; <2> further dispatch !! ;; update a flag in `app-db` ... presumably to cause a \"Loading...\" UI ( assoc db :loading? true ))) ;; <3> return an updated db Further Notes: 1. Event handlers are normally put into an events.cljs namespace 2. Notice that the GET callbacks issue a further dispatch . Such callbacks should never attempt to close over db themselves, or make any changes to it because, by the time these callbacks happen, the value in app-db may have changed. Whereas, if they dispatch , then the event handlers looking after the event they dispatch will be given the latest copy of the db. 3. event handlers registered using reg-event-db must return a new value for app-db . In our case, we set a flag which will presumably cause a \"Loading ...\" UI to show. Successful GET \u00b6 As we noted above, the on-success handler itself is just #(dispatch [:process-response RESPONSE]) . So we'll need to register a handler for this event too. Like this: ( reg-event-db :process-response ( fn [ db [ _ response ]] ;; destructure the response from the event vector ( -> db ( assoc :loading? false ) ;; take away that \"Loading ...\" UI ( assoc :data ( js->clj response )))) ;; fairly lame processing A normal handler would have more complex processing of the response. But we're just sketching here, so we've left it easy. There'd also need to be a handler for the :bad-response event too. Left as an exercise. Problems In Paradise? \u00b6 This approach will work, and it is useful to take time to understand why it would work, but it has a problem: the event handler isn't pure. That GET is a side effect, and side effecting functions are like a well salted paper cut. We try hard to avoid them. Version 2 \u00b6 The better solution is, of course, to use an effectful handler. This is explained in detail in the previous tutorials: Effectful Handlers and Effects . In the 2nd version, we use the alternative registration function, reg-event-fx , and we'll use an \"Effect Handler\" supplied by this library https://github.com/day8/re-frame-http-fx . You may soon feel confident enough to write your own. Here's our rewrite: ( ns my.app.events ( :require [ ajax.core :as ajax ] [ day8.re-frame.http-fx ] [ re-frame.core :refer [ reg-event-fx ])) ( reg-event-fx ;; <-- note the `-fx` extension :request-it ;; <-- the event id ( fn ;; <-- the handler function [{ db :db } _ ] ;; <-- 1st argument is coeffect, from which we extract db ;; we return a map of (side) effects { :http-xhrio { :method :get :uri \"http://json.my-endpoint.com/blah\" :format ( ajax/json-request-format ) :response-format ( ajax/json-response-format { :keywords? true }) :on-success [ :process-response ] :on-failure [ :bad-response ]} :db ( assoc db :loading? true )})) Notes: 1. Our event handler \"describes\" side effects, it does not \"do\" side effects 2. The event handler we wrote for :process-response stays as it was","title":"Talking To Servers"},{"location":"Talking-To-Servers/#talking-to-servers","text":"This page describes how a re-frame app might \"talk\" to a backend HTTP server. We'll assume there's a json-returning server endpoint at \"http://json.my-endpoint.com/blah\". We want to GET from that endpoint and put a processed version of the returned json into app-db .","title":"Talking To Servers"},{"location":"Talking-To-Servers/#triggering-the-request","text":"The user often does something to trigger the process. Here's a button which the user could click: ( defn request-it-button [] [ :div { :class \"button-class\" :on-click # ( dispatch [ :request-it ])} ;; get data from the server !! \"I want it, now!\" ]) Notice the on-click handler - it dispatch es the event [:request-it] .","title":"Triggering The Request"},{"location":"Talking-To-Servers/#the-event-handler","text":"That :request-it event will need to be \"handled\", which means an event handler must be registered for it. We want this handler to: 1. Initiate the HTTP GET 2. Update a flag in app-db which will trigger a modal \"Loading ...\" message for the user to see We're going to create two versions of this event handler. First, we'll create a problematic version of the event handler and then, realising our sins, we'll write a second version which is a soaring paragon of virtue. Both versions will teach us something.","title":"The Event Handler"},{"location":"Talking-To-Servers/#version-1","text":"We're going to use the cljs-ajax library as the HTTP workhorse. Here's the event handler: ( ns my.app.events ;; <1> ( :require [ ajax.core :refer [ GET ]] [ re-frame.core :refer [ reg-event-db ])) ( reg-event-db ;; <-- register an event handler :request-it ;; <-- the event id ( fn ;; <-- the handler function [ db _ ] ;; kick off the GET, making sure to supply a callback for success and failure ( GET \"http://json.my-endpoint.com/blah\" { :handler # ( dispatch [ :process-response %1 ]) ;; <2> further dispatch !! :error-handler # ( dispatch [ :bad-response %1 ])}) ;; <2> further dispatch !! ;; update a flag in `app-db` ... presumably to cause a \"Loading...\" UI ( assoc db :loading? true ))) ;; <3> return an updated db Further Notes: 1. Event handlers are normally put into an events.cljs namespace 2. Notice that the GET callbacks issue a further dispatch . Such callbacks should never attempt to close over db themselves, or make any changes to it because, by the time these callbacks happen, the value in app-db may have changed. Whereas, if they dispatch , then the event handlers looking after the event they dispatch will be given the latest copy of the db. 3. event handlers registered using reg-event-db must return a new value for app-db . In our case, we set a flag which will presumably cause a \"Loading ...\" UI to show.","title":"Version 1"},{"location":"Talking-To-Servers/#successful-get","text":"As we noted above, the on-success handler itself is just #(dispatch [:process-response RESPONSE]) . So we'll need to register a handler for this event too. Like this: ( reg-event-db :process-response ( fn [ db [ _ response ]] ;; destructure the response from the event vector ( -> db ( assoc :loading? false ) ;; take away that \"Loading ...\" UI ( assoc :data ( js->clj response )))) ;; fairly lame processing A normal handler would have more complex processing of the response. But we're just sketching here, so we've left it easy. There'd also need to be a handler for the :bad-response event too. Left as an exercise.","title":"Successful GET"},{"location":"Talking-To-Servers/#problems-in-paradise","text":"This approach will work, and it is useful to take time to understand why it would work, but it has a problem: the event handler isn't pure. That GET is a side effect, and side effecting functions are like a well salted paper cut. We try hard to avoid them.","title":"Problems In Paradise?"},{"location":"Talking-To-Servers/#version-2","text":"The better solution is, of course, to use an effectful handler. This is explained in detail in the previous tutorials: Effectful Handlers and Effects . In the 2nd version, we use the alternative registration function, reg-event-fx , and we'll use an \"Effect Handler\" supplied by this library https://github.com/day8/re-frame-http-fx . You may soon feel confident enough to write your own. Here's our rewrite: ( ns my.app.events ( :require [ ajax.core :as ajax ] [ day8.re-frame.http-fx ] [ re-frame.core :refer [ reg-event-fx ])) ( reg-event-fx ;; <-- note the `-fx` extension :request-it ;; <-- the event id ( fn ;; <-- the handler function [{ db :db } _ ] ;; <-- 1st argument is coeffect, from which we extract db ;; we return a map of (side) effects { :http-xhrio { :method :get :uri \"http://json.my-endpoint.com/blah\" :format ( ajax/json-request-format ) :response-format ( ajax/json-response-format { :keywords? true }) :on-success [ :process-response ] :on-failure [ :bad-response ]} :db ( assoc db :loading? true )})) Notes: 1. Our event handler \"describes\" side effects, it does not \"do\" side effects 2. The event handler we wrote for :process-response stays as it was","title":"Version 2"},{"location":"Testing/","text":"Testing \u00b6 This is an introduction to testing re-frame apps. It walks you through some choices. What To Test \u00b6 For any re-frame app, there's three things to test: Event Handlers - most of your testing focus will be here because this is where most of the logic lives Subscription Handlers - often not a lot to test here. Only Layer 3 subscriptions need testing. View functions - I don't tend to write tests for views. There, I said it. Hey! It is mean to look at someone with that level of disapproval, while shaking your head. I have my reasons ... In my experience with the re-frame architecture, View Functions tend to be an unlikely source of bugs. And every line of code you write is like a ball & chain you must forevermore drag about, so I dislike maintaining tests which don't deliver good bang for buck. And, yes, in theory there's also Effect Handlers (Domino 3) to test, but you'll hardly ever write one, and, anyway, each one is different, so I've got no good general insight to offer you for them. They will be ignored in this tutorial. Test Terminology \u00b6 Let's establish some terminology to aid the further explanations in this tutorial. Every unittest has 3 steps: setup initial conditions execute the thing-under-test verify that the thing-under-test did the right thing Exposing Event Handlers For Test \u00b6 Event Handlers are pure functions which should make them easy to test, right? First, create a named event handler using defn like this: ( defn select-triangle [ db [ _ triangle-id ]] ... return a modified version of db ) You'd register this handler in a separate step: ( re-frame.core/reg-event-db ;; this is a \"-db\" event handler, not \"-fx\" :select-triangle [ some-interceptors ] select-triangle ) ;; <--- defn above. don't use an annonomous fn This arrangement means the event handler function select-triangle is readily available to be unittested. Event Handlers - Setup - Part 1 \u00b6 To test select-triangle , a unittest must pass in values for the two arguments db and v . And, so, our setup would have to construct both values. But how to create a useful db value? db is a map of a certain structure, so one way would be to simply assoc values into a map at certain paths to simulate a real-world db value or, even easier, just use a map literal, like this: ;; a test ( let [ ;; setup - create db and event db { :some 42 :thing \"hello\" } ; a literal event [ :select-triangle :other :event :args ] ;; execute result-db ( select-triange db event )] ;; validate that result-db is correct) ( is ... ) This certainly works in theory, but in practice, unless we are careful, constructing the db value in setup could: be manual and time-consuming tie tests to the internal structure of app-db The setup of every test could end up relying on the internal structure of app-db and any change in that structure (which is inevitable over time) would result in a lot re-work in the tests. That's too fragile. So, this approach doesn't quite work. Event Handlers - Setup - Part 2 \u00b6 In re-frame, Events are central. They are the \"language of the system\". They provide the eloquence. The db value (stored in app-db ) is the cumulative result of many event handlers running. We can use this idea. In setup , instead of manually trying to create that db value, we could \"build up\" a db value by threading db through many event handlers which cumulatively create the required initial state. Tests then need know nothing about the internal structure of that db . Like this: ( let [ ;; setup - cummulatively build up db db ( -> {} ;; empty db ( initialise-db [ :initialise-db ]) ;; each event handler expects db and event ( clear-panel [ :clear-panel ]) ( draw-triangle [ :draw-triangle 1 2 3 ])) event [ :select-triange :other :stuff ] ;; now execute the event handler under test db ' ( select-triange db event )] ;; validate that db' is correct ( is ... ) This approach works so long as all the event handlers are of the -db kind, but the threading gets a little messy when some event handlers are of the -fx kind which take a coeffect argument and return effects , instead of a db value. So, this approach is quite workable in some cases, but can get messy in the general case. Event Handlers - Setup - Part 3 \u00b6 There is further variation which is quite general but not as pure. During test setup we could literally just dispatch the events which would put app-db into the right state. Except, we'd have to use dispatch-sync rather dispatch to force immediate handling of events, rather than queuing. ;; setup - cummulatively build up db ( dispatch-sync [ :initialise-db ]) ( dispatch-sync [ :clear-panel ]) ( dispatch-sync [ :draw-triangle 1 2 3 ]) ;; execute ( dispatch-sync [ :select-triange :other :stuff ]) ;; validate that the value in 'app-db' is correct ;; perhaps with subscriptions Notes: we use dispatch-sync because dispatch is async (event is handled not now, but soon) Not pure. We are choosing to mutate the global app-db . But having said that, there's something about this approach which is remarkably pragmatic. the setup is now very natural. The associated handlers can be either -db or -fx if the handlers have effects other than just updating app-db, we might need to stub out XXX How do we look at the results ???? If this method appeals to you, you should ABSOLUTELY review the utilities in this helper library: re-frame-test . In summary, event handlers should be easy to test because they are pure functions. The interesting part is the unittest \"setup\" where we need to establish an initial value for db . Subscription Handlers \u00b6 Here's a Subscription Handler from the todomvc example : ( reg-sub :visible-todos ;; signal function ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) ;; computation function ( fn [[ todos showing ] _ ] ;; that 1st parameter is a 2-vector of values ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) How do we test this? First, we could split the computation function from its registration, like this: ( defn visible-todos [[ todos showing ] _ ] ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos ))) ( reg-sub :visible-todos ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) visible-todos ) ;; <--- computation function used here That makes visible-todos available for direct unit testing. But, as we experienced with Event Handlers, the challenge is around constructing db values (first parameter) in a way which doesn't become fragile. View Functions - Part 1 \u00b6 Components/views are more tricky and there are a few options. But remember my ugly secret - I don't tend to write tests for my views. But here's how, theoretically, I'd write tests if I wasn't me ... If a View Function is Form-1 , then it is fairly easy to test. A trivial example: ( defn greet [ name ] [ :div \"Hello \" name ]) ( greet \"Wiki\" ) ;;=> [:div \"Hello \" \"Wiki\"] So, here, testing involves passing values into the function and checking the data structure returned for correctness. What's returned is hiccup, of course. So how do you test hiccup for correctness? hiccup is just a clojure data structure - vectors containing keywords, and maps, and other vectors, etc. Perhaps you'd use https://github.com/nathanmarz/specter to declaratively check on the presence of certain values and structures? Or do it more manually. View Functions - Part 2A \u00b6 But what if the View Function has a subscription? ( defn my-view [ something ] ( let [ val ( subscribe [ :query-id ])] ;; <-- reactive subscription [ :div .... using @ val in here ])) The use of subscribe makes the function impure (it obtains data from places other than its args). A testing plan might be: setup app-db with some values in the right places (via dispatch of events?) call my-view (with a parameter) which will return hiccup check the hiccup structure for correctness. Continuing on, in a second phase you could then: change the value in app-db (which will cause the subscription to fire) call view functions again (hiccup returned) check the new hiccup for correctness. Which is all possible, if a little messy. View Functions - Part 2B \u00b6 There is a pragmatic method available to handle the impurity: use with-redefs to stub out subscribe . Like this: ( defn subscription-stub [ x ] ( atom ( case x [ :query-id ] 42 ))) ( deftest some-test ( with-redefs [ re-frame/subscribe ( subscription-stub )] ( testing \"some some view which does a subscribe\" ..... call the view function and the hiccup output ))) For more integration level testing, you can use with-mounted-component from the reagent-template to render the component in the browser and validate the generated DOM. View Functions - Part 2C \u00b6 Or ... there is another option: you can structure in the first place for pure view functions. The trick here is to create an outer and inner component. The outer sources the data (via a subscription), and passes it onto the inner as props (parameters). As a result, the inner component, which does the testable work, is pure and easily tested. The outer is impure but trivial. To get a more concrete idea, I'll direct you to another page in the re-frame docs which has nothing to do with testing, but it does use this simple-outer-subscribe-with-complicated-inner-render pattern for a different purpose: Using Stateful JS Components Note: this technique could be made simple and almost invisible via the use of macros. This pattern has been independently discovered by many. For example, here it is called the Container/Component pattern . Also Read This \u00b6 https://juxt.pro/blog/posts/cljs-apps.html Summary \u00b6 Event handlers will be your primary focus when testing. Remember to review the utilities in re-frame-test .","title":"Testing"},{"location":"Testing/#testing","text":"This is an introduction to testing re-frame apps. It walks you through some choices.","title":"Testing"},{"location":"Testing/#what-to-test","text":"For any re-frame app, there's three things to test: Event Handlers - most of your testing focus will be here because this is where most of the logic lives Subscription Handlers - often not a lot to test here. Only Layer 3 subscriptions need testing. View functions - I don't tend to write tests for views. There, I said it. Hey! It is mean to look at someone with that level of disapproval, while shaking your head. I have my reasons ... In my experience with the re-frame architecture, View Functions tend to be an unlikely source of bugs. And every line of code you write is like a ball & chain you must forevermore drag about, so I dislike maintaining tests which don't deliver good bang for buck. And, yes, in theory there's also Effect Handlers (Domino 3) to test, but you'll hardly ever write one, and, anyway, each one is different, so I've got no good general insight to offer you for them. They will be ignored in this tutorial.","title":"What To Test"},{"location":"Testing/#test-terminology","text":"Let's establish some terminology to aid the further explanations in this tutorial. Every unittest has 3 steps: setup initial conditions execute the thing-under-test verify that the thing-under-test did the right thing","title":"Test Terminology"},{"location":"Testing/#exposing-event-handlers-for-test","text":"Event Handlers are pure functions which should make them easy to test, right? First, create a named event handler using defn like this: ( defn select-triangle [ db [ _ triangle-id ]] ... return a modified version of db ) You'd register this handler in a separate step: ( re-frame.core/reg-event-db ;; this is a \"-db\" event handler, not \"-fx\" :select-triangle [ some-interceptors ] select-triangle ) ;; <--- defn above. don't use an annonomous fn This arrangement means the event handler function select-triangle is readily available to be unittested.","title":"Exposing Event Handlers For Test"},{"location":"Testing/#event-handlers-setup-part-1","text":"To test select-triangle , a unittest must pass in values for the two arguments db and v . And, so, our setup would have to construct both values. But how to create a useful db value? db is a map of a certain structure, so one way would be to simply assoc values into a map at certain paths to simulate a real-world db value or, even easier, just use a map literal, like this: ;; a test ( let [ ;; setup - create db and event db { :some 42 :thing \"hello\" } ; a literal event [ :select-triangle :other :event :args ] ;; execute result-db ( select-triange db event )] ;; validate that result-db is correct) ( is ... ) This certainly works in theory, but in practice, unless we are careful, constructing the db value in setup could: be manual and time-consuming tie tests to the internal structure of app-db The setup of every test could end up relying on the internal structure of app-db and any change in that structure (which is inevitable over time) would result in a lot re-work in the tests. That's too fragile. So, this approach doesn't quite work.","title":"Event Handlers - Setup - Part 1"},{"location":"Testing/#event-handlers-setup-part-2","text":"In re-frame, Events are central. They are the \"language of the system\". They provide the eloquence. The db value (stored in app-db ) is the cumulative result of many event handlers running. We can use this idea. In setup , instead of manually trying to create that db value, we could \"build up\" a db value by threading db through many event handlers which cumulatively create the required initial state. Tests then need know nothing about the internal structure of that db . Like this: ( let [ ;; setup - cummulatively build up db db ( -> {} ;; empty db ( initialise-db [ :initialise-db ]) ;; each event handler expects db and event ( clear-panel [ :clear-panel ]) ( draw-triangle [ :draw-triangle 1 2 3 ])) event [ :select-triange :other :stuff ] ;; now execute the event handler under test db ' ( select-triange db event )] ;; validate that db' is correct ( is ... ) This approach works so long as all the event handlers are of the -db kind, but the threading gets a little messy when some event handlers are of the -fx kind which take a coeffect argument and return effects , instead of a db value. So, this approach is quite workable in some cases, but can get messy in the general case.","title":"Event Handlers - Setup - Part 2"},{"location":"Testing/#event-handlers-setup-part-3","text":"There is further variation which is quite general but not as pure. During test setup we could literally just dispatch the events which would put app-db into the right state. Except, we'd have to use dispatch-sync rather dispatch to force immediate handling of events, rather than queuing. ;; setup - cummulatively build up db ( dispatch-sync [ :initialise-db ]) ( dispatch-sync [ :clear-panel ]) ( dispatch-sync [ :draw-triangle 1 2 3 ]) ;; execute ( dispatch-sync [ :select-triange :other :stuff ]) ;; validate that the value in 'app-db' is correct ;; perhaps with subscriptions Notes: we use dispatch-sync because dispatch is async (event is handled not now, but soon) Not pure. We are choosing to mutate the global app-db . But having said that, there's something about this approach which is remarkably pragmatic. the setup is now very natural. The associated handlers can be either -db or -fx if the handlers have effects other than just updating app-db, we might need to stub out XXX How do we look at the results ???? If this method appeals to you, you should ABSOLUTELY review the utilities in this helper library: re-frame-test . In summary, event handlers should be easy to test because they are pure functions. The interesting part is the unittest \"setup\" where we need to establish an initial value for db .","title":"Event Handlers - Setup - Part 3"},{"location":"Testing/#subscription-handlers","text":"Here's a Subscription Handler from the todomvc example : ( reg-sub :visible-todos ;; signal function ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) ;; computation function ( fn [[ todos showing ] _ ] ;; that 1st parameter is a 2-vector of values ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) How do we test this? First, we could split the computation function from its registration, like this: ( defn visible-todos [[ todos showing ] _ ] ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos ))) ( reg-sub :visible-todos ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) visible-todos ) ;; <--- computation function used here That makes visible-todos available for direct unit testing. But, as we experienced with Event Handlers, the challenge is around constructing db values (first parameter) in a way which doesn't become fragile.","title":"Subscription Handlers"},{"location":"Testing/#view-functions-part-1","text":"Components/views are more tricky and there are a few options. But remember my ugly secret - I don't tend to write tests for my views. But here's how, theoretically, I'd write tests if I wasn't me ... If a View Function is Form-1 , then it is fairly easy to test. A trivial example: ( defn greet [ name ] [ :div \"Hello \" name ]) ( greet \"Wiki\" ) ;;=> [:div \"Hello \" \"Wiki\"] So, here, testing involves passing values into the function and checking the data structure returned for correctness. What's returned is hiccup, of course. So how do you test hiccup for correctness? hiccup is just a clojure data structure - vectors containing keywords, and maps, and other vectors, etc. Perhaps you'd use https://github.com/nathanmarz/specter to declaratively check on the presence of certain values and structures? Or do it more manually.","title":"View Functions - Part 1"},{"location":"Testing/#view-functions-part-2a","text":"But what if the View Function has a subscription? ( defn my-view [ something ] ( let [ val ( subscribe [ :query-id ])] ;; <-- reactive subscription [ :div .... using @ val in here ])) The use of subscribe makes the function impure (it obtains data from places other than its args). A testing plan might be: setup app-db with some values in the right places (via dispatch of events?) call my-view (with a parameter) which will return hiccup check the hiccup structure for correctness. Continuing on, in a second phase you could then: change the value in app-db (which will cause the subscription to fire) call view functions again (hiccup returned) check the new hiccup for correctness. Which is all possible, if a little messy.","title":"View Functions - Part 2A"},{"location":"Testing/#view-functions-part-2b","text":"There is a pragmatic method available to handle the impurity: use with-redefs to stub out subscribe . Like this: ( defn subscription-stub [ x ] ( atom ( case x [ :query-id ] 42 ))) ( deftest some-test ( with-redefs [ re-frame/subscribe ( subscription-stub )] ( testing \"some some view which does a subscribe\" ..... call the view function and the hiccup output ))) For more integration level testing, you can use with-mounted-component from the reagent-template to render the component in the browser and validate the generated DOM.","title":"View Functions - Part 2B"},{"location":"Testing/#view-functions-part-2c","text":"Or ... there is another option: you can structure in the first place for pure view functions. The trick here is to create an outer and inner component. The outer sources the data (via a subscription), and passes it onto the inner as props (parameters). As a result, the inner component, which does the testable work, is pure and easily tested. The outer is impure but trivial. To get a more concrete idea, I'll direct you to another page in the re-frame docs which has nothing to do with testing, but it does use this simple-outer-subscribe-with-complicated-inner-render pattern for a different purpose: Using Stateful JS Components Note: this technique could be made simple and almost invisible via the use of macros. This pattern has been independently discovered by many. For example, here it is called the Container/Component pattern .","title":"View Functions - Part 2C"},{"location":"Testing/#also-read-this","text":"https://juxt.pro/blog/posts/cljs-apps.html","title":"Also Read This"},{"location":"Testing/#summary","text":"Event handlers will be your primary focus when testing. Remember to review the utilities in re-frame-test .","title":"Summary"},{"location":"The-re-frame-logo/","text":"\u00b6 Who? \u00b6 It was created by a mysterious, deep thinker, known only as @martinklepsch. Some say he appears on high-value stamps in Germany and that he once knocked a horse unconscious with a single punch. Others say he loves recursion so much that, in his wallet, he carries a photograph of his wallet. All we know for sure is that he wields pixels like Bruce Lee wielded nunchucks. Genesis Theories \u00b6 Great, unexplained works encourage fan theories, and the re-frame logo is no exception. One noisy group insist that @martinklepsch's design is assertively putting the 'f' back into infinity, in a sicking-it-to-the-man kinda way. They have t-shirts, f u \u221e , and angry certainty. Another group speculates that he created the logo as a bifarious rainbow homage to Frank Lloyd Wright's architectural masterpiece, the Guggenheim Museum. Which is surely a classic case of premature abstraction and over-engineering. Their theory, not the Guggenheim. They sometimes indent by 5 spaces - because \"art\" - and need ultrawide monitors for yaml. Then there's the infamous \"Bad Touch\" faction. So embarrassing. For them, the logo shows the ClojureScript logo mating noisily with re-frame's official architecture diagram. Colour-wise, I guess. Their parties are completely awesome, but you might need someone to bail you out of jail later. For the Functional Fundamentalists, an earnest bunch with post-Maharishi-Beatles hair, the logo is a flowing poststructuralist rebuttal of OO's vowel duplication and horizontal adjacency. Their alternative abbreviation, FF, is fine, apparently, because \"hey, come on man, everyone loves a fricative\". For his part, @martinklepsch has never confirmed any theory, teasing us instead with coded clues like \"Will you please stop emailing me\" and \"Why did you say I hit a horse?\".","title":"The Logo Backstory"},{"location":"The-re-frame-logo/#_1","text":"","title":""},{"location":"The-re-frame-logo/#who","text":"It was created by a mysterious, deep thinker, known only as @martinklepsch. Some say he appears on high-value stamps in Germany and that he once knocked a horse unconscious with a single punch. Others say he loves recursion so much that, in his wallet, he carries a photograph of his wallet. All we know for sure is that he wields pixels like Bruce Lee wielded nunchucks.","title":"Who?"},{"location":"The-re-frame-logo/#genesis-theories","text":"Great, unexplained works encourage fan theories, and the re-frame logo is no exception. One noisy group insist that @martinklepsch's design is assertively putting the 'f' back into infinity, in a sicking-it-to-the-man kinda way. They have t-shirts, f u \u221e , and angry certainty. Another group speculates that he created the logo as a bifarious rainbow homage to Frank Lloyd Wright's architectural masterpiece, the Guggenheim Museum. Which is surely a classic case of premature abstraction and over-engineering. Their theory, not the Guggenheim. They sometimes indent by 5 spaces - because \"art\" - and need ultrawide monitors for yaml. Then there's the infamous \"Bad Touch\" faction. So embarrassing. For them, the logo shows the ClojureScript logo mating noisily with re-frame's official architecture diagram. Colour-wise, I guess. Their parties are completely awesome, but you might need someone to bail you out of jail later. For the Functional Fundamentalists, an earnest bunch with post-Maharishi-Beatles hair, the logo is a flowing poststructuralist rebuttal of OO's vowel duplication and horizontal adjacency. Their alternative abbreviation, FF, is fine, apparently, because \"hey, come on man, everyone loves a fricative\". For his part, @martinklepsch has never confirmed any theory, teasing us instead with coded clues like \"Will you please stop emailing me\" and \"Why did you say I hit a horse?\".","title":"Genesis Theories"},{"location":"Using-Stateful-JS-Components/","text":"You know what's good for you, and you know what's right. But it doesn't matter - the wickedness of the temptation is too much. The JS world is brimming with shiny component baubles: D3, Google Maps, Chosen, etc. But they are salaciously stateful and mutative. And, you, raised in a pure, functional home, with caring, immutable parents, know they are wrong. But, my, how you still yearn for the sweet thrill of that forbidden fruit. I won't tell, if you don't. But careful plans must be made ... The overall plan \u00b6 To use a stateful js component, you'll need to write two Reagent components: an outer component responsible for sourcing data via a subscription or r/atom or cursor, etc. an inner component responsible for wrapping and manipulating the stateful JS component via lifecycle functions. The pattern involves the outer component, which sources data, supplying this data to the inner component via props . Example Using Google Maps \u00b6 ( defn gmap-inner [] ( let [ gmap ( atom nil ) options ( clj->js { \"zoom\" 9 }) update ( fn [ comp ] ( let [{ :keys [ latitude longitude ]} ( reagent/props comp ) latlng ( js/google.maps.LatLng. latitude longitude )] ( .setPosition ( :marker @ gmap ) latlng ) ( .panTo ( :map @ gmap ) latlng )))] ( reagent/create-class { :reagent-render ( fn [] [ :div [ :h4 \"Map\" ] [ :div#map-canvas { :style { :height \"400px\" }}]]) :component-did-mount ( fn [ comp ] ( let [ canvas ( .getElementById js/document \"map-canvas\" ) gm ( js/google.maps.Map. canvas options ) marker ( js/google.maps.Marker. ( clj->js { :map gm :title \"Drone\" }))] ( reset! gmap { :map gm :marker marker })) ( update comp )) :component-did-update update :display-name \"gmap-inner\" }))) ( defn gmap-outer [] ( let [ pos ( subscribe [ :current-position ])] ;; obtain the data ( fn [] ;; Note: @pos is a map here, so it gets passed as props. ;; Non-props values can be accessed via (reagent/argv comp) [ gmap-inner @ pos ]))) Notes: gmap-outer obtains data via a subscription. It is quite simple - trivial almost. it then passes this data as a prop to gmap-inner . This inner component has the job of wrapping/managing the stateful js component (Gmap in our case above) when the data (delivered by the subscription) to the outer layer changes, the inner layer, gmap-inner , will be given a new prop - @pos in the case above. when the inner component is given new props, its entire set of lifecycle functions will be engaged. the renderer for the inner layer ALWAYS renders the same, minimal container hiccup for the component. Even though the props have changed, the same hiccup is output. So it will appear to React as if nothing changes from one render to the next. No work to be done. React/Reagent will leave the DOM untouched. but this inner component has other lifecycle functions and this is where the real work is done. for example, after the renderer is called (which ignores its props), component-did-update will be called. In this function, we don't ignore the props, and we use them to update/mutate the stateful JS component. the props passed (in this case @pos ) in must be a map, otherwise (reagent/props comp) will return nil. Pattern Discovery \u00b6 This pattern has been independently discovered by many. To my knowledge, this description of the Container/Component pattern is the first time it was written up. Code Credit \u00b6 The example gmaps code above was developed by @jhchabran in this gist: https://gist.github.com/jhchabran/e09883c3bc1b703a224d#file-2_google_map-cljs D3 Examples \u00b6 D3 (from @zachcp): Blog Post: http://zachcp.org/blog/2015/reagent-d3/ Code: https://github.com/zachcp/simplecomponent Example: http://zachcp.github.io/simplecomponent/ RID3, a reagent interface to D3: Repo: https://github.com/gadfly361/rid3 Demo: https://rawgit.com/gadfly361/rid3/master/dev-resources/public/examples.html JS Interop \u00b6 You'll probably need to know how to do interop with js: http://www.spacjer.com/blog/2014/09/12/clojurescript-javascript-interop/ Perhaps use this library to make it even easier: https://github.com/binaryage/cljs-oops Advanced Lifecycle Methods \u00b6 If you mess around with lifecycle methods, you'll probably want to read Martin's explanations","title":"Using Stateful JS Components"},{"location":"Using-Stateful-JS-Components/#the-overall-plan","text":"To use a stateful js component, you'll need to write two Reagent components: an outer component responsible for sourcing data via a subscription or r/atom or cursor, etc. an inner component responsible for wrapping and manipulating the stateful JS component via lifecycle functions. The pattern involves the outer component, which sources data, supplying this data to the inner component via props .","title":"The overall plan"},{"location":"Using-Stateful-JS-Components/#example-using-google-maps","text":"( defn gmap-inner [] ( let [ gmap ( atom nil ) options ( clj->js { \"zoom\" 9 }) update ( fn [ comp ] ( let [{ :keys [ latitude longitude ]} ( reagent/props comp ) latlng ( js/google.maps.LatLng. latitude longitude )] ( .setPosition ( :marker @ gmap ) latlng ) ( .panTo ( :map @ gmap ) latlng )))] ( reagent/create-class { :reagent-render ( fn [] [ :div [ :h4 \"Map\" ] [ :div#map-canvas { :style { :height \"400px\" }}]]) :component-did-mount ( fn [ comp ] ( let [ canvas ( .getElementById js/document \"map-canvas\" ) gm ( js/google.maps.Map. canvas options ) marker ( js/google.maps.Marker. ( clj->js { :map gm :title \"Drone\" }))] ( reset! gmap { :map gm :marker marker })) ( update comp )) :component-did-update update :display-name \"gmap-inner\" }))) ( defn gmap-outer [] ( let [ pos ( subscribe [ :current-position ])] ;; obtain the data ( fn [] ;; Note: @pos is a map here, so it gets passed as props. ;; Non-props values can be accessed via (reagent/argv comp) [ gmap-inner @ pos ]))) Notes: gmap-outer obtains data via a subscription. It is quite simple - trivial almost. it then passes this data as a prop to gmap-inner . This inner component has the job of wrapping/managing the stateful js component (Gmap in our case above) when the data (delivered by the subscription) to the outer layer changes, the inner layer, gmap-inner , will be given a new prop - @pos in the case above. when the inner component is given new props, its entire set of lifecycle functions will be engaged. the renderer for the inner layer ALWAYS renders the same, minimal container hiccup for the component. Even though the props have changed, the same hiccup is output. So it will appear to React as if nothing changes from one render to the next. No work to be done. React/Reagent will leave the DOM untouched. but this inner component has other lifecycle functions and this is where the real work is done. for example, after the renderer is called (which ignores its props), component-did-update will be called. In this function, we don't ignore the props, and we use them to update/mutate the stateful JS component. the props passed (in this case @pos ) in must be a map, otherwise (reagent/props comp) will return nil.","title":"Example Using Google Maps"},{"location":"Using-Stateful-JS-Components/#pattern-discovery","text":"This pattern has been independently discovered by many. To my knowledge, this description of the Container/Component pattern is the first time it was written up.","title":"Pattern Discovery"},{"location":"Using-Stateful-JS-Components/#code-credit","text":"The example gmaps code above was developed by @jhchabran in this gist: https://gist.github.com/jhchabran/e09883c3bc1b703a224d#file-2_google_map-cljs","title":"Code Credit"},{"location":"Using-Stateful-JS-Components/#d3-examples","text":"D3 (from @zachcp): Blog Post: http://zachcp.org/blog/2015/reagent-d3/ Code: https://github.com/zachcp/simplecomponent Example: http://zachcp.github.io/simplecomponent/ RID3, a reagent interface to D3: Repo: https://github.com/gadfly361/rid3 Demo: https://rawgit.com/gadfly361/rid3/master/dev-resources/public/examples.html","title":"D3 Examples"},{"location":"Using-Stateful-JS-Components/#js-interop","text":"You'll probably need to know how to do interop with js: http://www.spacjer.com/blog/2014/09/12/clojurescript-javascript-interop/ Perhaps use this library to make it even easier: https://github.com/binaryage/cljs-oops","title":"JS Interop"},{"location":"Using-Stateful-JS-Components/#advanced-lifecycle-methods","text":"If you mess around with lifecycle methods, you'll probably want to read Martin's explanations","title":"Advanced Lifecycle Methods"},{"location":"a-loop/","text":"Homoiconic \u00b6 ClojureScript is a modern LISP, and LISPs are homoiconic . You program in a LISP by creating and assembling LISP data structures. The syntax is data literals. Dwell on that for a moment. You are programming in data . The functions which later transform data, themselves start as data. Computation involves evaluating data. Macros, running at compile time, take code (which is just data) and rewrite it to other code (other data). The duality of code and data runs deep. So, Clojurists place particular emphasis on the primacy of data. They meditate on aphorisms like data is the ultimate in late binding . They exalt inequalities like data > functions > macros . (They also re-watch Rich Hickey videos a bit too much, and wish that their hair was darker and more curly.) I cannot stress enough what a big deal this is. It will seem like a syntax curiosity at first but, when the penny drops for you on this, it tends to be a profound moment. So, it will come as no surprise, then, to find that re-frame has a data-oriented design. Events are data. Effects are data. DOM is data. The functions which transform data are registered and looked up via data. Interceptors (data) are preferred to middleware (higher order functions). Etc. And re-frame apps are reactive which further elevates data because in reactive systems, it is the arrival of data which coordinates the calling of functions , not the other way around. Data - that's the way we roll. The Data Loop \u00b6 Architecturally, re-frame implements \"a perpetual loop\". To build an app, you hang pure functions on certain parts of this loop, and re-frame looks after the conveyance of data around the loop, into and out of the transforming functions you provide. The tag line for re-frame is \"derived values, flowing\". Remember this diagram from school? The water cycle, right? Two distinct stages, involving water in different phases, being acted upon by different forces: gravity working one way, evaporation and convection the other. To understand re-frame, imagine data flowing around that loop instead of water . re-frame provides the conveyance of the data around the loop - the equivalent of gravity, evaporation and convection. You design what's flowing, and then you hang functions on the loop at various points to compute the data's phase changes. Sure, right now, you're thinking \"lazy sod - make a proper Computer Science-y diagram\". But, no. Joe Armstrong says \"don't break the laws of physics\" - I'm sure you've seen the videos - and if he says to do something, you do it (unless Rich Hickey disagrees, and says to do something else). So, this diagram, apart from being a plausible analogy which might help you to understand re-frame, is practically proof it does physics. Six Dominoes \u00b6 Each iteration of the re-frame loop has 6 stages, and because these stages happen one after the other, we talk about this process as a six domino cascade. One domino triggers the next, which triggers the next, boom, boom, boom, until we are back at the beginning of the loop, and the dominoes reset to attention again, ready for the next iteration of the same cascade. The six dominoes are: Event dispatch Event handling Effect handling Query View DOM Let's begin by looking at each of them from a great height - maybe from 60,000 feet . 1st Domino - Event Dispatch \u00b6 An event is sent when something happens - the user clicks a button, or a websocket receives a new message. Without the impulse of a triggering event , no six domino cascade occurs. It is only because of events that a re-frame app is propelled, loop iteration after loop iteration, from one state to the next. re-frame is event driven. 2nd Domino - Event Handling \u00b6 In response to an event , an application must decide what action to take. This is known as event handling . Event handler functions compute how an event should change \"the world\", which is to say that they compute the side effects of the event. Or, more accurately, they compute a declarative description of the required side effects - represented as data. So event handlers are just functions which compute data, and that data describes what needs to happen. Much of the time, an event will only cause side effects to \"application state\", but sometimes the outside world must also be affected: localstore, cookies, databases, emails, logs, etc. 3rd Domino - Effect Handling \u00b6 In this step, the side effects , calculated by the previous step, are actioned. Data gets turned into action and the world is mutated. Now, to a functional programmer, effects are scary in a xenomorph kind of way. Nothing messes with functional purity quite like the need for side effects. On the other hand, effects are marvelous because they move the app forward. Without them, an app stays stuck in one state forever, never achieving anything. So re-frame embraces the protagonist nature of effects - the entire, unruly zoo of them - but it does so in a controlled and largely hidden way, and in a manner which is debuggable, auditable, mockable and pluggable. We're Now At A Pivot Point \u00b6 Domino 3 just changed the world and, very often, one particular part of it: the application state . re-frame's application state is held in one place - think of it like you would an in-memory, central database for the app (details soon). Any changes to application state trigger the next part of the cascade involving dominoes 4-5-6. There's a Formula For It \u00b6 The 4-5-6 domino cascade implements the formula made famous by Facebook's ground-breaking React library: v = f(s) A view, v , is a function, f , of the app state, s . Said another way, there are functions f that compute which DOM nodes, v , should be displayed to the user when the application is in a given app state, s . Or, to capture the dynamics we'd say: over time , as s changes, f will be re-run each time to compute new v , forever keeping v up to date with the current s . Or, with yet another emphasis: over time what is presented to the user changes in response to application state changes. In our case, domino 3 changes s , the application state, and, in response, dominoes 4-5-6 are concerned with re-running f to compute the new v shown to the user. Except, there's no single f to run. There are many f which collectively build the overall v . And only a certain part of s may have changed, meaning only a subset of the f need rerun, to re-compute a subset of v . Domino 4 - Query \u00b6 Domino 4 is about extracting data from \"app state\", and providing it in the right format for the ViewFunctions of domino 5. Domino 4 is a novel and efficient de-duplicated Signal Graph which runs query functions on the app state, efficiently computing reactive, multi-layered, \"materialised views\" of it. Please relax about any unfamiliar terminology, you'll soon see how simple the code is in practice. Domino 5 - View \u00b6 Domino 5 is many ViewFunctions (aka Reagent components) which collectively render the UI of the application. Each ViewFunction renders part of the whole. These functions compute and return data in a format called hiccup which represents DOM. To render the right DOM, ViewFunctions must obtain state using the signal graph of domino 4. They use a subscribe facility which reactively delivers this state. They automatically re-run in response to changes in the Signal Graph, keeping the UI up to date. So, after the application state changes in domino 3, data flows through the Signal Graph of domino 4, causing the ViewFunctions to re-render the UI presented to the user. Domino 6 - DOM \u00b6 You don't write Domino 6 - it is handled for you by Reagent/React. I mention it here for completeness and to fully close the loop. This is the step in which the hiccup-formatted \"descriptions of required DOM\", returned by the ViewFunctions of Domino 5, are actioned. The browser DOM nodes are mutated.","title":"A Data Loop"},{"location":"a-loop/#homoiconic","text":"ClojureScript is a modern LISP, and LISPs are homoiconic . You program in a LISP by creating and assembling LISP data structures. The syntax is data literals. Dwell on that for a moment. You are programming in data . The functions which later transform data, themselves start as data. Computation involves evaluating data. Macros, running at compile time, take code (which is just data) and rewrite it to other code (other data). The duality of code and data runs deep. So, Clojurists place particular emphasis on the primacy of data. They meditate on aphorisms like data is the ultimate in late binding . They exalt inequalities like data > functions > macros . (They also re-watch Rich Hickey videos a bit too much, and wish that their hair was darker and more curly.) I cannot stress enough what a big deal this is. It will seem like a syntax curiosity at first but, when the penny drops for you on this, it tends to be a profound moment. So, it will come as no surprise, then, to find that re-frame has a data-oriented design. Events are data. Effects are data. DOM is data. The functions which transform data are registered and looked up via data. Interceptors (data) are preferred to middleware (higher order functions). Etc. And re-frame apps are reactive which further elevates data because in reactive systems, it is the arrival of data which coordinates the calling of functions , not the other way around. Data - that's the way we roll.","title":"Homoiconic"},{"location":"a-loop/#the-data-loop","text":"Architecturally, re-frame implements \"a perpetual loop\". To build an app, you hang pure functions on certain parts of this loop, and re-frame looks after the conveyance of data around the loop, into and out of the transforming functions you provide. The tag line for re-frame is \"derived values, flowing\". Remember this diagram from school? The water cycle, right? Two distinct stages, involving water in different phases, being acted upon by different forces: gravity working one way, evaporation and convection the other. To understand re-frame, imagine data flowing around that loop instead of water . re-frame provides the conveyance of the data around the loop - the equivalent of gravity, evaporation and convection. You design what's flowing, and then you hang functions on the loop at various points to compute the data's phase changes. Sure, right now, you're thinking \"lazy sod - make a proper Computer Science-y diagram\". But, no. Joe Armstrong says \"don't break the laws of physics\" - I'm sure you've seen the videos - and if he says to do something, you do it (unless Rich Hickey disagrees, and says to do something else). So, this diagram, apart from being a plausible analogy which might help you to understand re-frame, is practically proof it does physics.","title":"The Data Loop"},{"location":"a-loop/#six-dominoes","text":"Each iteration of the re-frame loop has 6 stages, and because these stages happen one after the other, we talk about this process as a six domino cascade. One domino triggers the next, which triggers the next, boom, boom, boom, until we are back at the beginning of the loop, and the dominoes reset to attention again, ready for the next iteration of the same cascade. The six dominoes are: Event dispatch Event handling Effect handling Query View DOM Let's begin by looking at each of them from a great height - maybe from 60,000 feet .","title":"Six Dominoes"},{"location":"a-loop/#1st-domino-event-dispatch","text":"An event is sent when something happens - the user clicks a button, or a websocket receives a new message. Without the impulse of a triggering event , no six domino cascade occurs. It is only because of events that a re-frame app is propelled, loop iteration after loop iteration, from one state to the next. re-frame is event driven.","title":"1st Domino - Event Dispatch"},{"location":"a-loop/#2nd-domino-event-handling","text":"In response to an event , an application must decide what action to take. This is known as event handling . Event handler functions compute how an event should change \"the world\", which is to say that they compute the side effects of the event. Or, more accurately, they compute a declarative description of the required side effects - represented as data. So event handlers are just functions which compute data, and that data describes what needs to happen. Much of the time, an event will only cause side effects to \"application state\", but sometimes the outside world must also be affected: localstore, cookies, databases, emails, logs, etc.","title":"2nd Domino - Event Handling"},{"location":"a-loop/#3rd-domino-effect-handling","text":"In this step, the side effects , calculated by the previous step, are actioned. Data gets turned into action and the world is mutated. Now, to a functional programmer, effects are scary in a xenomorph kind of way. Nothing messes with functional purity quite like the need for side effects. On the other hand, effects are marvelous because they move the app forward. Without them, an app stays stuck in one state forever, never achieving anything. So re-frame embraces the protagonist nature of effects - the entire, unruly zoo of them - but it does so in a controlled and largely hidden way, and in a manner which is debuggable, auditable, mockable and pluggable.","title":"3rd Domino - Effect Handling"},{"location":"a-loop/#were-now-at-a-pivot-point","text":"Domino 3 just changed the world and, very often, one particular part of it: the application state . re-frame's application state is held in one place - think of it like you would an in-memory, central database for the app (details soon). Any changes to application state trigger the next part of the cascade involving dominoes 4-5-6.","title":"We're Now At A Pivot Point"},{"location":"a-loop/#theres-a-formula-for-it","text":"The 4-5-6 domino cascade implements the formula made famous by Facebook's ground-breaking React library: v = f(s) A view, v , is a function, f , of the app state, s . Said another way, there are functions f that compute which DOM nodes, v , should be displayed to the user when the application is in a given app state, s . Or, to capture the dynamics we'd say: over time , as s changes, f will be re-run each time to compute new v , forever keeping v up to date with the current s . Or, with yet another emphasis: over time what is presented to the user changes in response to application state changes. In our case, domino 3 changes s , the application state, and, in response, dominoes 4-5-6 are concerned with re-running f to compute the new v shown to the user. Except, there's no single f to run. There are many f which collectively build the overall v . And only a certain part of s may have changed, meaning only a subset of the f need rerun, to re-compute a subset of v .","title":"There's a Formula For It"},{"location":"a-loop/#domino-4-query","text":"Domino 4 is about extracting data from \"app state\", and providing it in the right format for the ViewFunctions of domino 5. Domino 4 is a novel and efficient de-duplicated Signal Graph which runs query functions on the app state, efficiently computing reactive, multi-layered, \"materialised views\" of it. Please relax about any unfamiliar terminology, you'll soon see how simple the code is in practice.","title":"Domino 4 - Query"},{"location":"a-loop/#domino-5-view","text":"Domino 5 is many ViewFunctions (aka Reagent components) which collectively render the UI of the application. Each ViewFunction renders part of the whole. These functions compute and return data in a format called hiccup which represents DOM. To render the right DOM, ViewFunctions must obtain state using the signal graph of domino 4. They use a subscribe facility which reactively delivers this state. They automatically re-run in response to changes in the Signal Graph, keeping the UI up to date. So, after the application state changes in domino 3, data flows through the Signal Graph of domino 4, causing the ViewFunctions to re-render the UI presented to the user.","title":"Domino 5 - View"},{"location":"a-loop/#domino-6-dom","text":"You don't write Domino 6 - it is handled for you by Reagent/React. I mention it here for completeness and to fully close the loop. This is the step in which the hiccup-formatted \"descriptions of required DOM\", returned by the ViewFunctions of Domino 5, are actioned. The browser DOM nodes are mutated.","title":"Domino 6 - DOM"},{"location":"all-models-are-wrong/","text":"Mental Model Omnibus \u00b6 All models are wrong, but some are useful The re-frame tutorials initially focus on the domino narrative. The goal is to efficiently explain the mechanics of re-frame, and to get you reading and writing code ASAP. But there are other perspectives on re-frame which will deepen your understanding. This section of the tutorial is a tour of these ideas. If a factory is torn down but the rationality which produced it is left standing, then that rationality will simply produce another factory. If a revolution destroys a government, but the systematic patterns of thought that produced that government are left intact, then those patterns will repeat themselves. -- Robert Pirsig, Zen and the Art of Motorcycle Maintenance","title":"Other Models"},{"location":"all-models-are-wrong/#mental-model-omnibus","text":"All models are wrong, but some are useful The re-frame tutorials initially focus on the domino narrative. The goal is to efficiently explain the mechanics of re-frame, and to get you reading and writing code ASAP. But there are other perspectives on re-frame which will deepen your understanding. This section of the tutorial is a tour of these ideas. If a factory is torn down but the rationality which produced it is left standing, then that rationality will simply produce another factory. If a revolution destroys a government, but the systematic patterns of thought that produced that government are left intact, then those patterns will repeat themselves. -- Robert Pirsig, Zen and the Art of Motorcycle Maintenance","title":"Mental Model Omnibus"},{"location":"api-builtin-effects/","text":"Builtin Effects \u00b6 re-frame supplies a small number of built-in effects which contribute to the API. What Are Effects? \u00b6 Event handlers, such as those registered using reg-event-fx , compute and return a map of effects which might look like this: { :db new-db :fx [ [ :dispatch [ :some-id ]] [ :full-screen true ] [ :http { :method :GET :url \"http://somewhere.com/\" }]]} That's a map with two keys: :db and :fx . Which means there are two effects in this example. In another case, there could be more or less. Each effect consists of an id and a payload pair. The id identifies the effect required and the payload carries additional information which will parameterise the action taken. So, if an effect map was { :db new-value } , it would contain only one effect with an id of :db and a payload of new-value . In the example above, the effect :fx has a vector payload. That vector is a sequence of other effects, each captured as a 2-vector: [id payload] - for example [:full-screen true] . :fx is an effect which actions other effects in sequence - the ones in its payload. The two effects :db and :fx are a powerful combination, and both of these effects are built-in. That means re-frame itself uses reg-fx to register effect handlers for these two ids . Other effects, like :http , might come from a third-party library or from within your own application code. This page lists the built-in effects. :db \u00b6 reset! app-db to be a new value. The associated value is expected to be a map. The :db effect has a special status. It will always be actioned before others. (Prior to v1.1.0 this guarantee did not exist. There were no ordering guarantees). usage: { :db some-map } In the wild, real usage might look like this: ( reg-event-fx :token ( fn [{ :keys [ db ]} event ] { :db ( assoc db :some-key some-val )})) ;; <-- new value computed :fx \u00b6 Added in v1.1.0 An effect which actions other effects, sequentially. Expects a value which is a sequence, typically a vector. Each element in the sequence represents one effect. Each element is a 2-tuple of (1) an effect id and (2) the payload of the effect (the value ultimately given to the registered effect handler as an argument). For example: { :db new-db :fx [ [ :dispatch [ :some-id \"extra\" ]] [ :http-xhrio { :method :GET :url \"http://somewhere.com/\" }] ( when ( > 2 3 ) [ :full-screen true ])]} Notice the use of when to conditionally include or exclude an effect. Any nil found in a :fx sequence will be ignored. :dispatch \u00b6 dispatch one event. Expects a single vector. usage: { :fx [[ :dispatch [ :event-id \"param1\" :param2 ]]] } To dispatch multiple events: { :fx [[ :dispatch [ :event1 \"param1\" :param2 ]] [ :dispatch [ :second ]]} Effects in :fx are actioned in order, so the dispatched events will be queued and, later handled, in order supplied. FIFO. :dispatch-later \u00b6 dispatch one or more events after a given delay. Expects a payload which is a map with two keys: :ms (milliseconds delay), and :dispatch (the event). usage: { :fx [ [ :dispatch-later { :ms 200 :dispatch [ :event-id1 \"param\" ]}] [ :dispatch-later { :ms 100 :dispatch [ :event-id2 \"param\" ]}]]} Prior to re-frame v1.1.1 :dispatch-later required a seq of maps, since v1.1.1 it can also accept a single map. :deregister-event-handler \u00b6 Removes a previously registered event handler. Expects the event id for a previously registered event handler. usage: { :db new-db :fx [[ :deregister-event-handler :my-id ]])} :dispatch-n \u00b6 From v1.1.0 onwards, this effect is deprecated in favour of using :fx with multiple :dispatch tuples. dispatch more than one event. Expects a seq of event vectors (typically a list of them). usage: { :db new-db :fx [[ :dispatch-n ( list [ :do :all ] [ :three :of ] [ :these ])]]} Notes: The events will be dispatched in the order provided. And, because events are handled FIFO, the events will subsequently be processed in the order provided. nils in the event collection are ignored which means events can be added conditionally: clojure {:db new-db :fx [[:dispatch-n (list (when (> 3 5) [:conditioned-out]) [:another-one])]]}","title":"Builtin Effects"},{"location":"api-builtin-effects/#builtin-effects","text":"re-frame supplies a small number of built-in effects which contribute to the API.","title":"Builtin Effects"},{"location":"api-builtin-effects/#what-are-effects","text":"Event handlers, such as those registered using reg-event-fx , compute and return a map of effects which might look like this: { :db new-db :fx [ [ :dispatch [ :some-id ]] [ :full-screen true ] [ :http { :method :GET :url \"http://somewhere.com/\" }]]} That's a map with two keys: :db and :fx . Which means there are two effects in this example. In another case, there could be more or less. Each effect consists of an id and a payload pair. The id identifies the effect required and the payload carries additional information which will parameterise the action taken. So, if an effect map was { :db new-value } , it would contain only one effect with an id of :db and a payload of new-value . In the example above, the effect :fx has a vector payload. That vector is a sequence of other effects, each captured as a 2-vector: [id payload] - for example [:full-screen true] . :fx is an effect which actions other effects in sequence - the ones in its payload. The two effects :db and :fx are a powerful combination, and both of these effects are built-in. That means re-frame itself uses reg-fx to register effect handlers for these two ids . Other effects, like :http , might come from a third-party library or from within your own application code. This page lists the built-in effects.","title":"What Are Effects?"},{"location":"api-builtin-effects/#db","text":"reset! app-db to be a new value. The associated value is expected to be a map. The :db effect has a special status. It will always be actioned before others. (Prior to v1.1.0 this guarantee did not exist. There were no ordering guarantees). usage: { :db some-map } In the wild, real usage might look like this: ( reg-event-fx :token ( fn [{ :keys [ db ]} event ] { :db ( assoc db :some-key some-val )})) ;; <-- new value computed","title":" :db"},{"location":"api-builtin-effects/#fx","text":"Added in v1.1.0 An effect which actions other effects, sequentially. Expects a value which is a sequence, typically a vector. Each element in the sequence represents one effect. Each element is a 2-tuple of (1) an effect id and (2) the payload of the effect (the value ultimately given to the registered effect handler as an argument). For example: { :db new-db :fx [ [ :dispatch [ :some-id \"extra\" ]] [ :http-xhrio { :method :GET :url \"http://somewhere.com/\" }] ( when ( > 2 3 ) [ :full-screen true ])]} Notice the use of when to conditionally include or exclude an effect. Any nil found in a :fx sequence will be ignored.","title":" :fx"},{"location":"api-builtin-effects/#dispatch","text":"dispatch one event. Expects a single vector. usage: { :fx [[ :dispatch [ :event-id \"param1\" :param2 ]]] } To dispatch multiple events: { :fx [[ :dispatch [ :event1 \"param1\" :param2 ]] [ :dispatch [ :second ]]} Effects in :fx are actioned in order, so the dispatched events will be queued and, later handled, in order supplied. FIFO.","title":" :dispatch"},{"location":"api-builtin-effects/#dispatch-later","text":"dispatch one or more events after a given delay. Expects a payload which is a map with two keys: :ms (milliseconds delay), and :dispatch (the event). usage: { :fx [ [ :dispatch-later { :ms 200 :dispatch [ :event-id1 \"param\" ]}] [ :dispatch-later { :ms 100 :dispatch [ :event-id2 \"param\" ]}]]} Prior to re-frame v1.1.1 :dispatch-later required a seq of maps, since v1.1.1 it can also accept a single map.","title":" :dispatch-later"},{"location":"api-builtin-effects/#deregister-event-handler","text":"Removes a previously registered event handler. Expects the event id for a previously registered event handler. usage: { :db new-db :fx [[ :deregister-event-handler :my-id ]])}","title":" :deregister-event-handler"},{"location":"api-builtin-effects/#dispatch-n","text":"From v1.1.0 onwards, this effect is deprecated in favour of using :fx with multiple :dispatch tuples. dispatch more than one event. Expects a seq of event vectors (typically a list of them). usage: { :db new-db :fx [[ :dispatch-n ( list [ :do :all ] [ :three :of ] [ :these ])]]} Notes: The events will be dispatched in the order provided. And, because events are handled FIFO, the events will subsequently be processed in the order provided. nils in the event collection are ignored which means events can be added conditionally: clojure {:db new-db :fx [[:dispatch-n (list (when (> 3 5) [:conditioned-out]) [:another-one])]]}","title":" :dispatch-n"},{"location":"api-intro/","text":"Overview \u00b6 The re-frame API consists of: the namespace re-frame.core a set of built-in effects In the navigation to the left, you'll see a link to both. Dependency Information \u00b6 Please review both the releases page and the Clojars page to discover the version you should be using. Using re-frame \u00b6 To use the re-frame API within your namespace, you'll need to require it, perhaps like this: ( ns my-app.some-namespace ( :require [ re-frame.core :as rf ])) ;; your code here You'll then be able to use the functions in the API, perhaps like this: rf/dispatch . The Most Commonly Used Part Of The API \u00b6 When you are writing View Functions : dispatch (or occasionally, dispatch-sync ) subscribe When you are registering: event handlers - reg-event-db and reg-event-fx subscription handlers - reg-sub (and rarely reg-sub-raw ) rarely, effect handlers - reg-fx rarely, coeffect handlers - reg-cofx with inject-cofx When you register event handlers , you might use builtin interceptors: path on-change enrich after trim-v debug Global interceptors can be very useful: register them via reg-global-interceptors rarely, remove them via clear-global-interceptor More Rarely Used Part \u00b6 Testing or dev-time related utilities: clear-subscription-cache! make-restore-fn purge-event-queue Logging/debugging: console set-loggers If you write an Interceptor, use these utilities. To see how they are used, look at the re-frame code for builtin Interceptors : ->interceptor get-coeffect assoc-coeffect get-effect assoc-effect enqueue","title":"Overview"},{"location":"api-intro/#overview","text":"The re-frame API consists of: the namespace re-frame.core a set of built-in effects In the navigation to the left, you'll see a link to both.","title":"Overview"},{"location":"api-intro/#dependency-information","text":"Please review both the releases page and the Clojars page to discover the version you should be using.","title":"Dependency Information"},{"location":"api-intro/#using-re-frame","text":"To use the re-frame API within your namespace, you'll need to require it, perhaps like this: ( ns my-app.some-namespace ( :require [ re-frame.core :as rf ])) ;; your code here You'll then be able to use the functions in the API, perhaps like this: rf/dispatch .","title":"Using re-frame"},{"location":"api-intro/#the-most-commonly-used-part-of-the-api","text":"When you are writing View Functions : dispatch (or occasionally, dispatch-sync ) subscribe When you are registering: event handlers - reg-event-db and reg-event-fx subscription handlers - reg-sub (and rarely reg-sub-raw ) rarely, effect handlers - reg-fx rarely, coeffect handlers - reg-cofx with inject-cofx When you register event handlers , you might use builtin interceptors: path on-change enrich after trim-v debug Global interceptors can be very useful: register them via reg-global-interceptors rarely, remove them via clear-global-interceptor","title":"The Most Commonly Used Part Of The API"},{"location":"api-intro/#more-rarely-used-part","text":"Testing or dev-time related utilities: clear-subscription-cache! make-restore-fn purge-event-queue Logging/debugging: console set-loggers If you write an Interceptor, use these utilities. To see how they are used, look at the re-frame code for builtin Interceptors : ->interceptor get-coeffect assoc-coeffect get-effect assoc-effect enqueue","title":"More Rarely Used Part"},{"location":"api-re-frame.core/","text":"re-frame.core \u00b6 Dispatching Events \u00b6 dispatch \u00b6 ( dispatch event ) Queue event for processing (handling). event is a vector and the first element is typically a keyword which identifies the kind of event. The event will be added to a FIFO processing queue, so event handling does not happen immediately. It will happen 'very soon' but not now. And if the queue already contains events, they will be processed first. Usage: 1 ( dispatch [ :order \"pizza\" { :supreme 2 :meatlovers 1 :veg 1 }]) dispatch-sync \u00b6 ( dispatch-sync event ) Synchronously (immediately) process event . It does not queue the event for handling later as dispatch does. event is a vector and the first element is typically a keyword which identifies the kind of event. It is an error to use dispatch-sync within an event handler because you can't immediately process an new event when one is already part way through being processed. Generally, avoid using this function, and instead, use dispatch . Only use it in the narrow set of cases where any delay in processing is a problem: the :on-change handler of a text field where we are expecting fast typing when initialising your app - see 'main' in examples/todomvc/src/core.cljs in a unit test where immediate, synchronous processing is useful Usage: 1 ( dispatch-sync [ :sing :falsetto \"piano accordion\" ]) Event Handlers \u00b6 reg-event-db \u00b6 ( reg-event-db id handler ) ( reg-event-db id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: (db event) -> db interceptors is a collection of interceptors. Will be flattened and nils removed. Example Usage: 1 2 3 4 ( reg-event-db :token ( fn [ db event ] ( assoc db :some-key ( get event 2 ))) ;; return updated db Or perhaps: 1 2 3 4 5 6 7 ( reg-event-db :namespaced/id ;; <-- namespaced keywords are often used [ one two three ] ;; <-- a seq of interceptors ( fn [ db [ _ arg1 arg2 ]] ;; <-- event vector is destructured ( -> db ( dissoc arg1 ) ( update :key + arg2 )))) ;; return updated db reg-event-fx \u00b6 ( reg-event-fx id handler ) ( reg-event-fx id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: (coeffects-map event-vector) -> effects-map interceptors is a collection of interceptors. Will be flattened and nils removed. Example Usage: 1 2 3 4 ( reg-event-fx :event-id ( fn [ cofx event ] { :db ( assoc ( :db cofx ) :some-key ( get event 2 ))})) ;; return a map of effects Or perhaps: 1 2 3 4 5 6 ( reg-event-fx :namespaced/id ;; <-- namespaced keywords are often used [ one two three ] ;; <-- a seq of interceptors ( fn [{ :keys [ db ] :as cofx } [ _ arg1 arg2 ]] ;; destructure both arguments { :db ( assoc db :some-key arg1 ) ;; return a map of effects :fx [[ :dispatch [ :some-event arg2 ]]]})) reg-event-ctx \u00b6 ( reg-event-ctx id handler ) ( reg-event-ctx id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: context-map -> context-map You can explore what is provided in context here . Example Usage: 1 2 3 4 5 6 7 8 9 10 11 12 ( reg-event-ctx :event-id ( fn [{ :keys [ coeffects ] :as context }] ( let [ initial { :db ( :db coeffects ) :event ( :event coeffects ) :fx []} result ( -> initial function1 function2 function3 ) effects ( select-keys result [ :db :fx ])] ( assoc context :effects effects )))) clear-event \u00b6 ( clear-event ) ( clear-event id ) Unregisters event handlers (presumably registered previously via the use of reg-event-db or reg-event-fx ). When called with no args, it will unregister all currently registered event handlers. When given one arg, assumed to be the id of a previously registered event handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration. Subscriptions \u00b6 reg-sub \u00b6 ( reg-sub query-id & args ) A call to reg-sub associates a query-id WITH two functions. The two functions provide 'a mechanism' for creating a node in the Signal Graph. When a node of type query-id is needed, the two functions can be used to create it. The three arguments are: query-id - typically a namespaced keyword (later used in subscribe) optionally, an input signals function which returns the input data flows required by this kind of node. a computation function which computes the value (output) of the node (from the input data flows) Later, during app execution, a call to (subscribe [:sub-id 3 :blue]) , will trigger the need for a new :sub-id Signal Graph node (matching the query [:sub-id 3 :blue] ). And, to create that node the two functions associated with :sub-id will be looked up and used. Just to be clear: calling reg-sub does not immediately create a node. It only registers 'a mechanism' (the two functions) by which nodes can be created later, when a node is bought into existence by the use of subscribe in a View Function . reg-sub arguments are: a query-id (typically a namespaced keyword) a function which returns the inputs required by this kind of node (can be supplied in one of three ways) a function which computes the value of this kind of node (can be supplied in one of three ways) The computation function is always the last argument supplied and has three ways to be called. Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data. A function that will accept two parameters, the input-values and query-vector . This is the standard way to provide a computation-function 1 2 3 4 ( reg-sub :query-id ( fn [ input-values query-vector ] ( :foo input-values ))) A single sugary tuple of :-> and a 1-arity computation-function : 1 2 3 ( reg-sub :query-id :-> computation-fn ) This sugary variation allows you to pass a function that will expect only one parameter, namely the input-values and entirely omit the query-vector . A typical computation-function expects two parameters which can cause unfortunate results when attempting to use clojure standard library functions, or other functions, in a functional manner. For example, a significant number of subscriptions exist only to get a value from the input-values . As shown below, this subscription will simply retrieve the value associated with the :foo key in our db: 1 2 3 4 ( reg-sub :query-id ( fn [ db _ ] ;; :<---- trivial boilerplate we might want to skip over ( :foo db ))) This is slightly more boilerplate than we might like to do, as we can use a keyword directly as a function, and we might like to do this: 1 2 3 ( reg-sub :query-id :foo ) ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`. By using :-> our function would not contain the query-vector , and any missing keys would be represented as such: 1 2 3 ( reg-sub :query-id :-> :foo ) This form allows us to ignore the query-vector if our computation-function has no need for it, and be safe from any accidents. Any 1-arity function can be provided, and for more complicated use cases, partial , comp , and anonymous functions can still be used. A single sugary tuple of :=> and a multi-arity computation-function 1 2 3 ( reg-sub :query-id :=> computation-fn ) The query-vector can be broken into two components [query-id & optional-values] , and some subscriptions require the optional-values for extra work within the subscription. To use them in variation #1, we need to destructure our computation-function parameters in order to use them. 1 2 3 4 ( reg-sub :query-id ( fn [ db [ _ foo ]] [ db foo ])) Again we are writing boilerplate just to reach our values, and we might prefer to have direction access through a parameter vector like [input-values optional-values] instead, so we might be able to use a multi-arity function directly as our computation-function . A rewrite of the above sub using this sugary syntax would look like this: 1 2 3 ( reg-sub :query-id :=> vector ) ;; :<---- Could also be `(fn [db foo] [db foo])` The computation function is expected to take two arguments: input-values - the values which flow into this node (how is it wired into the graph?) query-vector - the vector given to subscribe and it returns a computed value (which then becomes the output of the node) When computation function is called, the 2nd query-vector argument will be that vector supplied to the subscribe . So, if the call was (subscribe [:sub-id 3 :blue]) , then the query-vector supplied to the computation function will be [:sub-id 3 :blue] . The argument(s) supplied to reg-sub between query-id and the computation-function can vary in 3 ways, but whatever is there defines the input signals part of the mechanism , specifying what input values \"flow into\" the computation function (as the 1st argument) when it is called. So, reg-sub can be called in one of three ways, because there are three ways to define the input signals part. But note, the 2nd method, in which a signals function is explicitly supplied, is the most canonical and instructive. The other two are really just sugary variations. First variation - no input signal function given: 1 2 3 ( reg-sub :query-id a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) In the absence of an explicit signals function , the node's input signal defaults to app-db and, as a result, the value within app-db (a map) is given as the 1st argument when a-computation-fn is called. Second variation - a signal function is explicitly supplied: 1 2 3 4 ( reg-sub :query-id signal-fn ;; <-- here computation-fn ) This is the most canonical and instructive of the three variations. When a node is created from the template, the signal function will be called and it is expected to return the input signal(s) as either a singleton, if there is only one, or a sequence if there are many, or a map with the signals as the values. The current values of the returned signals will be supplied as the 1st argument to the a-computation-fn when it is called - and subject to what this signal-fn returns, this value will be either a singleton, sequence or map of them (paralleling the structure returned by the signal function ). This example signal function returns a 2-vector of input signals. 1 2 3 ( fn [ query-vec dynamic-vec ] [( subscribe [ :a-sub ]) ( subscribe [ :b-sub ])]) The associated computation function must be written to expect a 2-vector of values for its first argument: 1 2 ( fn [[ a b ] query-vec ] ;; 1st argument is a seq of two values .... ) If, on the other hand, the signal function was simpler and returned a singleton, like this: 1 2 ( fn [ query-vec dynamic-vec ] ( subscribe [ :a-sub ])) ;; <-- returning a singleton then the associated computation function must be written to expect a single value as the 1st argument: 1 2 ( fn [ a query-vec ] ;; 1st argument is a single value ... ) Further Note: variation #1 above, in which an signal-fn was not supplied, like this: 1 2 3 ( reg-sub :query-id a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) is the equivalent of using this 2nd variation and explicitly supplying a signal-fn which returns app-db : 1 2 3 4 ( reg-sub :query-id ( fn [ _ _ ] re-frame/app-db ) ;; <--- explicit signal-fn a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) Third variation - syntax Sugar 1 2 3 4 5 6 ( reg-sub :a-b-sub :<- [ :a-sub ] :<- [ :b-sub ] ( fn [[ a b ] query-vec ] ;; 1st argument is a seq of two values { :a a :b b })) This 3rd variation is just syntactic sugar for the 2nd. Instead of providing an signals-fn you provide one or more pairs of :<- and a subscription vector. If you supply only one pair a singleton will be supplied to the computation function, as if you had supplied a signal-fn returning only a single value: 1 2 3 4 5 ( reg-sub :a-sub :<- [ :a-sub ] ( fn [ a query-vec ] ;; only one pair, so 1st argument is a single value ... )) Syntactic sugar for both the signal-fn and computation-fn can be used together and the direction of arrows shows the flow of data and functions. The example from directly above is reproduced here: 1 2 3 4 5 ( reg-sub :a-b-sub :<- [ :a-sub ] :<- [ :b-sub ] :-> ( partial zipmap [ :a :b ])) For further understanding, read the tutorials, and look at the detailed comments in /examples/todomvc/src/subs.cljs. See also: subscribe subscribe \u00b6 ( subscribe query ) ( subscribe query dynv ) Given a query vector, returns a Reagent reaction which will, over time, reactively deliver a stream of values. So, in FRP-ish terms, it returns a Signal . To obtain the current value from the Signal, it must be dereferenced: 1 2 3 ( let [ signal ( subscribe [ :items ]) value ( deref signal )] ;; could be written as @signal ... ) which is typically written tersely as simple: 1 2 ( let [ items @ ( subscribe [ :items ])] ... ) query is a vector of at least one element. The first element is the query-id , typically a namespaced keyword. The rest of the vector's elements are optional, additional values which parameterise the query performed. dynv is an optional 3rd argument, which is a vector of further input signals (atoms, reactions, etc), NOT values. This argument exists for historical reasons and is borderline deprecated these days. Example Usage : 1 2 3 ( subscribe [ :items ]) ( subscribe [ :items \"blue\" :small ]) ( subscribe [ :items { :colour \"blue\" :size :small }]) Note: for any given call to subscribe there must have been a previous call to reg-sub , registering the query handler (functions) associated with query-id . Hint When used in a view function BE SURE to deref the returned value. In fact, to avoid any mistakes, some prefer to define: 1 ( def <sub ( comp deref re-frame.core/subscribe )) And then, within their views, they call (<sub [:items :small]) rather than using subscribe directly. De-duplication Two, or more, concurrent subscriptions for the same query will source reactive updates from the one executing handler. See also: reg-sub clear-sub \u00b6 ( clear-sub ) ( clear-sub query-id ) Unregisters subscription handlers (presumably registered previously via the use of reg-sub ). When called with no args, it will unregister all currently registered subscription handlers. When given one arg, assumed to be the id of a previously registered subscription handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration. NOTE: Depending on the usecase, it may be necessary to call clear-subscription-cache! afterwards reg-sub-raw \u00b6 ( reg-sub-raw query-id handler-fn ) This is a low level, advanced function. You should probably be using reg-sub instead. Some explanation is available in the docs at http://day8.github.io/re-frame/flow-mechanics/ clear-subscription-cache! \u00b6 ( clear-subscription-cache! ) Removes all subscriptions from the cache. This function can be used at development time or test time. Useful when hot reloading namespaces containing subscription handlers. Also call it after a React/render exception, because React components won't have been cleaned up properly. And this, in turn, means the subscriptions within those components won't have been cleaned up correctly. So this forces the issue. Effect Handlers \u00b6 reg-fx \u00b6 ( reg-fx id handler ) Register the given effect handler for the given id : id is keyword, often namespaced. handler is a side-effecting function which takes a single argument and whose return value is ignored. To use, first, associate :effect2 with a handler: 1 2 3 4 ( reg-fx :effect2 ( fn [ value ] ... do something side-effect-y )) Then, later, if an event handler were to return this effects map: 1 { :effect2 [ 1 2 ]} then the handler fn we registered previously, using reg-fx , will be called with an argument of [1 2] . clear-fx \u00b6 ( clear-fx ) ( clear-fx id ) Unregisters effect handlers (presumably registered previously via the use of reg-fx ). When called with no args, it will unregister all currently registered effect handlers. When given one arg, assumed to be the id of a previously registered effect handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration. Coeffects \u00b6 reg-cofx \u00b6 ( reg-cofx id handler ) Register the given coeffect handler for the given id , for later use within inject-cofx : id is keyword, often namespaced. handler is a function which takes either one or two arguments, the first of which is always coeffects and which returns an updated coeffects . See also: inject-cofx inject-cofx \u00b6 ( inject-cofx id ) ( inject-cofx id value ) Given an id , and an optional, arbitrary value , returns an interceptor whose :before adds to the :coeffects (map) by calling a pre-registered 'coeffect handler' identified by the id . The previous association of a coeffect handler with an id will have happened via a call to re-frame.core/reg-cofx - generally on program startup. Within the created interceptor, this 'looked up' coeffect handler will be called (within the :before ) with two arguments: the current value of :coeffects optionally, the originally supplied arbitrary value This coeffect handler is expected to modify and return its first, coeffects argument. Example of inject-cofx and reg-cofx working together First - Early in app startup, you register a coeffect handler for :datetime : 1 2 3 4 5 ( re-frame.core/reg-cofx :datetime ;; usage (inject-cofx :datetime) ( fn coeffect-handler [ coeffect ] ( assoc coeffect :now ( js/Date. )))) ;; modify and return first arg Second - Later, add an interceptor to an -fx event handler, using inject-cofx : 1 2 3 4 5 6 7 ( re-frame.core/reg-event-fx ;; when registering an event handler :event-id [ ... ( inject-cofx :datetime ) ... ] ;; <-- create an injecting interceptor ( fn event-handler [ coeffect event ] ;;... in here can access (:now coeffect) to obtain current datetime ... ))) Background coeffects are the input resources required by an event handler to perform its job. The two most obvious ones are db and event . But sometimes an event handler might need other resources. Perhaps an event handler needs a random number or a GUID or the current datetime. Perhaps it needs access to a DataScript database connection. If an event handler directly accesses these resources, it stops being pure and, consequently, it becomes harder to test, etc. So we don't want that. Instead, the interceptor created by this function is a way to 'inject' 'necessary resources' into the :coeffects (map) subsequently given to the event handler at call time. See also reg-cofx clear-cofx \u00b6 ( clear-cofx ) ( clear-cofx id ) Unregisters coeffect handlers (presumably registered previously via the use of reg-cofx ). When called with no args, it will unregister all currently registered coeffect handlers. When given one arg, assumed to be the id of a previously registered coeffect handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration. Interceptors \u00b6 debug \u00b6 An interceptor which logs/instruments an event handler's actions to re-frame/console at the :log level. Output includes: the event vector a clojure.data/diff of db, before vs after, which shows the changes caused by the event handler. To understand the output, you should understand: https://clojuredocs.org/clojure.data/diff . You'd typically include this interceptor after (to the right of) any path interceptor. Warning: calling clojure.data/diff on large, complex data structures can be slow. So, you won't want this interceptor present in production code. So, you should condition it out like this: 1 2 3 4 5 ( re-frame.core/reg-event-db :evt-id [( when ^ boolean goog.DEBUG re-frame.core/debug )] ;; <-- conditional ( fn [ db v ] ... )) To make this code fragment work, you'll also have to set goog.DEBUG to false in your production builds. For an example, look in project.clj of /examples/todomvc. path \u00b6 ( path & args ) Returns an interceptor which acts somewhat like clojure.core/update-in , in the sense that the event handler is given a specific part of app-db to change, not all of app-db . The interceptor has both a :before and :after functions. The :before replaces the :db key within coeffects with a sub-path within app-db . The :after reverses the process, and it grafts the handler's return value back into db, at the right path. Examples: 1 2 3 4 ( path :some :path ) ( path [ :some :path ]) ( path [ :some :path ] :to :here ) ( path [ :some :path ] [ :to ] :here ) Example Use: 1 2 3 4 5 ( reg-event-db :event-id ( path [ :a :b ]) ;; <-- used here, in interceptor chain ( fn [ b v ] ;; 1st arg is not db. Is the value from path [:a :b] within db ... new-b )) ;; returns a new value for that path (not the entire db) Notes: path may appear more than once in an interceptor chain. Progressive narrowing. if :effects contains no :db effect, can't graft a value back in. enrich \u00b6 ( enrich f ) Returns an interceptor which will run the given function f in the :after position. f is called with two arguments: db and event , and is expected to return a modified db . Unlike the after interceptor which is only about side effects, enrich expects f to process and alter the given db coeffect in some useful way, contributing to the derived data, flowing vibe. If f returns nil , the db value passed to f will be returned instead. Example Use: Imagine that todomvc needed to do duplicate detection - if any two todos had the same text, then highlight their background, and report them via a warning at the bottom of the panel. Almost any user action (edit text, add new todo, remove a todo) requires a complete reassessment of duplication errors and warnings. E.g. that edit just made might have introduced a new duplicate, or removed one. Same with any todo removal. So we need to re-calculate warnings after any CRUD events associated with the todos list. Unless we are careful, we might end up coding subtly different checks for each kind of CRUD operation. The duplicates check made after 'delete todo' event might be subtly different to that done after an editing operation. Nice and efficient, but fiddly. A bug generator approach. So, instead, we create an f which recalculates ALL warnings from scratch every time there is ANY change. It will inspect all the todos, and reset ALL FLAGS every time (overwriting what was there previously) and fully recalculate the list of duplicates (displayed at the bottom?). https://twitter.com/nathanmarz/status/879722740776939520 By applying f in an :enrich interceptor, after every CRUD event, we keep the handlers simple and yet we ensure this important step (of getting warnings right) is not missed on any change. We can test f easily - it is a pure function - independently of any CRUD operation. This brings huge simplicity at the expense of some re-computation each time. This may be a very satisfactory trade-off in many cases. Returning nil In some cases, it's useful to apply a change to specific situations that can be determined at runtime instead of when defining the handler with an :enrich interceptor. Instead of forcing you to return the db from every non-applicable branch, you can return nil to use the given db value: 1 2 3 4 5 ( def set-last-update ( core/enrich ( fn [{ db :db } [ _ { user :user }]] ( when ( active-user? user ) ;; <- Only perform an update if user is active ... )))) unwrap \u00b6 New in v1.2.0 An interceptor which decreases the amount of destructuring necessary in an event handler where the event is structured as a 2-vector of [event-id payload-map]. It promotes the payload-map part to be the event ultimately given to the event handler. Should you want the full original event, it can be found in coeffects under the key :original-event . If a dispatch looked like this: 1 ( dispatch [ :event-id { :x 1 :y 2 :z 3 }]) Your event handlers can look like this: 1 2 3 4 5 ( reg-event-fx :event-id [ ... unwrap ... ] ;; <-- added to the interceptors ( fn [{ :keys [ db ]} { :keys [ x y z ]}] ;; <-- instead of [_ {:keys [x y z]}] ... ) trim-v \u00b6 An interceptor which removes the first element of the event vector, before it is supplied to the event handler, allowing you to write more aesthetically pleasing event handlers. No leading underscore on the event-v! Should you want the full original event, it can be found in coeffects under the key :original-event . Your event handlers will look like this: 1 2 3 4 5 ( reg-event-db :event-id [ ... trim-v ... ] ;; <-- added to the interceptors ( fn [ db [ x y z ]] ;; <-- instead of [_ x y z] ... ) after \u00b6 ( after f ) Returns an interceptor which runs the given function f in the :after position, presumably for side effects. f is called with two arguments: the :effects value for :db (or the :coeffect value of :db if no :db effect is returned) and the event. Its return value is ignored, so f can only side-effect. An example of use can be seen in the re-frame github repo in /examples/todomvc/events.cljs : f runs schema validation (reporting any errors found). f writes to localstorage. on-changes \u00b6 ( on-changes f out-path & in-paths ) Returns an interceptor which will observe N paths within db , and if any of them test not identical? to their previous value (as a result of a event handler being run), then it will run f to compute a new value, which is then assoc-ed into the given out-path within db . Example Usage: 1 2 3 4 5 6 7 8 9 10 11 12 ( defn my-f [ a-val b-val ] ... some computation on a and b in here ) ;; use it ( def my-interceptor ( on-changes my-f [ :c ] [ :a ] [ :b ])) ( reg-event-db :event-id [ ... my-interceptor ... ] ;; <-- ultimately used here ( fn [ db v ] ... )) If you put this interceptor on handlers which might change paths :a or :b , it will: call f each time the value at path [:a] or [:b] changes call f with the values extracted from [:a] [:b] assoc the return value from f into the path [:c] Global Interceptors \u00b6 reg-global-interceptor \u00b6 ( reg-global-interceptor interceptor ) Registers the given interceptor as a global interceptor. Global interceptors are included in the processing chain of every event. When you register an event handler, you have the option of supplying an interceptor chain. Any global interceptors you register are effectively prepending to this chain. Global interceptors are run in the order that they are registered. clear-global-interceptor \u00b6 ( clear-global-interceptor ) ( clear-global-interceptor id ) Unregisters global interceptors (presumably registered previously via the use of reg-global-interceptor ). When called with no args, it will unregister all currently registered global interceptors. When given one arg, assumed to be the id of a previously registered global interceptors, it will unregister the associated interceptor. Will produce a warning to console if it finds no matching registration. Writing Interceptors \u00b6 ->interceptor \u00b6 ( ->interceptor & { :as m , :keys [ id before after ]}) A utility function for creating interceptors. Accepts three optional, named arguments: :id - an id for the interceptor (decorative only) :before - the interceptor's before function :after - the interceptor's after function Example use: 1 2 3 4 5 6 7 ( def my-interceptor ( ->interceptor :id :my-interceptor :before ( fn [ context ] ... modifies and returns ` context ` ) :after ( fn [ context ] ... modifies and returns ` context ` ))) Notes: :before functions modify and return their context argument. Sometimes they only side effect, in which case, they'll perform the side effect and return context unchanged. :before functions often modify the :coeffects map within context and, if they do, then they should use the utility functions get-coeffect and assoc-coeffect . :after functions modify and return their context argument. Sometimes they only side effect, in which case, they'll perform the side effect and return context unchanged. :after functions often modify the :effects map within context and, if they do, then they should use the utility functions get-effect and assoc-effect get-coeffect \u00b6 ( get-coeffect context ) ( get-coeffect context key ) ( get-coeffect context key not-found ) A utility function, typically used when writing an interceptor's :before function. When called with one argument, it returns the :coeffects map from within that context . When called with two or three arguments, behaves like clojure.core/get and returns the value mapped to key in the :coeffects map within context , not-found or nil if key is not present. assoc-coeffect \u00b6 ( assoc-coeffect context key value ) A utility function, typically used when writing an interceptor's :before function. Adds or updates a key/value pair in the :coeffects map within context . get-effect \u00b6 ( get-effect context ) ( get-effect context key ) ( get-effect context key not-found ) A utility function, used when writing interceptors, typically within an :after function. When called with one argument, returns the :effects map from the context . When called with two or three arguments, behaves like clojure.core/get and returns the value mapped to key in the effects map, not-found or nil if key is not present. assoc-effect \u00b6 ( assoc-effect context key value ) A utility function, typically used when writing an interceptor's :after function. Adds or updates a key/value pair in the :effects map within context . enqueue \u00b6 ( enqueue context interceptors ) A utility function, used when writing an interceptor's :before function. Adds the given collection of interceptors to those already in context's execution :queue . It returns the updated context . So, it provides a way for one interceptor to add more interceptors to the currently executing interceptor chain. Logging \u00b6 set-loggers! \u00b6 ( set-loggers! new-loggers ) re-frame outputs warnings and errors via the API function console which, by default, delegates to js/console 's default implementation for log , error , warn , debug , group and groupEnd . But, using this function, you can override that behaviour with your own functions. The argument new-loggers should be a map containing a subset of they keys for the standard loggers , namely :log :error :warn :debug :group or :groupEnd . Example Usage: 1 2 3 4 5 6 ( defn my-logger ;; my alternative logging function [ & args ] ( post-it-somewhere ( apply str args ))) ;; now install my alternative loggers ( re-frame.core/set-loggers! { :warn my-logger :log my-logger }) console \u00b6 ( console level & args ) A utility logging function which is used internally within re-frame to produce warnings and other output. It can also be used by libraries which extend re-frame, such as effect handlers. By default, it will output the given args to js/console at the given log level . However, an application using re-frame can redirect console output via set-loggers! . level can be one of :log , :error , :warn , :debug , :group or :groupEnd . Example usage: 1 2 ( console :error \"Sure enough it happened:\" a-var \"and\" another ) ( console :warn \"Possible breach of containment wall at:\" dt ) Miscellaneous \u00b6 make-restore-fn \u00b6 ( make-restore-fn ) This is a utility function, typically used in testing. It checkpoints the current state of re-frame and returns a function which, when later called, will restore re-frame to the checkpointed state. The checkpoint includes app-db , all registered handlers and all subscriptions. purge-event-queue \u00b6 ( purge-event-queue ) Removes all events currently queued for processing add-post-event-callback \u00b6 ( add-post-event-callback f ) ( add-post-event-callback id f ) Registers the given function f to be called after each event is processed. f will be called with two arguments: event : a vector. The event just processed. queue : a PersistentQueue, possibly empty, of events yet to be processed. This facility is useful in advanced cases like: you are implementing a complex bootstrap pipeline you want to create your own handling infrastructure, with perhaps multiple handlers for the one event, etc. Hook in here. libraries providing 'isomorphic javascript' rendering on Nodejs or Nashorn. id is typically a keyword. If it supplied when an f is added, it can be subsequently be used to identify it for removal. See remove-post-event-callback . remove-post-event-callback \u00b6 ( remove-post-event-callback id ) Unregisters a post event callback function, identified by id . Such a function must have been previously registered via add-post-event-callback Deprecated \u00b6 register-handler \u00b6 ( register-handler & args ) Deprecated. Use reg-event-db instead. register-sub \u00b6 ( register-sub & args ) Deprecated. Use reg-sub-raw instead.","title":"re-frame.core"},{"location":"api-re-frame.core/#re-framecore","text":"","title":"re-frame.core"},{"location":"api-re-frame.core/#dispatching-events","text":"","title":"Dispatching Events"},{"location":"api-re-frame.core/#dispatch","text":"( dispatch event ) Queue event for processing (handling). event is a vector and the first element is typically a keyword which identifies the kind of event. The event will be added to a FIFO processing queue, so event handling does not happen immediately. It will happen 'very soon' but not now. And if the queue already contains events, they will be processed first. Usage: 1 ( dispatch [ :order \"pizza\" { :supreme 2 :meatlovers 1 :veg 1 }])","title":"dispatch"},{"location":"api-re-frame.core/#dispatch-sync","text":"( dispatch-sync event ) Synchronously (immediately) process event . It does not queue the event for handling later as dispatch does. event is a vector and the first element is typically a keyword which identifies the kind of event. It is an error to use dispatch-sync within an event handler because you can't immediately process an new event when one is already part way through being processed. Generally, avoid using this function, and instead, use dispatch . Only use it in the narrow set of cases where any delay in processing is a problem: the :on-change handler of a text field where we are expecting fast typing when initialising your app - see 'main' in examples/todomvc/src/core.cljs in a unit test where immediate, synchronous processing is useful Usage: 1 ( dispatch-sync [ :sing :falsetto \"piano accordion\" ])","title":"dispatch-sync"},{"location":"api-re-frame.core/#event-handlers","text":"","title":"Event Handlers"},{"location":"api-re-frame.core/#reg-event-db","text":"( reg-event-db id handler ) ( reg-event-db id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: (db event) -> db interceptors is a collection of interceptors. Will be flattened and nils removed. Example Usage: 1 2 3 4 ( reg-event-db :token ( fn [ db event ] ( assoc db :some-key ( get event 2 ))) ;; return updated db Or perhaps: 1 2 3 4 5 6 7 ( reg-event-db :namespaced/id ;; <-- namespaced keywords are often used [ one two three ] ;; <-- a seq of interceptors ( fn [ db [ _ arg1 arg2 ]] ;; <-- event vector is destructured ( -> db ( dissoc arg1 ) ( update :key + arg2 )))) ;; return updated db","title":"reg-event-db"},{"location":"api-re-frame.core/#reg-event-fx","text":"( reg-event-fx id handler ) ( reg-event-fx id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: (coeffects-map event-vector) -> effects-map interceptors is a collection of interceptors. Will be flattened and nils removed. Example Usage: 1 2 3 4 ( reg-event-fx :event-id ( fn [ cofx event ] { :db ( assoc ( :db cofx ) :some-key ( get event 2 ))})) ;; return a map of effects Or perhaps: 1 2 3 4 5 6 ( reg-event-fx :namespaced/id ;; <-- namespaced keywords are often used [ one two three ] ;; <-- a seq of interceptors ( fn [{ :keys [ db ] :as cofx } [ _ arg1 arg2 ]] ;; destructure both arguments { :db ( assoc db :some-key arg1 ) ;; return a map of effects :fx [[ :dispatch [ :some-event arg2 ]]]}))","title":"reg-event-fx"},{"location":"api-re-frame.core/#reg-event-ctx","text":"( reg-event-ctx id handler ) ( reg-event-ctx id interceptors handler ) Register the given event handler (function) for the given id . Optionally, provide an interceptors chain: id is typically a namespaced keyword (but can be anything) handler is a function: context-map -> context-map You can explore what is provided in context here . Example Usage: 1 2 3 4 5 6 7 8 9 10 11 12 ( reg-event-ctx :event-id ( fn [{ :keys [ coeffects ] :as context }] ( let [ initial { :db ( :db coeffects ) :event ( :event coeffects ) :fx []} result ( -> initial function1 function2 function3 ) effects ( select-keys result [ :db :fx ])] ( assoc context :effects effects ))))","title":"reg-event-ctx"},{"location":"api-re-frame.core/#clear-event","text":"( clear-event ) ( clear-event id ) Unregisters event handlers (presumably registered previously via the use of reg-event-db or reg-event-fx ). When called with no args, it will unregister all currently registered event handlers. When given one arg, assumed to be the id of a previously registered event handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration.","title":"clear-event"},{"location":"api-re-frame.core/#subscriptions","text":"","title":"Subscriptions"},{"location":"api-re-frame.core/#reg-sub","text":"( reg-sub query-id & args ) A call to reg-sub associates a query-id WITH two functions. The two functions provide 'a mechanism' for creating a node in the Signal Graph. When a node of type query-id is needed, the two functions can be used to create it. The three arguments are: query-id - typically a namespaced keyword (later used in subscribe) optionally, an input signals function which returns the input data flows required by this kind of node. a computation function which computes the value (output) of the node (from the input data flows) Later, during app execution, a call to (subscribe [:sub-id 3 :blue]) , will trigger the need for a new :sub-id Signal Graph node (matching the query [:sub-id 3 :blue] ). And, to create that node the two functions associated with :sub-id will be looked up and used. Just to be clear: calling reg-sub does not immediately create a node. It only registers 'a mechanism' (the two functions) by which nodes can be created later, when a node is bought into existence by the use of subscribe in a View Function . reg-sub arguments are: a query-id (typically a namespaced keyword) a function which returns the inputs required by this kind of node (can be supplied in one of three ways) a function which computes the value of this kind of node (can be supplied in one of three ways) The computation function is always the last argument supplied and has three ways to be called. Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data. A function that will accept two parameters, the input-values and query-vector . This is the standard way to provide a computation-function 1 2 3 4 ( reg-sub :query-id ( fn [ input-values query-vector ] ( :foo input-values ))) A single sugary tuple of :-> and a 1-arity computation-function : 1 2 3 ( reg-sub :query-id :-> computation-fn ) This sugary variation allows you to pass a function that will expect only one parameter, namely the input-values and entirely omit the query-vector . A typical computation-function expects two parameters which can cause unfortunate results when attempting to use clojure standard library functions, or other functions, in a functional manner. For example, a significant number of subscriptions exist only to get a value from the input-values . As shown below, this subscription will simply retrieve the value associated with the :foo key in our db: 1 2 3 4 ( reg-sub :query-id ( fn [ db _ ] ;; :<---- trivial boilerplate we might want to skip over ( :foo db ))) This is slightly more boilerplate than we might like to do, as we can use a keyword directly as a function, and we might like to do this: 1 2 3 ( reg-sub :query-id :foo ) ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`. By using :-> our function would not contain the query-vector , and any missing keys would be represented as such: 1 2 3 ( reg-sub :query-id :-> :foo ) This form allows us to ignore the query-vector if our computation-function has no need for it, and be safe from any accidents. Any 1-arity function can be provided, and for more complicated use cases, partial , comp , and anonymous functions can still be used. A single sugary tuple of :=> and a multi-arity computation-function 1 2 3 ( reg-sub :query-id :=> computation-fn ) The query-vector can be broken into two components [query-id & optional-values] , and some subscriptions require the optional-values for extra work within the subscription. To use them in variation #1, we need to destructure our computation-function parameters in order to use them. 1 2 3 4 ( reg-sub :query-id ( fn [ db [ _ foo ]] [ db foo ])) Again we are writing boilerplate just to reach our values, and we might prefer to have direction access through a parameter vector like [input-values optional-values] instead, so we might be able to use a multi-arity function directly as our computation-function . A rewrite of the above sub using this sugary syntax would look like this: 1 2 3 ( reg-sub :query-id :=> vector ) ;; :<---- Could also be `(fn [db foo] [db foo])` The computation function is expected to take two arguments: input-values - the values which flow into this node (how is it wired into the graph?) query-vector - the vector given to subscribe and it returns a computed value (which then becomes the output of the node) When computation function is called, the 2nd query-vector argument will be that vector supplied to the subscribe . So, if the call was (subscribe [:sub-id 3 :blue]) , then the query-vector supplied to the computation function will be [:sub-id 3 :blue] . The argument(s) supplied to reg-sub between query-id and the computation-function can vary in 3 ways, but whatever is there defines the input signals part of the mechanism , specifying what input values \"flow into\" the computation function (as the 1st argument) when it is called. So, reg-sub can be called in one of three ways, because there are three ways to define the input signals part. But note, the 2nd method, in which a signals function is explicitly supplied, is the most canonical and instructive. The other two are really just sugary variations. First variation - no input signal function given: 1 2 3 ( reg-sub :query-id a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) In the absence of an explicit signals function , the node's input signal defaults to app-db and, as a result, the value within app-db (a map) is given as the 1st argument when a-computation-fn is called. Second variation - a signal function is explicitly supplied: 1 2 3 4 ( reg-sub :query-id signal-fn ;; <-- here computation-fn ) This is the most canonical and instructive of the three variations. When a node is created from the template, the signal function will be called and it is expected to return the input signal(s) as either a singleton, if there is only one, or a sequence if there are many, or a map with the signals as the values. The current values of the returned signals will be supplied as the 1st argument to the a-computation-fn when it is called - and subject to what this signal-fn returns, this value will be either a singleton, sequence or map of them (paralleling the structure returned by the signal function ). This example signal function returns a 2-vector of input signals. 1 2 3 ( fn [ query-vec dynamic-vec ] [( subscribe [ :a-sub ]) ( subscribe [ :b-sub ])]) The associated computation function must be written to expect a 2-vector of values for its first argument: 1 2 ( fn [[ a b ] query-vec ] ;; 1st argument is a seq of two values .... ) If, on the other hand, the signal function was simpler and returned a singleton, like this: 1 2 ( fn [ query-vec dynamic-vec ] ( subscribe [ :a-sub ])) ;; <-- returning a singleton then the associated computation function must be written to expect a single value as the 1st argument: 1 2 ( fn [ a query-vec ] ;; 1st argument is a single value ... ) Further Note: variation #1 above, in which an signal-fn was not supplied, like this: 1 2 3 ( reg-sub :query-id a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) is the equivalent of using this 2nd variation and explicitly supplying a signal-fn which returns app-db : 1 2 3 4 ( reg-sub :query-id ( fn [ _ _ ] re-frame/app-db ) ;; <--- explicit signal-fn a-computation-fn ) ;; has signature: (fn [db query-vec] ... ret-value) Third variation - syntax Sugar 1 2 3 4 5 6 ( reg-sub :a-b-sub :<- [ :a-sub ] :<- [ :b-sub ] ( fn [[ a b ] query-vec ] ;; 1st argument is a seq of two values { :a a :b b })) This 3rd variation is just syntactic sugar for the 2nd. Instead of providing an signals-fn you provide one or more pairs of :<- and a subscription vector. If you supply only one pair a singleton will be supplied to the computation function, as if you had supplied a signal-fn returning only a single value: 1 2 3 4 5 ( reg-sub :a-sub :<- [ :a-sub ] ( fn [ a query-vec ] ;; only one pair, so 1st argument is a single value ... )) Syntactic sugar for both the signal-fn and computation-fn can be used together and the direction of arrows shows the flow of data and functions. The example from directly above is reproduced here: 1 2 3 4 5 ( reg-sub :a-b-sub :<- [ :a-sub ] :<- [ :b-sub ] :-> ( partial zipmap [ :a :b ])) For further understanding, read the tutorials, and look at the detailed comments in /examples/todomvc/src/subs.cljs. See also: subscribe","title":"reg-sub"},{"location":"api-re-frame.core/#subscribe","text":"( subscribe query ) ( subscribe query dynv ) Given a query vector, returns a Reagent reaction which will, over time, reactively deliver a stream of values. So, in FRP-ish terms, it returns a Signal . To obtain the current value from the Signal, it must be dereferenced: 1 2 3 ( let [ signal ( subscribe [ :items ]) value ( deref signal )] ;; could be written as @signal ... ) which is typically written tersely as simple: 1 2 ( let [ items @ ( subscribe [ :items ])] ... ) query is a vector of at least one element. The first element is the query-id , typically a namespaced keyword. The rest of the vector's elements are optional, additional values which parameterise the query performed. dynv is an optional 3rd argument, which is a vector of further input signals (atoms, reactions, etc), NOT values. This argument exists for historical reasons and is borderline deprecated these days. Example Usage : 1 2 3 ( subscribe [ :items ]) ( subscribe [ :items \"blue\" :small ]) ( subscribe [ :items { :colour \"blue\" :size :small }]) Note: for any given call to subscribe there must have been a previous call to reg-sub , registering the query handler (functions) associated with query-id . Hint When used in a view function BE SURE to deref the returned value. In fact, to avoid any mistakes, some prefer to define: 1 ( def <sub ( comp deref re-frame.core/subscribe )) And then, within their views, they call (<sub [:items :small]) rather than using subscribe directly. De-duplication Two, or more, concurrent subscriptions for the same query will source reactive updates from the one executing handler. See also: reg-sub","title":"subscribe"},{"location":"api-re-frame.core/#clear-sub","text":"( clear-sub ) ( clear-sub query-id ) Unregisters subscription handlers (presumably registered previously via the use of reg-sub ). When called with no args, it will unregister all currently registered subscription handlers. When given one arg, assumed to be the id of a previously registered subscription handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration. NOTE: Depending on the usecase, it may be necessary to call clear-subscription-cache! afterwards","title":"clear-sub"},{"location":"api-re-frame.core/#reg-sub-raw","text":"( reg-sub-raw query-id handler-fn ) This is a low level, advanced function. You should probably be using reg-sub instead. Some explanation is available in the docs at http://day8.github.io/re-frame/flow-mechanics/","title":"reg-sub-raw"},{"location":"api-re-frame.core/#clear-subscription-cache","text":"( clear-subscription-cache! ) Removes all subscriptions from the cache. This function can be used at development time or test time. Useful when hot reloading namespaces containing subscription handlers. Also call it after a React/render exception, because React components won't have been cleaned up properly. And this, in turn, means the subscriptions within those components won't have been cleaned up correctly. So this forces the issue.","title":"clear-subscription-cache!"},{"location":"api-re-frame.core/#effect-handlers","text":"","title":"Effect Handlers"},{"location":"api-re-frame.core/#reg-fx","text":"( reg-fx id handler ) Register the given effect handler for the given id : id is keyword, often namespaced. handler is a side-effecting function which takes a single argument and whose return value is ignored. To use, first, associate :effect2 with a handler: 1 2 3 4 ( reg-fx :effect2 ( fn [ value ] ... do something side-effect-y )) Then, later, if an event handler were to return this effects map: 1 { :effect2 [ 1 2 ]} then the handler fn we registered previously, using reg-fx , will be called with an argument of [1 2] .","title":"reg-fx"},{"location":"api-re-frame.core/#clear-fx","text":"( clear-fx ) ( clear-fx id ) Unregisters effect handlers (presumably registered previously via the use of reg-fx ). When called with no args, it will unregister all currently registered effect handlers. When given one arg, assumed to be the id of a previously registered effect handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration.","title":"clear-fx"},{"location":"api-re-frame.core/#coeffects","text":"","title":"Coeffects"},{"location":"api-re-frame.core/#reg-cofx","text":"( reg-cofx id handler ) Register the given coeffect handler for the given id , for later use within inject-cofx : id is keyword, often namespaced. handler is a function which takes either one or two arguments, the first of which is always coeffects and which returns an updated coeffects . See also: inject-cofx","title":"reg-cofx"},{"location":"api-re-frame.core/#inject-cofx","text":"( inject-cofx id ) ( inject-cofx id value ) Given an id , and an optional, arbitrary value , returns an interceptor whose :before adds to the :coeffects (map) by calling a pre-registered 'coeffect handler' identified by the id . The previous association of a coeffect handler with an id will have happened via a call to re-frame.core/reg-cofx - generally on program startup. Within the created interceptor, this 'looked up' coeffect handler will be called (within the :before ) with two arguments: the current value of :coeffects optionally, the originally supplied arbitrary value This coeffect handler is expected to modify and return its first, coeffects argument. Example of inject-cofx and reg-cofx working together First - Early in app startup, you register a coeffect handler for :datetime : 1 2 3 4 5 ( re-frame.core/reg-cofx :datetime ;; usage (inject-cofx :datetime) ( fn coeffect-handler [ coeffect ] ( assoc coeffect :now ( js/Date. )))) ;; modify and return first arg Second - Later, add an interceptor to an -fx event handler, using inject-cofx : 1 2 3 4 5 6 7 ( re-frame.core/reg-event-fx ;; when registering an event handler :event-id [ ... ( inject-cofx :datetime ) ... ] ;; <-- create an injecting interceptor ( fn event-handler [ coeffect event ] ;;... in here can access (:now coeffect) to obtain current datetime ... ))) Background coeffects are the input resources required by an event handler to perform its job. The two most obvious ones are db and event . But sometimes an event handler might need other resources. Perhaps an event handler needs a random number or a GUID or the current datetime. Perhaps it needs access to a DataScript database connection. If an event handler directly accesses these resources, it stops being pure and, consequently, it becomes harder to test, etc. So we don't want that. Instead, the interceptor created by this function is a way to 'inject' 'necessary resources' into the :coeffects (map) subsequently given to the event handler at call time. See also reg-cofx","title":"inject-cofx"},{"location":"api-re-frame.core/#clear-cofx","text":"( clear-cofx ) ( clear-cofx id ) Unregisters coeffect handlers (presumably registered previously via the use of reg-cofx ). When called with no args, it will unregister all currently registered coeffect handlers. When given one arg, assumed to be the id of a previously registered coeffect handler, it will unregister the associated handler. Will produce a warning to console if it finds no matching registration.","title":"clear-cofx"},{"location":"api-re-frame.core/#interceptors","text":"","title":"Interceptors"},{"location":"api-re-frame.core/#debug","text":"An interceptor which logs/instruments an event handler's actions to re-frame/console at the :log level. Output includes: the event vector a clojure.data/diff of db, before vs after, which shows the changes caused by the event handler. To understand the output, you should understand: https://clojuredocs.org/clojure.data/diff . You'd typically include this interceptor after (to the right of) any path interceptor. Warning: calling clojure.data/diff on large, complex data structures can be slow. So, you won't want this interceptor present in production code. So, you should condition it out like this: 1 2 3 4 5 ( re-frame.core/reg-event-db :evt-id [( when ^ boolean goog.DEBUG re-frame.core/debug )] ;; <-- conditional ( fn [ db v ] ... )) To make this code fragment work, you'll also have to set goog.DEBUG to false in your production builds. For an example, look in project.clj of /examples/todomvc.","title":"debug"},{"location":"api-re-frame.core/#path","text":"( path & args ) Returns an interceptor which acts somewhat like clojure.core/update-in , in the sense that the event handler is given a specific part of app-db to change, not all of app-db . The interceptor has both a :before and :after functions. The :before replaces the :db key within coeffects with a sub-path within app-db . The :after reverses the process, and it grafts the handler's return value back into db, at the right path. Examples: 1 2 3 4 ( path :some :path ) ( path [ :some :path ]) ( path [ :some :path ] :to :here ) ( path [ :some :path ] [ :to ] :here ) Example Use: 1 2 3 4 5 ( reg-event-db :event-id ( path [ :a :b ]) ;; <-- used here, in interceptor chain ( fn [ b v ] ;; 1st arg is not db. Is the value from path [:a :b] within db ... new-b )) ;; returns a new value for that path (not the entire db) Notes: path may appear more than once in an interceptor chain. Progressive narrowing. if :effects contains no :db effect, can't graft a value back in.","title":"path"},{"location":"api-re-frame.core/#enrich","text":"( enrich f ) Returns an interceptor which will run the given function f in the :after position. f is called with two arguments: db and event , and is expected to return a modified db . Unlike the after interceptor which is only about side effects, enrich expects f to process and alter the given db coeffect in some useful way, contributing to the derived data, flowing vibe. If f returns nil , the db value passed to f will be returned instead.","title":"enrich"},{"location":"api-re-frame.core/#unwrap","text":"New in v1.2.0 An interceptor which decreases the amount of destructuring necessary in an event handler where the event is structured as a 2-vector of [event-id payload-map]. It promotes the payload-map part to be the event ultimately given to the event handler. Should you want the full original event, it can be found in coeffects under the key :original-event . If a dispatch looked like this: 1 ( dispatch [ :event-id { :x 1 :y 2 :z 3 }]) Your event handlers can look like this: 1 2 3 4 5 ( reg-event-fx :event-id [ ... unwrap ... ] ;; <-- added to the interceptors ( fn [{ :keys [ db ]} { :keys [ x y z ]}] ;; <-- instead of [_ {:keys [x y z]}] ... )","title":"unwrap"},{"location":"api-re-frame.core/#trim-v","text":"An interceptor which removes the first element of the event vector, before it is supplied to the event handler, allowing you to write more aesthetically pleasing event handlers. No leading underscore on the event-v! Should you want the full original event, it can be found in coeffects under the key :original-event . Your event handlers will look like this: 1 2 3 4 5 ( reg-event-db :event-id [ ... trim-v ... ] ;; <-- added to the interceptors ( fn [ db [ x y z ]] ;; <-- instead of [_ x y z] ... )","title":"trim-v"},{"location":"api-re-frame.core/#after","text":"( after f ) Returns an interceptor which runs the given function f in the :after position, presumably for side effects. f is called with two arguments: the :effects value for :db (or the :coeffect value of :db if no :db effect is returned) and the event. Its return value is ignored, so f can only side-effect. An example of use can be seen in the re-frame github repo in /examples/todomvc/events.cljs : f runs schema validation (reporting any errors found). f writes to localstorage.","title":"after"},{"location":"api-re-frame.core/#on-changes","text":"( on-changes f out-path & in-paths ) Returns an interceptor which will observe N paths within db , and if any of them test not identical? to their previous value (as a result of a event handler being run), then it will run f to compute a new value, which is then assoc-ed into the given out-path within db . Example Usage: 1 2 3 4 5 6 7 8 9 10 11 12 ( defn my-f [ a-val b-val ] ... some computation on a and b in here ) ;; use it ( def my-interceptor ( on-changes my-f [ :c ] [ :a ] [ :b ])) ( reg-event-db :event-id [ ... my-interceptor ... ] ;; <-- ultimately used here ( fn [ db v ] ... )) If you put this interceptor on handlers which might change paths :a or :b , it will: call f each time the value at path [:a] or [:b] changes call f with the values extracted from [:a] [:b] assoc the return value from f into the path [:c]","title":"on-changes"},{"location":"api-re-frame.core/#global-interceptors","text":"","title":"Global Interceptors"},{"location":"api-re-frame.core/#reg-global-interceptor","text":"( reg-global-interceptor interceptor ) Registers the given interceptor as a global interceptor. Global interceptors are included in the processing chain of every event. When you register an event handler, you have the option of supplying an interceptor chain. Any global interceptors you register are effectively prepending to this chain. Global interceptors are run in the order that they are registered.","title":"reg-global-interceptor"},{"location":"api-re-frame.core/#clear-global-interceptor","text":"( clear-global-interceptor ) ( clear-global-interceptor id ) Unregisters global interceptors (presumably registered previously via the use of reg-global-interceptor ). When called with no args, it will unregister all currently registered global interceptors. When given one arg, assumed to be the id of a previously registered global interceptors, it will unregister the associated interceptor. Will produce a warning to console if it finds no matching registration.","title":"clear-global-interceptor"},{"location":"api-re-frame.core/#writing-interceptors","text":"","title":"Writing Interceptors"},{"location":"api-re-frame.core/#-interceptor","text":"( ->interceptor & { :as m , :keys [ id before after ]}) A utility function for creating interceptors. Accepts three optional, named arguments: :id - an id for the interceptor (decorative only) :before - the interceptor's before function :after - the interceptor's after function Example use: 1 2 3 4 5 6 7 ( def my-interceptor ( ->interceptor :id :my-interceptor :before ( fn [ context ] ... modifies and returns ` context ` ) :after ( fn [ context ] ... modifies and returns ` context ` ))) Notes: :before functions modify and return their context argument. Sometimes they only side effect, in which case, they'll perform the side effect and return context unchanged. :before functions often modify the :coeffects map within context and, if they do, then they should use the utility functions get-coeffect and assoc-coeffect . :after functions modify and return their context argument. Sometimes they only side effect, in which case, they'll perform the side effect and return context unchanged. :after functions often modify the :effects map within context and, if they do, then they should use the utility functions get-effect and assoc-effect","title":"-&gt;interceptor"},{"location":"api-re-frame.core/#get-coeffect","text":"( get-coeffect context ) ( get-coeffect context key ) ( get-coeffect context key not-found ) A utility function, typically used when writing an interceptor's :before function. When called with one argument, it returns the :coeffects map from within that context . When called with two or three arguments, behaves like clojure.core/get and returns the value mapped to key in the :coeffects map within context , not-found or nil if key is not present.","title":"get-coeffect"},{"location":"api-re-frame.core/#assoc-coeffect","text":"( assoc-coeffect context key value ) A utility function, typically used when writing an interceptor's :before function. Adds or updates a key/value pair in the :coeffects map within context .","title":"assoc-coeffect"},{"location":"api-re-frame.core/#get-effect","text":"( get-effect context ) ( get-effect context key ) ( get-effect context key not-found ) A utility function, used when writing interceptors, typically within an :after function. When called with one argument, returns the :effects map from the context . When called with two or three arguments, behaves like clojure.core/get and returns the value mapped to key in the effects map, not-found or nil if key is not present.","title":"get-effect"},{"location":"api-re-frame.core/#assoc-effect","text":"( assoc-effect context key value ) A utility function, typically used when writing an interceptor's :after function. Adds or updates a key/value pair in the :effects map within context .","title":"assoc-effect"},{"location":"api-re-frame.core/#enqueue","text":"( enqueue context interceptors ) A utility function, used when writing an interceptor's :before function. Adds the given collection of interceptors to those already in context's execution :queue . It returns the updated context . So, it provides a way for one interceptor to add more interceptors to the currently executing interceptor chain.","title":"enqueue"},{"location":"api-re-frame.core/#logging","text":"","title":"Logging"},{"location":"api-re-frame.core/#set-loggers","text":"( set-loggers! new-loggers ) re-frame outputs warnings and errors via the API function console which, by default, delegates to js/console 's default implementation for log , error , warn , debug , group and groupEnd . But, using this function, you can override that behaviour with your own functions. The argument new-loggers should be a map containing a subset of they keys for the standard loggers , namely :log :error :warn :debug :group or :groupEnd . Example Usage: 1 2 3 4 5 6 ( defn my-logger ;; my alternative logging function [ & args ] ( post-it-somewhere ( apply str args ))) ;; now install my alternative loggers ( re-frame.core/set-loggers! { :warn my-logger :log my-logger })","title":"set-loggers!"},{"location":"api-re-frame.core/#console","text":"( console level & args ) A utility logging function which is used internally within re-frame to produce warnings and other output. It can also be used by libraries which extend re-frame, such as effect handlers. By default, it will output the given args to js/console at the given log level . However, an application using re-frame can redirect console output via set-loggers! . level can be one of :log , :error , :warn , :debug , :group or :groupEnd . Example usage: 1 2 ( console :error \"Sure enough it happened:\" a-var \"and\" another ) ( console :warn \"Possible breach of containment wall at:\" dt )","title":"console"},{"location":"api-re-frame.core/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"api-re-frame.core/#make-restore-fn","text":"( make-restore-fn ) This is a utility function, typically used in testing. It checkpoints the current state of re-frame and returns a function which, when later called, will restore re-frame to the checkpointed state. The checkpoint includes app-db , all registered handlers and all subscriptions.","title":"make-restore-fn"},{"location":"api-re-frame.core/#purge-event-queue","text":"( purge-event-queue ) Removes all events currently queued for processing","title":"purge-event-queue"},{"location":"api-re-frame.core/#add-post-event-callback","text":"( add-post-event-callback f ) ( add-post-event-callback id f ) Registers the given function f to be called after each event is processed. f will be called with two arguments: event : a vector. The event just processed. queue : a PersistentQueue, possibly empty, of events yet to be processed. This facility is useful in advanced cases like: you are implementing a complex bootstrap pipeline you want to create your own handling infrastructure, with perhaps multiple handlers for the one event, etc. Hook in here. libraries providing 'isomorphic javascript' rendering on Nodejs or Nashorn. id is typically a keyword. If it supplied when an f is added, it can be subsequently be used to identify it for removal. See remove-post-event-callback .","title":"add-post-event-callback"},{"location":"api-re-frame.core/#remove-post-event-callback","text":"( remove-post-event-callback id ) Unregisters a post event callback function, identified by id . Such a function must have been previously registered via add-post-event-callback","title":"remove-post-event-callback"},{"location":"api-re-frame.core/#deprecated","text":"","title":"Deprecated"},{"location":"api-re-frame.core/#register-handler","text":"( register-handler & args ) Deprecated. Use reg-event-db instead.","title":"register-handler"},{"location":"api-re-frame.core/#register-sub","text":"( register-sub & args ) Deprecated. Use reg-sub-raw instead.","title":"register-sub"},{"location":"application-state/","text":"Application State \u00b6 Well-formed Data at rest is as close to perfection in programming as it gets. All the crap that had to happen to put it there however... \u2014 Fogus (@fogus) April 11, 2014 The Big Ratom \u00b6 re-frame puts all application state into one place, which is called app-db . Now, this advice is not the slightest bit controversial for 'real' databases, right? You'd happily put all your well-formed data into PostgreSQL. But within a running application (in memory), there can be hesitation. If you have a background in OO, this data-in-one-place business is a really, really hard one to swallow. You've spent your life breaking systems into pieces, organised around behaviour and trying to hide state. I still wake up in a sweat some nights thinking about all that Clojure data lying around exposed and passive. But, as Fogus reminds us above, data at rest is quite perfect. In re-frame, app-db is one of these: ( def app-db ( reagent/atom {})) ;; a Reagent atom, containing a map Although it is a Reagent atom (hereafter ratom ), I'd encourage you to think of it as an in-memory database. It will contain structured data. You will need to query that data. You will perform CRUD and other transformations on it. You'll often want to transact on this database atomically, etc. So \"in-memory database\" seems a more useful paradigm than a map in an atom . Further Notes: app-state would probably be a more accurate name, but I choose app-db instead because I wanted to convey the in-memory database notion as strongly as possible. In the documentation and code, I make a distinction between app-db (the ratom ) and db which is the value (A map) currently stored inside this ratom . Be aware of that naming as you read code. re-frame creates and manages an app-db for you, so you don't need to declare one yourself (see the first FAQ if you want to inspect the value it holds). app-db doesn't actually have to be a ratom containing a map. It could, for example, be a datascript database . In fact, any database which can signal you when it changes would do. We'd love! to be using datascript database - so damn cool - but we had too much data in our apps. If you were to use it, you'd have to tweak re-frame a bit and use re-posh . The Benefits \u00b6 There are benefits to having data in the one place: Here's the big one: because there is a single source of truth, we write no code to synchronise state between many different stateful components. I cannot stress enough how significant this is. You end up writing less code and an entire class of bugs is eliminated. (This mindset is very different to OO which involves distributing state across objects, and then ensuring that state is synchronised, all the while trying to hide it, which is, when you think about it, quite crazy ... and I did it for years). Because all app state is coalesced into one atom, it can be updated with a single reset! , which acts like a transactional commit. There is an instant in which the app goes from one state to the next, never a series of incremental steps which can leave the app in a temporarily inconsistent, intermediate state. Again, this simplicity causes a certain class of bugs or design problems to evaporate. The data in app-db can be given a strong schema so that, at any moment, we can validate all the data in the application. All of it! We do this check after every single \"event handler\" runs (event handlers compute new state). And this enables us to catch errors early (and accurately). It increases confidence in the way that Types can increase confidence, only a good schema can potentially provide more leverage than types . Undo/Redo becomes straight forward to implement . It is easy to snapshot and restore one central value. Immutable data structures have a feature called structural sharing which means it doesn't cost much RAM to keep the last, say, 200 snapshots. All very efficient. For certain categories of applications (eg: drawing applications), this feature is borderline magic. Instead of undo/redo being hard, disruptive and error-prone, it becomes trivial. But, many web applications are not self-contained data-wise and, instead, are dominated by data sourced from an authoritative, remote database. For these applications, re-frame's app-db is mostly a local caching point, and being able to undo/redo its state is meaningless because the authoritative source of data is elsewhere. The ability to genuinely model control via FSMs (discussed later). The ability to do time travel debugging, even in a production setting. More soon. Create A Leveragable Schema \u00b6 You will want to provide a spec for all this data-in-the-one-place. You'll want the leverage it brings. Of course, that means you'll have to learn spec and there's some overhead in that, so maybe, just maybe, in your initial experiments, you can get away without one. But not for long. Promise me you'll write a spec . Promise me. Okay, good. Specs are potentially more leveragable than types. This is a big interesting idea which is not yet sufficiently mainstream. Watch how . Also, watch Rich Hickey roar (bummer, poor audio)","title":"State"},{"location":"application-state/#application-state","text":"Well-formed Data at rest is as close to perfection in programming as it gets. All the crap that had to happen to put it there however... \u2014 Fogus (@fogus) April 11, 2014","title":"Application State"},{"location":"application-state/#the-big-ratom","text":"re-frame puts all application state into one place, which is called app-db . Now, this advice is not the slightest bit controversial for 'real' databases, right? You'd happily put all your well-formed data into PostgreSQL. But within a running application (in memory), there can be hesitation. If you have a background in OO, this data-in-one-place business is a really, really hard one to swallow. You've spent your life breaking systems into pieces, organised around behaviour and trying to hide state. I still wake up in a sweat some nights thinking about all that Clojure data lying around exposed and passive. But, as Fogus reminds us above, data at rest is quite perfect. In re-frame, app-db is one of these: ( def app-db ( reagent/atom {})) ;; a Reagent atom, containing a map Although it is a Reagent atom (hereafter ratom ), I'd encourage you to think of it as an in-memory database. It will contain structured data. You will need to query that data. You will perform CRUD and other transformations on it. You'll often want to transact on this database atomically, etc. So \"in-memory database\" seems a more useful paradigm than a map in an atom . Further Notes: app-state would probably be a more accurate name, but I choose app-db instead because I wanted to convey the in-memory database notion as strongly as possible. In the documentation and code, I make a distinction between app-db (the ratom ) and db which is the value (A map) currently stored inside this ratom . Be aware of that naming as you read code. re-frame creates and manages an app-db for you, so you don't need to declare one yourself (see the first FAQ if you want to inspect the value it holds). app-db doesn't actually have to be a ratom containing a map. It could, for example, be a datascript database . In fact, any database which can signal you when it changes would do. We'd love! to be using datascript database - so damn cool - but we had too much data in our apps. If you were to use it, you'd have to tweak re-frame a bit and use re-posh .","title":"The Big Ratom"},{"location":"application-state/#the-benefits","text":"There are benefits to having data in the one place: Here's the big one: because there is a single source of truth, we write no code to synchronise state between many different stateful components. I cannot stress enough how significant this is. You end up writing less code and an entire class of bugs is eliminated. (This mindset is very different to OO which involves distributing state across objects, and then ensuring that state is synchronised, all the while trying to hide it, which is, when you think about it, quite crazy ... and I did it for years). Because all app state is coalesced into one atom, it can be updated with a single reset! , which acts like a transactional commit. There is an instant in which the app goes from one state to the next, never a series of incremental steps which can leave the app in a temporarily inconsistent, intermediate state. Again, this simplicity causes a certain class of bugs or design problems to evaporate. The data in app-db can be given a strong schema so that, at any moment, we can validate all the data in the application. All of it! We do this check after every single \"event handler\" runs (event handlers compute new state). And this enables us to catch errors early (and accurately). It increases confidence in the way that Types can increase confidence, only a good schema can potentially provide more leverage than types . Undo/Redo becomes straight forward to implement . It is easy to snapshot and restore one central value. Immutable data structures have a feature called structural sharing which means it doesn't cost much RAM to keep the last, say, 200 snapshots. All very efficient. For certain categories of applications (eg: drawing applications), this feature is borderline magic. Instead of undo/redo being hard, disruptive and error-prone, it becomes trivial. But, many web applications are not self-contained data-wise and, instead, are dominated by data sourced from an authoritative, remote database. For these applications, re-frame's app-db is mostly a local caching point, and being able to undo/redo its state is meaningless because the authoritative source of data is elsewhere. The ability to genuinely model control via FSMs (discussed later). The ability to do time travel debugging, even in a production setting. More soon.","title":"The Benefits"},{"location":"application-state/#create-a-leveragable-schema","text":"You will want to provide a spec for all this data-in-the-one-place. You'll want the leverage it brings. Of course, that means you'll have to learn spec and there's some overhead in that, so maybe, just maybe, in your initial experiments, you can get away without one. But not for long. Promise me you'll write a spec . Promise me. Okay, good. Specs are potentially more leveragable than types. This is a big interesting idea which is not yet sufficiently mainstream. Watch how . Also, watch Rich Hickey roar (bummer, poor audio)","title":"Create A Leveragable Schema"},{"location":"breaking-it/","text":"Document is WIP To understand how something works, figure out how to break it -- N.N.Talib All libraries/frameworks should come with a \"what breaks this\" section - this is that document for re-frame. The essence of science is earnestness of inquiry. Eddington defined science as \u201cthe earnest endeavour to put into order the facts of experience\u201d So what are we doing here? Marketing (Narative warefare) for the re-frame framework or computer science. Pros \u00b6 is very productive has simple dynamics (#1 importance) you write your app in less lines of code (#2 importance) sits in a sea of tranquility, compared to the technical churn elsewhere best in breed hot reloading process, because of tooling and pervasive immutable data it leverages pure functions immutable data declarative style, useing data-based DSLs a shockingly effective and beautiful language (50 years of refinement by the finest minds in computer science) React's entire ecosystem of components - although Hooks is starting to bimodalate (?word) the ecosystem. full interop with js reactive data flows a data oriented design excellent tooling shadow-clj and figwheel clj-devtools re-frame-10x Google's \"Closure Compiler\" (tree shaking) Also benefits from: acceptable performance acceptable bundle size is mature is easily learned (sometimes Clojure itself can be an initial hurdle, if you don't know functional programming) an enthusiastic community, video training and 3rd party libraries re-frame-10x is only half finished. It is entirely useful and functional, but I'd love to take it the rest of the way. is functional and has a data oriented design (has unique features) It is Boringly simple Cons \u00b6 As the framework author, I should be a relentless chearleader, right?. The gyrations of my pompoms should be tecktonic. But one of the best ways for me to help you, an evaluator of this framework, is explain where and how it doesn't work well? That's this section. Every design represents a point in design space, with pros and cons. The tradeoffs are the intersting bit. So I'll do that now. I will not try to contrast re-frame with your other framework options. I wish I could provide you with that, but to do that well, i would need deep knowledge of all the frameworks, and I don't know of anyone who really has that. Certainly not me. I try to keep an eye on them, but by \"deep knowledge\" I mean you need to have used it in anger, professionally for a couple of years. Anything less and the comparisions tend to be too shallow and misleading - which means: not unsful - particularly when they are written by someone with a Rather than telling you what's awesome, I should take Talib's advice and tell you what breaks re-frame. What doesn't work. In that way you will know it better than any amount of \"its so awesome\". What breaks re-frame: too many events - maybe a telemetary app? if you want to use components which use React hooks it might not be a good fit if your app is a very thin venier over a remote database, and forms dominate the process. re-frame can do forms, but it is probably better when the UI get's more complex. I'm not sure the testing story is as strong as it could be. Mind you, it seems good enough that I haven't been tempted to improve it. A lot of chat with a server HTTP results in too many (we plan to fix this, but right now XXXX) Server side rendering. Is possible if you use node, but other platforms, maybe not. We'd like a better FSM story framework vs library. dynamically typed A Framework should be invisible and boring. So, where you notice it ... that's an example of it being broken. Connection with server?? XXX I will say that I don't think React is on the right track with hooks, Suspense. React was at its best when it tried to be the V in MVC .","title":"Breaking it"},{"location":"breaking-it/#pros","text":"is very productive has simple dynamics (#1 importance) you write your app in less lines of code (#2 importance) sits in a sea of tranquility, compared to the technical churn elsewhere best in breed hot reloading process, because of tooling and pervasive immutable data it leverages pure functions immutable data declarative style, useing data-based DSLs a shockingly effective and beautiful language (50 years of refinement by the finest minds in computer science) React's entire ecosystem of components - although Hooks is starting to bimodalate (?word) the ecosystem. full interop with js reactive data flows a data oriented design excellent tooling shadow-clj and figwheel clj-devtools re-frame-10x Google's \"Closure Compiler\" (tree shaking) Also benefits from: acceptable performance acceptable bundle size is mature is easily learned (sometimes Clojure itself can be an initial hurdle, if you don't know functional programming) an enthusiastic community, video training and 3rd party libraries re-frame-10x is only half finished. It is entirely useful and functional, but I'd love to take it the rest of the way. is functional and has a data oriented design (has unique features) It is Boringly simple","title":"Pros"},{"location":"breaking-it/#cons","text":"As the framework author, I should be a relentless chearleader, right?. The gyrations of my pompoms should be tecktonic. But one of the best ways for me to help you, an evaluator of this framework, is explain where and how it doesn't work well? That's this section. Every design represents a point in design space, with pros and cons. The tradeoffs are the intersting bit. So I'll do that now. I will not try to contrast re-frame with your other framework options. I wish I could provide you with that, but to do that well, i would need deep knowledge of all the frameworks, and I don't know of anyone who really has that. Certainly not me. I try to keep an eye on them, but by \"deep knowledge\" I mean you need to have used it in anger, professionally for a couple of years. Anything less and the comparisions tend to be too shallow and misleading - which means: not unsful - particularly when they are written by someone with a Rather than telling you what's awesome, I should take Talib's advice and tell you what breaks re-frame. What doesn't work. In that way you will know it better than any amount of \"its so awesome\". What breaks re-frame: too many events - maybe a telemetary app? if you want to use components which use React hooks it might not be a good fit if your app is a very thin venier over a remote database, and forms dominate the process. re-frame can do forms, but it is probably better when the UI get's more complex. I'm not sure the testing story is as strong as it could be. Mind you, it seems good enough that I haven't been tempted to improve it. A lot of chat with a server HTTP results in too many (we plan to fix this, but right now XXXX) Server side rendering. Is possible if you use node, but other platforms, maybe not. We'd like a better FSM story framework vs library. dynamically typed A Framework should be invisible and boring. So, where you notice it ... that's an example of it being broken. Connection with server?? XXX I will say that I don't think React is on the right track with hooks, Suspense. React was at its best when it tried to be the V in MVC .","title":"Cons"},{"location":"browser-dynamics/","text":"The re-frame loop plays out, over time, within the browser. And browsers are bursty, noisy things. Here's an infographic describing the ideal process.","title":"Browser Dynamics"},{"location":"clojurescript/","text":"This document is currently in alpha test. If you review it, could you please let me know: How long it takes you to read (my current guess is 40 mins) What worked well for you. What puzzled you. What jarred. What is overexplained. What is underexplained. etc. It is not yet completely polished, but it is getting close. It does not yet have an integrated inline/on-page REPL yet. But it will soon. Please open an issue with your thoughts at the re-freame repo or via twitter here Many Thanks! Are you new to ClojureScript? This page will teach you to read Clojure in 40 minutes. The goal is to teach you just enough ClojureScript to read Reagent and re-frame code. The next step is learning to write ClojureScript but that's a larger skill, which will require more than 40 mins. Why? \u00b6 Clojure is a modern LISP. Alan Kay once described LISP as \"Maxwell's equations of software\". Paul Graham believes LISP was a competitive advantage for his startup. Eric Raymmond said that learning LISP was profoundly enligthening and that knowing it would make you a better programmer for the rest of your days. In the 70s, 80s and 90s, the LISP community went through a washing machine phase of evolutionary churn. Innovation flourished, experiments happened, prototype ideas were tested and knowledge foliated. Later, in about 2010, Rich Hickey took that knowledge and created Clojure, introducing key innovations. He did this well away from academia (LISP's traditional home) because he wanted to create a pragmatic language for commercial developers. So, Clojure has had a long gestation period, and it comes with a hard practical edge. As the owner of a company that develops software products, I believe ClojureScript gives us a competitive edge. As an experienced programmer, I feel like it has provided me with excellent, nourishing brain food. It is a stable, productive place. If you'll allow me some momentary negativity: in contrast, I'm scared of the javascript landscape, which still appears to be a churning washing machine full of steep learning curves, premature obsolescence and sharp edges, which teach me little of substance and certainly won't make me productive. Enough of a sermon? Yes. Okay, 40 mins ... A note on names: Clojure runs on the JVM. ClojureScript runs in the browser. They are essentially the same language but our focus here is on ClojureScript . I have good news: you are going to be surprised and delighted at the simplicity of the syntax. Simple Data Literals \u00b6 Type Example Comment character \\a The letter a number 1 number 3.14 string \"hello\" nil nil aka null, None Collection Data Literals \u00b6 Lists use () , vectors use [] , hashmaps use {} and sets use # {} , Examples: Collection Example Comment list ( 1 2 3 ) Empty list is () No commas necessary. But, if present, treated as whitespace. list ( 1 2 \"yes\" ) Can be heterogeneous. vector [ 1 2 3 ] Again, no commas necessary. Empty vector is [] vector [ 1 \"hello\" \\x nil ] Can be heterogeneous. hashmap { 1 \"Hello\" } A dictionary, or hashmap. Each pair is a key and a value . One pair in this example. 1 is key, \"hello\" is the value hashmap { 1 \"Hello\" 2 nil } No delimiter necessary between pairs. Two key/value pairs in this example. hashmap { 1 \"Hello\" \\b 27 \"pi\" 3.14 } Can be heterogeneous. Still no commas between pairs. set # { 1 \"Hello\" \\a } Can be heterogeneous. Still no commas between pairs. Collections can nest: Example Comment vector [ 1 [ 2 2 ] 3 ] an element can be another vector vector [ 1 { 4 5 } 3 ] an element can be a hashmap hashmap { 1 [ 4 5 ] 2 [ \\a \\b ]} a value in a hashmap can be a vector hashmap { 1 { 4 5 } 2 { \\a \\b }} a value in a hashmap can be a hashmap hashmap {{ 4 5 } 1 [ 1 2 ] 2 } the keys in a hashmap can be a hashmap or vector Hashmaps are often just called maps. Symbols \u00b6 A symbol is a name that is bound to a value . Here, we mean \"bound\" in the sense of \"is tied to\" or \"is associated with\" or \"refers to\". Type Example Comment symbol inc The symbol inc is bound to one of Clojure's builtin functions. This function will return its argument incremented symbol + The symbol + is also bound to a builtin function. It adds its arguments. note: + is not an operator in ClojureScript, it is a function symbol yours Soon you'll see how you can create a symbol and bind it to a value. But that is a few minutes away down the page, so until then, you'll just have to take it on trust that this is possible/easy. That's It For Syntax \u00b6 We've now covered most of Clojure's syntax. But, how can that be? Haven't we only looked at data literals? Well, yes, but Clojure is Homoiconic which means \"code is data\" - you write Clojure code using Clojure's data literals and we've covered data literals. Evaluation \u00b6 You are going to be surprised and delighted with the simplicity of \"evaluation\". 1st Evaluation Rule: all data litterals other than lists and symbols evaluate to themselves. Value Evaluates To Comment \\a \\a Same 1 1 Same [ 1 1 ] [ 1 1 ] Same { 1 1 2 2 } { 1 1 2 2 } Yep, same Below, you can start evaluating live on this page. Click the Eval button, or change the expression, and it will be evaluated. The result of the evaluation will be shown in the box below the editor. Try these experiments: {:a 1 :a 4} (fn duplicate-keys [{:keys [return-str]}] (when (re-find #\"duplicate key\" return-str) [:span \"Oops! A map can only have 1 of a given key. Try changing \" [:code \":a 4\"] \" to \" [:code \":b 4\"] \".\"])) [:apple :orange :banana (fn eof-vector [{:keys [return-str]}] (when (re-find #\"EOF\" return-str) [:span \"Forgot to close the form? Try adding \" [:code \"]\"] \" to the end.\"])) XXX other basic examples? So, let's now talk about the two exceptions lists and symbols ... Evaluating Symbols \u00b6 2nd Evaluation Rule: Symbols don't evaluate to themselves. Instead, they evaluate to the value to which they are \"bound\". Example symbol evaluations: Expression Evaluates To Comments foo 4 Assuming the symbol foo is bound to the value 4 bar [ 1 2 3 ] Assuming the symbol bar is bound to the value [ 1 2 3 ] [ 1 foo ] [ 1 4 ] Each element is evaluated, and foo evaluated to 4 [ foo bar ] [ 4 [ 1 2 3 ]] Assuming foo evaluates to 4 , bar evaluates to [ 1 2 3 ] Symbols are often bound to functions For the moment, you'll have to take my word on this: the symbol inc is bound to a function in Clojure's standard library. As a result, when you evaulate inc , you get the function!! Because that's what inc is bound to. There's also another symbol, count , which is bound to different function in the standard library. And, finally - this one will be a surprise - the symbol + is bound to a function. Wait. Isn't + an operator? No. Clojure doesn't have operators. Instead, + is a symbol, and it is bound to a function - one which adds. Anyway, more soon. Try these experiments: > inc (fn function-object [{:keys [status]}] (when (#{:success} status) [:span \"Functions are technically objects, and cljs represents them by printing \" [:code \"object[qualified$name]\"]])) [inc dec +] (fn function-vec-item [{:keys [status]}] (when (#{:success} status) \"This is simply three items in a vector. Just because they're functions does not mean you're calling them.\")) {inc 5} (fn function-vec-item [{:keys [status]}] (when (#{:success} status) \"Nearly anything can be a map key.\")) Evaluating Lists \u00b6 3rd Evaluation Rule: a list evaluates to a function call. Okay, now we're cooking with gas! Clojure is a functional language so, as you can imagine, function calls are a big deal, so this section is important. Here's an example list ( f arg1 arg2 arg3 ) . Because it is surrounded by parens, ( ) , it is a list, and we can see it has four elements. Such a list is evaluated in two steps : first, each element in the list is evaluated (all four of them in this example) then, a function call occurs where: the evaluation of the 1st element will be the function called the evaluation of the other elements (3 in the case above) will be the actual arguments in this function call The list evaluates to the return value of this function call. So, if this example function call returned the string \"maybe Satoshi\" , then the list ( f arg1 arg2 arg3 ) would evaluate to \"maybe Satoshi\" . More on symbols bound to functions In Clojure code, the 1st element of a list is often a symbol. So, let's talk more about that. Here's an example: ( inc 3 ) . That's a two element list, and the first element is the symbol inc . The 2nd element is the value 3 When evaluating this list, in step 1 all elements of the list are evaluated and, if the first element of the list is a symbol, like inc , it will evaluate to what it is bound to, which is a function. And it is that function which is called in step 2. So inc is a symbol, not a function. But it is bound to a function. A subtle but important distinction. If, instead, inc was bound to the value 27 we couldn't use it in the first position of a list, because it is bound to a number, not a function. We'd get an error at call time. Example list evaluations, involving symbols: List Evaluates To Comments ( inc 3 ) 4 Step 1: evaluate each element of the list (there are two): \u2022 the symbol inc is bound to a builtin function \u2022 and 3 evaluates to 3 Step 2: call the function with 3 as the argument. The return value 4 [ 5 ( inc 6 )] [ 5 7 ] Evaluate each element of the vector. 5 evaluates to 5 . Then, evaluating that 2nd element is a function call. ( + 1 2 ) 3 The symbol + is bound to a builin function. And that function adds together its arguments ( + 1 2 3 ) 6 Surprise! Turns out this function can handle a variable number of arguments. [ 1 ( + 1 2 3 )] [ 1 6 ] No operators We now know that + is a symbol bound to a builtin function, not an operator. It is the same with - , / , > , = , etc. Because these are just names, you can also have not= And because there are no operators, there's no operator precedence to discuss. Simple syntax, right? Let's start evaluating, live. Type into the following editor. Click Ctrl-click to evaluate. Possible experiments: is (+ 1) an error? How about (+) or (*) ? try (odd? 5) try (count [1 2 3]) (fn arithmetic-arity [{:keys [status source-form]}] (when (and (#{:success} status) (#{'(+ 1) '(+) '(*)} source-form)) \"Consider this either very intuitive, or very unintuitive.\")) Forms \u00b6 A list like this ( + 1 2 ) is known as a form . Forms can nest like this: ( + 1 ( inc 10 )) . So, how do nested forms evaluate? Well, in your mind's eye, see this nested example as ( f arg1 arg2 ) where: f is + arg1 is 1 arg2 is ( inc 10 ) <-- a nested form To evaluate this form, you'll remember from the last section that it is a two step process. First, evaluate each of the three elements. So the execution trace will be: + will evaluate to the builtin function bound to that symbol 1 evaluates to 1 ( inc 10 ) is a list and we evaluate it as a function call: (1) evaluate the elements (2) perform the function call with all three elements evaluated, the function (bound to + ) is called with the two actual arguments of 1 and 11 the return value from the function call is 12 which means the overall evaluation of this nested form is 12 More: Nested Forms Evaluates To Comments ( + 3 ( count [ 1 2 ])) 5 Evaluation trace: \u2022 + is evaluated to a function \u2022 3 is evaluated to 3 \u2022 ( count [ 1 2 ]) is evaluated as a function call which returns 2 \u2022 call function with args 3 and 2 , which returns 5 ( = 2 ( inc 1 )) true = is a symbol which is bound to a builtin function. You can guess what it does. ( = ( inc 1 ) ( dec 3 )) true dec is bound to a bultin, and it decrements its arg by one Evaluate these experiments yourself (any surprises?): (inc (dec 1)) (odd? (inc (dec 1))) (= (inc (dec 1)) 1) Keywords \u00b6 Keywords are like symbols, except they evaluate to themselves and not to a bound value. This means they evaluate like most other data literals. Keywords are invaluable as identities and they are used widely, particularly as keys in hashmaps. A keyword is a name that starts with a colon. Let's evaluate some: Value Evaluates To Comments :foo :foo It evaluates to itself. :bar :bar It evaluates to itself ( = :bar :bar ) true Different instances will evaluate to equal. Like numbers do, and strings. ( = :bar :foo ) false [ 1 2 :bar ] [ 1 2 :bar ] Yep, evaluates to itself. { 1 :bar } { 1 :bar } And again, but as a hashmap value Keywords can have a namespace . Value Evaluates To Comments :panel1/edit :panel1/edit Starts with a colon Optionally, contains a / Before the / is the namespace After the / is the name Evaluates to itself :panel2/edit :panel2/edit Different namespace to above, same name :panel.commands/edit :panel.commands/edit namespaces can be dotted ( name :a/b ) \"b\" name is bound to a builtin function ( namespace :a/b ) \"a\" namespace is bound to a builtin function ( keyword \"a/b\" ) :a/b keyword is bound to a builtin function ( keyword \"a\" \"b\" ) :a/b keyword is bound to a builtin function To give you a taste of where this can go, here they are used as the keys in a hashmap: { :user/id 1 :user/name \"Barry\" :user/age 28 :user/company \"SpaceX\" :role/name \"Rocket Sharpener\" } Evaluate these experiments yourself (any surprises?): (namespace :a) (keyword (name :a)) (keyword (namespace :a/b) (name :a/b)) Kebab Case Please \u00b6 We don't use _ in names. Instead we use - . This applies to both symbols and keywords. That leads to Kebab Casing like this :the-winner-is , and not Snake Casing :dont_do_this . Pascal case is reserved for a situation which we don't cover in this tutorial. We can use - in names because it isn't an operator. In the form ( - 3 2 ) , - is a one character name which is the ultimate in kebab case. It also happens to look like the minus operator in other languages. Predicates \u00b6 On that subject, you'll often see Clojure names which include a trailing ? . For example, even? or nil? . This is a naming convention. It is used for symbols bound to predicate functions which test for a truth. Form Evaluates To ( odd? 5 ) true ( even? 5 ) false ( nil? 5 ) false ( nil? nil ) true ( empty? []) true ( empty? [ :some :thing ]) false Again, we can use ? in names because it is not an operator, as it is in other lanugages. What Have You Learned ? \u00b6 So Far: To write Clojure code, you write Clojure data literal. You code in data. data can be evaluated, to create new data 1st Evaluation Rule: most data evaluates to itself 2nd Evaluation Rule: symbols evaluate to what they are bound to 3rd Evaluation Rule: lists evaluate to a function call's return value using \"quoting\" we can avoid the 2nd and 3rd evaluation rules. Now, we review some special cases. Special Forms \u00b6 Some Forms are special because they evaluate differently to the \"normal\" rules outlined above. Let's review the important ones. if \u00b6 if forms evaluate in a \"special\" way. This ( if true 4 3 ) is a four element list. Normal evaluation rules would mean, first, evaluate all four elements of the list, and then calling the if function with three arguments. But with if forms, not all elements are evaluated. The 2nd test element is evaluated but then either the 3rd or the 4th argument is evaluated depending on the result of that test . One element remains unevaluated. Example Evaluates To Comments ( if true 4 3 ) 4 Only true and 4 elements are evaluated The 3 element is not evaluated ( if false 4 3 ) 3 Only false and 3 elements are evaluated ( if false 4 ) nil else form not provided for evaluation, so the if evaluates to nil ( if ( odd? 3 ) 3 4 ) 3 ( odd? 3 ) evaluates to true ( = 4 ( inc 3 )) true ( if ( = 4 ( inc 3 )) :t :f ) :t [ 1 ( if true \"yes\" )] [ 1 \"yes\" ] { 1 ( if false \"yes\" )} { 1 nil } No Statements Notice how if is a form in Clojure, which evaluates to a value, and not a statement. (Clojure doesn't have any statements, or operators, it just has data and evaluation rules) Possible experiments: check if ( if true ) is valid. explore what is \"truthy\", via ( if \"hello\" true false ) or ( if [] true false ) or ( if nil true false ) fn \u00b6 An fn form creates a function. We're taking a big step up here. Here is a very simple example ( fn [ x ] x ) : an fn form has three elements: the 2nd is a vector of symbols - in this case [ x ] the 3rd is a body - in this case x an fn form is \"special\" because the 2nd and 3rd elements are not evaluated it is only later, when this function is called, that body will be evaluated, and when that happens, body can refer to symbols in the vector, which will be bound to the actual arguments of the function call our simple example function above only takes one argument. See [ x ] and, when the body is evaluated, at call time, the symbol x will be bound to the actual argument of that function call the function will return the evaluation of the body , which, in the case above, is the same value as the actual argument. consequently, if we called this function with the argument 3 , this function would return 3 and, if we called this function with the argument [ :a :b ] , it would return [ :a :b ] Question : so, how do we call this function? Answer : easy, we already know how, just place it as the first element in a form. Then add a 2nd element in that form, which is the actual argument. Like this: ; Aside: a line which starts with a semi-colon is a comment ; The following is a two element list: ; - the 1st is (fn [x] x) and that's a function (created by an `fn` form) ; - the 2nd element is a string \"the actual arg\" (( fn [ x ] x ) \"the actual arg\" ) I'd like you to see this two element list as more like, say: ( count \"the actual arg\" ) Except, in place of the symbol count there is a form ( fn [ x ] x ) . count is symbol which evaluates to a builtin function. Whereas ( fn [ x ] x ) is a form which evaluates to a function. Either way, the first element of the list evaluates to a function and the 2nd element to the list will be the actual argument in this function call. Let's work through it in more detail: This is a two element list, so it will evaluate to a function call, in the two step process described above First, evaluate all the elements of the list (remember, there are two) The first element (the fn form) will evaluate to a function The second element is a string which will evaluate to itself \"the actual arg\" Second, the function call happens the function ( fn [ x ] x ) will be called x will be bound to the actual argument \"the actual arg\" calling the function means evaluating the body of the function The body of the function is just x , a symbol which is bound to the actual argument \"the actual arg\" So the body evaluates to \"the actual arg\" The functions return value will be \"the actual arg\" And that then is the evaluation of the entire form Here's another call to the same function: (( fn [ x ] x ) [ :a :b ]) The actual argument is [ :a :b ] , and the form (function call) will evaluate to [ :a :b ] . Let's create a different function and evaluate it: (( fn [ num ] ( + num 1 )) 4 ) The body of the function, ( + num 1 ) , will be evaluated with the num symbol bound to the actual parameter 4 . The return value is 5 . Try these experiments: ((fn [x] [x x]) 4) ((fn [x y] {x y}) :a 4) ((fn [])) ((fn [yes?] {:a (if yes? \"yes\")}) true) what if, instead, we called this function with false . You won't see this written in normal ClojureScript code, because it is weird, but here's a puzzle: (((fn [] inc)) 4) What is the evaluation? Note: there is an extra set of parens around the fn form. def \u00b6 The def form creates a symbol and binds it to a value. ( def gurus 2 ) This defines the symbol gurus and binds it to the value 2 . If, later, we used this symbol in other code, it would evaluate to 2 . def is a \"special form\" in two ways: when evaluated, it adds to the global set of defined symbols. Such mutation is known as a side-effect. Functions don't normally cause side effect - they are normally pure. in a normal Clojure form, like say ( f gurus 2 ) , the gurus element would be evaluated before the call. But the evaluation rules in a def form are different because, instead, gurus is the symbol to define. It doesn't get evaluated. But the 3rd element certainly does. The 3rd element of a def is evaluated: ( def saints ( inc gurus )) ;; look, using the symbol `gurus` !! saints is now also a defined symbol and it is bound to the evaluation of ( inc gurus ) , which is ( inc 2 ) , which is 3 . Consider these two: ( def beach-list [ :hat :sunglasses :towel ]) ( def beach-items ( count beach-list )) ;; count is a builtin function beach-items is a symbol bound to 3 Now, consider what is happening here: ( def my-inc ( fn [ a ] ( + a 1 )) That fn form will create a function, and then the def will bind it to the symbol my-inc . Two steps. Hey, we've just created our own inc . ( my-inc 4 ) evaluates to 5 And again: ( def square-it ( fn [ x ] ( * x x ))) We can use this symbol square-it in a form (it is now bound to a function), like this: ( square-it 5 ) evaluates to 25 defn \u00b6 A ClojureScript program typically contains a lot of function definitions, and combining def and fn each time would be verbose. So, there is a shorter way which combines the two, called defn . You use it like this: ( defn dec ; `dec` is the symbol being defined [ n ] ; a vector of symbols for the actual arguments ( - n 1 )) ; function body - evaluated when function is called - uses `n` So, this binds a symbol to a function. All of the \"builtin functions\" mentioned previously in this tutorial are defined this way: str , count , inc , namespace , + etc. To use the symbol/function just defined: ( dec 4 ) evaluates to 3 Define another function: ( defn square-it ; `square-it` is the symbol being defined [ n ] ; a vector of symbols for the actual arguments ( * n n )) ; function body - evaluated when function is called - uses `n` use it: ( square-it 3 ) evaluates to 9 . Or use it like this: ( square-it ( inc 3 )) evaluates to 16 . Define another: ( defn greet [ username ] ( str \"Hello \" username ))) str is a builtin function which turns each of its arguments into a string and concatenates them. use it: ( greet \"world\" ) evaluates to \"Hello world\" . In a functional language, creating functions is a big deal. You'll be using defn a lot. let \u00b6 This is another special form you'll be using a lot . ; a let form has two parts: ; - 1st a vector of \"binding pairs\" ; - 2nd a \"body\" ( let [ a \"pen\" ] ; a pair - binds the symbol `a` to the value \"pen\" a ) ; the body is evaluated with the bindings This let form evaluates to \"pen\" Another one: ( let [ a \"pen\" ] :foo ) ; odd. The body doesn't use `a`. But this still works. This let form evaluates to :foo Notice the way this let form is formatted: ( let [ a \"pen\" ; this pair means `a` is bound to \"pen\" b \"sword\" ] ; this pair means `b` is bound to \"sword\" ( > a b )) ; is \"pen\" greater than \"sword\" ?? evaluates to false . Wait, no. That isn't conventional wisdom. Damn you lexicographic comparisons!! We need to make some changes: ( let [ a \"the pen\" b \"a sword\" ] ( if ( > a b ) a b )) evaluates to \"the pen\" . Phew! ( let [ a \"the pen\" b \"a sword\" ] { :winner-is ( if ( > a b ) a b )}) evaluates to { :winner-is \"the pen\" } let is often used within a defn : (defn greet [name friendly?] (let [greeting (if friendly? \"Hello \" \"Go away \")] [:div greeting name])) XXX experiment with greet (greet \"Mum\" true) (greet \"Noisy Neighbours\" false) In this particular, we could have got away with no using a let , like this: ( defn greet [ name friendly? ] [ :div ( if friendly? \"Hello \" \"Go away \" ) name ) ( defn items-text [ items ] ( let [ num ( count items ) plural ( if ( = num 1 ) \"\" \"s\" ) verb ( if ( > num 1 ) \"are \" \"is \" )] ( str \"There \" verb num \" item\" plural ))) Check on the output in these cases: ( items-text [ :towel :sunglasses ]) ( items-text [ :towel ]) ( items-text []) Exercise: when there are no items make the text \"there are no items\" (and not \"there is 0 items\") What have You Learned ? \u00b6 So Far: the syntax is just data literals data can be evaluated lists (forms) evaluate to function calls there are special forms (exceptions to the normal evaluation rules for forms) defn allows us to bind a function to a symbol Data Functions \u00b6 Sometimes data can act as a function - it can appear as the first element in a form. For example, a hashmap can act as a function. This is easiest to explain via code: ({ :a 11 } :a ) Here, a hashmap { :a 11 } is used as the 1st element in a form . The actual argument, :a , will be looked up in that hashmap, and the associated value, 11 , is the return value of the function call. So 11 is the evaluation. ({ :a 11 :b 21 } :b ) evaluates to 21 . We are looking up the key :b in the hashmap { :a 11 :b 21 } and obtaining the associated value 21 ({ :a 11 :b 21 } :c ) evaluates to nil . There's no key :c in the hashmap. ({ :a 11 :b 21 } :c :not-found ) evaluates to :not-found . The key was not found in the hashmap, but we supplied a default value as the 2nd actual argument (the 3rd element of the list). This can be reversed. A keyword can also be used as the 1st element in a form, provided the actual argument is a hashmap. ( :a { :a 11 }) evaluates to 11 ( :b { :a 11 :b 21 }) evaluates to 21 ( :c { :a 11 :b 21 }) evaluates to nil ( :c { :a 11 :b 21 } :not-found ) evaluates to :not-found This approach of using a keyword as the function, with a hashmap argument happens a lot in ClojureScript Code. BuiltIn Functions \u00b6 Clojure's has a substantial library of builtin functions. A few in particular are used all the time, and to read Clojure code (our aim here), you must know them. assoc \u00b6 assoc allows you to add a key/value pair to a hashmap. Example Evaluates To Comments ( assoc {} :a 4 ) { :a 4 } adding a key/value pair to the empty hashmap {} ( assoc nil :a 4 ) { :a 4 } nil is treated as {} ( assoc { :b 1 } :a 4 ) { :b 1 :a 4 } adding a key/value pair to the hashmap { :b 1 } ( assoc {} :b 1 :a 4 ) { :b 1 :a 4 } add two pairs at once map \u00b6 Applies a function to all the elements of a collection. First, we create a function called plus-one ( defn plus-one [ it ] ( + 1 it )) Now use it with map : Example of map Evaluates To Comments ( map plus-one [ 1 2 3 ]) ( 2 3 4 ) Applies plus-one to each element of the collection. Think [( plus-one 1 ) ( plus-one 2 ) ( plus-one 3 )] except the result is a list, not a vector. ( map inc [ 1 2 3 ]) ( 2 3 4 ) Same as above, but now inc ( map inc ' ( 1 2 3 )) ( 2 3 4 ) Same as above. But now across a list . Note the use of quote on the list ( map inc # { 1 2 3 }) ( 2 3 4 ) Same as above. But now across a set . ( map count [ \"hi\" \"world\" ]) ( 2 5 ) Think ( count \"hi\" ) ( count \"world\" ) ( map :a [{ :a 1 } { :a 11 }]) ( 1 11 ) Earlier, we learned that keywords can act like functions. Think ( :a { :a 1 }) ( :a { :a 11 }) Note: map always returns a list , even if you give it a vector, set, list, etc. Create add for use with map below: ( defn add [ a b ] ( + a b )) Example Evaluates To Comments ( map add [ 1 2 3 ] [ 4 5 6 ]) ( 5 7 9 ) Applies add to pairs of elements. Think [( add 1 4 ) ( add 2 5 ) ( add 3 6 )] , except result is a list ( map + [ 1 2 3 ] [ 4 5 6 ]) ( 5 7 9 ) Same as above. But using the builtin function + Exercises: ( map { :a 1 :b 2 :c 3 } [ :a :b :c :d ]) What would this evaluate to: ( map count ( map str ( map inc [ 9 99 999 ]))) XXX Live coding here. reduce \u00b6 In the functional world, reduce is part 600 pound gorilla, part swiss arm knife. It takes three arguments: a function which \"accumulates\" the initial state of the accumulation a collection to accumulate \"across\" ( reduce + ;; accumulating with `+` 0 ;; initial state of accumulation [ 1 2 4 ]) ;; the collection to accumulate across, element by element The accumulation function, + in the example above, must accept two arguments: the current, running accumulation, up to the current element the new element to process The accumulation function should combine the current, running accumulation, with the new element, and return an updated accumulation. + works because it can take two arguments and it will return a new accumulation of the two. Because there are three elements in our example collection [ 1 2 4 ] , there are three steps in the reduction. If our collection had 100 elements, there would be 100 steps in the reduction. This is effectively what reduce will compute for the example above: ( + ( + ( + 0 1 ) 2 ) 4 ) evaluates to 7 and, in this case reduce , is effectively summing the collection Or, to explain the three steps another way: Collection Element Running Accumulation Evaluation using + New Accumulation Comment 1 0 ( + 0 1 ) 1 + is applied to the initial value 0 and the 1st element of the collection 1 , producing a new accumulation of 1 2 1 ( + 1 2 ) 3 + is applied to the accumulation 1 and the 2nd element of the collection 2 , producing a new accumulation of 3 4 3 ( + 3 4 ) 7 + is applied to the accumulation 3 and the 3rd element of the collection 4 , producing a new accumulation of 7 Next example: we create this accumulation function: ( defn max [ a b ] ( if ( > a b ) a b )) Then we use that function with a reduce: ( reduce max ;; accumulating with `max` 0 ;; initial accumulation (maximum) [ 1 2 4 ]) ;; the collection to process Effectively, what gets evaluated: ( max ( max ( max 0 1 ) 2 ) 4 ) How about this one: ( reduce str ;; accumulating with the builtin `str` 0 [ 1 2 4 ]) We \"accumulate\" a string How about this one: ( reduce conj ;; <--- `conj` is a builtin too [] ;; <--- empty vector [ 1 2 4 ]) Or this one: ( defn only-odd [ accumulation val ] ;; <-- accumulated value, new value ( if ( even? val ) accumulation ( conj accumulation val ))) ( reduce only-odd [] ;; <--- start with an empty vector [ 1 2 3 4 5 6 ]) The Arrow Macros \u00b6 Clojure has an advanced feature called macros which we'll review now, because you need to understand their impact. Macros are functions which are run at compile time, not run time. Their job is to rewrite your code in useful ways. This is probably not a feature you'll have experienced before in other languages. Wait, rewrite my code? How is that even possible? Well, in ClojureScript your code is data . It is just arrangements of data literals put into text file, involving mostly lists, symbols and vectors. This property means a function can take your code (which is just data, remember), and compute new data, which is new code. And that is how a macro rewrites your code - it is a function that runs at compile time. The key takeaway is that macros rewrite your code in useful ways. Thread First Macro -> \u00b6 Let's talk examples ... here's a deeply nested arrangement of forms we talked about earlier: ( + ( + ( + 0 1 ) 2 ) 4 ) Deeply nested forms, like this, are often rewritten using the thread first macro -> : ( -> ( + 0 1 ) ; (+ 0 1) ( + 2 ) ; (+ (+ 0 1) 2) ( + 4 ))) ; (+ (+ (+ 0 1) 2) 4) -> is a symbol and it is the first element in a form ( -> ... ) . So, this is a function call and the symbol -> is bound to the function to be called, a bit like ( + ... ) . And, in this example, the function call has three actual arguments - I can see three forms. But this -> function is actually getting called at compile time, not run time. And this thread first function (marco) will rewrite/reorganise the three forms provided as arguments, producing new code. And that new code will match exactly the deeply-nested-forms version given above. Read the thread first version (above) like this: First, ( max 0 1 ) is evaluated to 1 Then that 1 value becomes the 1st argument to the next form down, which is ( + 2 ) , effectively creating ( + 1 2 ) Then the evaluation of that form becomes the first argument to the next form, which is ( + 4 ) , effectively creating ( + 3 4 ) The result is 7 Notice how the value for the previous form's evaluation is always \"threaded\" into the form below as the 1st argument. Hence the name \"thread first macro\". Deeply nested forms can be a bit hard to read, so the thread first macro arrangement allows you to visualise the computation as a cascading data flow. It is as if the evaluation of the higher form is \"flowing down\" and into the form underneath. That's a useful mental model for many. How about this use of -> : ( -> {} ( assoc :a 1 ) ; (assoc {} :a 1) ( assoc :b 2 )) ; (assoc (assoc {} :a 1) :b 2) Read that as: First, {} is evaluated to {} Then that value becomes the 1st argument to the next form down creating ( assoc {} :a 1 ) And the evaluation of that form becomes the first argument to the next form creating ( assoc { :a 1 } :b 2 ) The entire form evaluates to { :a 1 :b 2 } Now, we could choose to simply write it the deeply nested way ourselves, of course, but humans seem to better understand the \"data flow\" version more than the nested forms version. Work out the evaluation of: ( -> { :a { :aa 11 }} :a ;; same as (:a) :aa ) ;; same as (:aa) -> belongs to a small family of marcos. Another one is the thread last macro ->> . It operates the same way except it threads the value as the argument in the last position, not the first. Thread Last Macro ->> \u00b6 Do you remember this nested form example from earlier: ( map count ( map str ( map inc [ 9 99 999 ]))) This can be rewritten using the \"thread last\" macro ->> : ( ->> [ 9 99 999 ] ( map inc ) ; (map inc [9 99 999]) ( map str ) ; (map str (map inc [9 99 999])) ( map count )) ; (map count (map str (map inc [9 99 999]))) With thread last the evaluation of the previous form is threaded into the next form as the last argument (not the first). Work out the evaluation of: ( ->> ( range 10 ) ; (range 10) ( map inc ) ; (map inc (range 10)) ( filter odd? )) ; (filter odd? (map inc (range 10)) The Hard Bit \u00b6 The learning curve so far as been gentle. Clojure has simple syntax and simple evaluation semantics. The steeper part of the Clojure learning curve, and the part that takes most of the time to master, is figuring out how to write code using pure functions and immutable data . If you have previously only used imperative, place-oriented languages (eg. OO languages), this paradigm change takes time to click. But, of course, the purpose of this tutorial is to teach you to read Clojure, which is an easier skill. So, onward ... Immutable Data \u00b6 ClojureScript uses immutable data structures by default. The rule : once you create data, you can't mutate it (change it). Ever. But you can create a revision (a copy) of that data, which is modified in some way. The original data is untouched. But, then, you can't change this revision either. But, you can create a further revision (copy) of the revision, etc. Let's see this in action. Evaluate the following: ( let [ car1 { :doors 2 } ; an original hashmap car2 ( assoc car1 :seats 4 ) ; add a key/value pair, a new revision is created car3 ( assoc car2 :engine :big )] ; add a key/value pair, a new revision is created [ car1 car2 car3 ]) ; the value associated with car1 is untouched you'll see a vector of three values [{ :doors 2 } { :doors 2 , :seats 4 } { :doors 2 , :seats 4 , :engine :big } ] . Notice how car1 is unchanged, even though we did an assoc into car1 . Same with XXXXXXXXX When you are used to imperative, in-place modification of data, it can initially be mysterfying as to how you can achieve anything. Rest assured, you can. More experiments. If we evaluate this: ( assoc ( assoc score :c 3 ) :d 4 ) there will be three revisions of a hashmap. The original one bound to score which is { :a 1 :b 2 } . Then there's the one which results from ( assoc score :c 3 ) . And then there is the final one { :a 1 :b 2 :c 3 :d 4 } . If you are new to Immutable Data, you probably have two concerns: Surely this is inefficient? Don't worry, via clever algorithms, efficiency is seldom an issue. How do you get anything done? (Don't worry, there are answers here too). Using Immutable data dovetails with pure functions, to reduce cognitive load and bring a great simplicity to your programming. All grand claims. We'll need to see how this plays out in bigger programs. Evaluate the following: ( let [ car1 { :doors 2 } ;; original hashmap car2 ( assoc car1 :doors 4 ) ;; new value for :doors car3 ( assoc car2 :doors 2 )] ;; back to the original value of 2 [( = car1 car3 ) ( identical? car1 car3 )]) ;; identical? tests if two pieces of data at the same piece Evaluate the following: ( let [ car1 { :doors 2 } ;; this hashmap can't be changed car2 ( assoc car1 :doors 2 )] ;; wait on, same values!!! ( identical? car1 car2 )) ;; identical? tests if two pieces of data at the same XXX boolean and and or ??? https://j19sch.github.io/blog/clj3-and-or-being-weird/ XXX destructuring ?? Later XXX interop ?? Mention ?? XXX Reagent like code ?? Next tutorial XXX atoms and deref - defer this to later XXX tracking is reified dynamics. residential ; short-hand for creating a simple function: ; #(...) => (fn [args] (...)) ( 3 %) ; => (fn [x] ( 3 x)) \u00b6 ( 3 (+ %1 %2)) ; => (fn [x y] ( 3 (+ x y))) \u00b6 Summary \u00b6 We have learned: in ClojureScript we evaulate data, to create new data virtually all data literals evaluate to themselves We've looked at ClojureScript through a lens which makes it easier to understand Reagent and re-frame. Installing \u00b6 To install Clojure and Leiningen (a build tool) following these instructions . Here's a good intro on writing a function: https://blog.cleancoder.com/uncle-bob/2020/04/09/ALittleMoreClojure.html Gently paced video series showing you ClojureScript coding/tooling from the basics up: https://www.youtube.com/watch?v=SljDPNwAFOc&list=PLaGDS2KB3-ArG0WqAytE9GsZgrM-USsZA The cheatsheet: https://clojure.org/api/cheatsheet A visual overview of the similarities and differences between ClojureScript and JavaScript https://www.freecodecamp.org/news/here-is-a-quick-overview-of-the-similarities-and-differences-between-clojurescript-and-javascript-c5bd51c5c007/ We haven't covered: macros - write functions which take your code/data and manipulate it at compile time. JavaScript interop. (js/console.log \"Hello World!\")","title":"Clojurescript"},{"location":"clojurescript/#why","text":"Clojure is a modern LISP. Alan Kay once described LISP as \"Maxwell's equations of software\". Paul Graham believes LISP was a competitive advantage for his startup. Eric Raymmond said that learning LISP was profoundly enligthening and that knowing it would make you a better programmer for the rest of your days. In the 70s, 80s and 90s, the LISP community went through a washing machine phase of evolutionary churn. Innovation flourished, experiments happened, prototype ideas were tested and knowledge foliated. Later, in about 2010, Rich Hickey took that knowledge and created Clojure, introducing key innovations. He did this well away from academia (LISP's traditional home) because he wanted to create a pragmatic language for commercial developers. So, Clojure has had a long gestation period, and it comes with a hard practical edge. As the owner of a company that develops software products, I believe ClojureScript gives us a competitive edge. As an experienced programmer, I feel like it has provided me with excellent, nourishing brain food. It is a stable, productive place. If you'll allow me some momentary negativity: in contrast, I'm scared of the javascript landscape, which still appears to be a churning washing machine full of steep learning curves, premature obsolescence and sharp edges, which teach me little of substance and certainly won't make me productive. Enough of a sermon? Yes. Okay, 40 mins ... A note on names: Clojure runs on the JVM. ClojureScript runs in the browser. They are essentially the same language but our focus here is on ClojureScript . I have good news: you are going to be surprised and delighted at the simplicity of the syntax.","title":"Why?"},{"location":"clojurescript/#simple-data-literals","text":"Type Example Comment character \\a The letter a number 1 number 3.14 string \"hello\" nil nil aka null, None","title":"Simple Data Literals"},{"location":"clojurescript/#collection-data-literals","text":"Lists use () , vectors use [] , hashmaps use {} and sets use # {} , Examples: Collection Example Comment list ( 1 2 3 ) Empty list is () No commas necessary. But, if present, treated as whitespace. list ( 1 2 \"yes\" ) Can be heterogeneous. vector [ 1 2 3 ] Again, no commas necessary. Empty vector is [] vector [ 1 \"hello\" \\x nil ] Can be heterogeneous. hashmap { 1 \"Hello\" } A dictionary, or hashmap. Each pair is a key and a value . One pair in this example. 1 is key, \"hello\" is the value hashmap { 1 \"Hello\" 2 nil } No delimiter necessary between pairs. Two key/value pairs in this example. hashmap { 1 \"Hello\" \\b 27 \"pi\" 3.14 } Can be heterogeneous. Still no commas between pairs. set # { 1 \"Hello\" \\a } Can be heterogeneous. Still no commas between pairs. Collections can nest: Example Comment vector [ 1 [ 2 2 ] 3 ] an element can be another vector vector [ 1 { 4 5 } 3 ] an element can be a hashmap hashmap { 1 [ 4 5 ] 2 [ \\a \\b ]} a value in a hashmap can be a vector hashmap { 1 { 4 5 } 2 { \\a \\b }} a value in a hashmap can be a hashmap hashmap {{ 4 5 } 1 [ 1 2 ] 2 } the keys in a hashmap can be a hashmap or vector Hashmaps are often just called maps.","title":"Collection Data Literals"},{"location":"clojurescript/#symbols","text":"A symbol is a name that is bound to a value . Here, we mean \"bound\" in the sense of \"is tied to\" or \"is associated with\" or \"refers to\". Type Example Comment symbol inc The symbol inc is bound to one of Clojure's builtin functions. This function will return its argument incremented symbol + The symbol + is also bound to a builtin function. It adds its arguments. note: + is not an operator in ClojureScript, it is a function symbol yours Soon you'll see how you can create a symbol and bind it to a value. But that is a few minutes away down the page, so until then, you'll just have to take it on trust that this is possible/easy.","title":"Symbols"},{"location":"clojurescript/#thats-it-for-syntax","text":"We've now covered most of Clojure's syntax. But, how can that be? Haven't we only looked at data literals? Well, yes, but Clojure is Homoiconic which means \"code is data\" - you write Clojure code using Clojure's data literals and we've covered data literals.","title":"That's It For Syntax"},{"location":"clojurescript/#evaluation","text":"You are going to be surprised and delighted with the simplicity of \"evaluation\". 1st Evaluation Rule: all data litterals other than lists and symbols evaluate to themselves. Value Evaluates To Comment \\a \\a Same 1 1 Same [ 1 1 ] [ 1 1 ] Same { 1 1 2 2 } { 1 1 2 2 } Yep, same Below, you can start evaluating live on this page. Click the Eval button, or change the expression, and it will be evaluated. The result of the evaluation will be shown in the box below the editor. Try these experiments: {:a 1 :a 4} (fn duplicate-keys [{:keys [return-str]}] (when (re-find #\"duplicate key\" return-str) [:span \"Oops! A map can only have 1 of a given key. Try changing \" [:code \":a 4\"] \" to \" [:code \":b 4\"] \".\"])) [:apple :orange :banana (fn eof-vector [{:keys [return-str]}] (when (re-find #\"EOF\" return-str) [:span \"Forgot to close the form? Try adding \" [:code \"]\"] \" to the end.\"])) XXX other basic examples? So, let's now talk about the two exceptions lists and symbols ...","title":"Evaluation"},{"location":"clojurescript/#evaluating-symbols","text":"2nd Evaluation Rule: Symbols don't evaluate to themselves. Instead, they evaluate to the value to which they are \"bound\". Example symbol evaluations: Expression Evaluates To Comments foo 4 Assuming the symbol foo is bound to the value 4 bar [ 1 2 3 ] Assuming the symbol bar is bound to the value [ 1 2 3 ] [ 1 foo ] [ 1 4 ] Each element is evaluated, and foo evaluated to 4 [ foo bar ] [ 4 [ 1 2 3 ]] Assuming foo evaluates to 4 , bar evaluates to [ 1 2 3 ] Symbols are often bound to functions For the moment, you'll have to take my word on this: the symbol inc is bound to a function in Clojure's standard library. As a result, when you evaulate inc , you get the function!! Because that's what inc is bound to. There's also another symbol, count , which is bound to different function in the standard library. And, finally - this one will be a surprise - the symbol + is bound to a function. Wait. Isn't + an operator? No. Clojure doesn't have operators. Instead, + is a symbol, and it is bound to a function - one which adds. Anyway, more soon. Try these experiments: > inc (fn function-object [{:keys [status]}] (when (#{:success} status) [:span \"Functions are technically objects, and cljs represents them by printing \" [:code \"object[qualified$name]\"]])) [inc dec +] (fn function-vec-item [{:keys [status]}] (when (#{:success} status) \"This is simply three items in a vector. Just because they're functions does not mean you're calling them.\")) {inc 5} (fn function-vec-item [{:keys [status]}] (when (#{:success} status) \"Nearly anything can be a map key.\"))","title":"Evaluating Symbols"},{"location":"clojurescript/#evaluating-lists","text":"3rd Evaluation Rule: a list evaluates to a function call. Okay, now we're cooking with gas! Clojure is a functional language so, as you can imagine, function calls are a big deal, so this section is important. Here's an example list ( f arg1 arg2 arg3 ) . Because it is surrounded by parens, ( ) , it is a list, and we can see it has four elements. Such a list is evaluated in two steps : first, each element in the list is evaluated (all four of them in this example) then, a function call occurs where: the evaluation of the 1st element will be the function called the evaluation of the other elements (3 in the case above) will be the actual arguments in this function call The list evaluates to the return value of this function call. So, if this example function call returned the string \"maybe Satoshi\" , then the list ( f arg1 arg2 arg3 ) would evaluate to \"maybe Satoshi\" . More on symbols bound to functions In Clojure code, the 1st element of a list is often a symbol. So, let's talk more about that. Here's an example: ( inc 3 ) . That's a two element list, and the first element is the symbol inc . The 2nd element is the value 3 When evaluating this list, in step 1 all elements of the list are evaluated and, if the first element of the list is a symbol, like inc , it will evaluate to what it is bound to, which is a function. And it is that function which is called in step 2. So inc is a symbol, not a function. But it is bound to a function. A subtle but important distinction. If, instead, inc was bound to the value 27 we couldn't use it in the first position of a list, because it is bound to a number, not a function. We'd get an error at call time. Example list evaluations, involving symbols: List Evaluates To Comments ( inc 3 ) 4 Step 1: evaluate each element of the list (there are two): \u2022 the symbol inc is bound to a builtin function \u2022 and 3 evaluates to 3 Step 2: call the function with 3 as the argument. The return value 4 [ 5 ( inc 6 )] [ 5 7 ] Evaluate each element of the vector. 5 evaluates to 5 . Then, evaluating that 2nd element is a function call. ( + 1 2 ) 3 The symbol + is bound to a builin function. And that function adds together its arguments ( + 1 2 3 ) 6 Surprise! Turns out this function can handle a variable number of arguments. [ 1 ( + 1 2 3 )] [ 1 6 ] No operators We now know that + is a symbol bound to a builtin function, not an operator. It is the same with - , / , > , = , etc. Because these are just names, you can also have not= And because there are no operators, there's no operator precedence to discuss. Simple syntax, right? Let's start evaluating, live. Type into the following editor. Click Ctrl-click to evaluate. Possible experiments: is (+ 1) an error? How about (+) or (*) ? try (odd? 5) try (count [1 2 3]) (fn arithmetic-arity [{:keys [status source-form]}] (when (and (#{:success} status) (#{'(+ 1) '(+) '(*)} source-form)) \"Consider this either very intuitive, or very unintuitive.\"))","title":"Evaluating Lists"},{"location":"clojurescript/#forms","text":"A list like this ( + 1 2 ) is known as a form . Forms can nest like this: ( + 1 ( inc 10 )) . So, how do nested forms evaluate? Well, in your mind's eye, see this nested example as ( f arg1 arg2 ) where: f is + arg1 is 1 arg2 is ( inc 10 ) <-- a nested form To evaluate this form, you'll remember from the last section that it is a two step process. First, evaluate each of the three elements. So the execution trace will be: + will evaluate to the builtin function bound to that symbol 1 evaluates to 1 ( inc 10 ) is a list and we evaluate it as a function call: (1) evaluate the elements (2) perform the function call with all three elements evaluated, the function (bound to + ) is called with the two actual arguments of 1 and 11 the return value from the function call is 12 which means the overall evaluation of this nested form is 12 More: Nested Forms Evaluates To Comments ( + 3 ( count [ 1 2 ])) 5 Evaluation trace: \u2022 + is evaluated to a function \u2022 3 is evaluated to 3 \u2022 ( count [ 1 2 ]) is evaluated as a function call which returns 2 \u2022 call function with args 3 and 2 , which returns 5 ( = 2 ( inc 1 )) true = is a symbol which is bound to a builtin function. You can guess what it does. ( = ( inc 1 ) ( dec 3 )) true dec is bound to a bultin, and it decrements its arg by one Evaluate these experiments yourself (any surprises?): (inc (dec 1)) (odd? (inc (dec 1))) (= (inc (dec 1)) 1)","title":"Forms"},{"location":"clojurescript/#keywords","text":"Keywords are like symbols, except they evaluate to themselves and not to a bound value. This means they evaluate like most other data literals. Keywords are invaluable as identities and they are used widely, particularly as keys in hashmaps. A keyword is a name that starts with a colon. Let's evaluate some: Value Evaluates To Comments :foo :foo It evaluates to itself. :bar :bar It evaluates to itself ( = :bar :bar ) true Different instances will evaluate to equal. Like numbers do, and strings. ( = :bar :foo ) false [ 1 2 :bar ] [ 1 2 :bar ] Yep, evaluates to itself. { 1 :bar } { 1 :bar } And again, but as a hashmap value Keywords can have a namespace . Value Evaluates To Comments :panel1/edit :panel1/edit Starts with a colon Optionally, contains a / Before the / is the namespace After the / is the name Evaluates to itself :panel2/edit :panel2/edit Different namespace to above, same name :panel.commands/edit :panel.commands/edit namespaces can be dotted ( name :a/b ) \"b\" name is bound to a builtin function ( namespace :a/b ) \"a\" namespace is bound to a builtin function ( keyword \"a/b\" ) :a/b keyword is bound to a builtin function ( keyword \"a\" \"b\" ) :a/b keyword is bound to a builtin function To give you a taste of where this can go, here they are used as the keys in a hashmap: { :user/id 1 :user/name \"Barry\" :user/age 28 :user/company \"SpaceX\" :role/name \"Rocket Sharpener\" } Evaluate these experiments yourself (any surprises?): (namespace :a) (keyword (name :a)) (keyword (namespace :a/b) (name :a/b))","title":"Keywords"},{"location":"clojurescript/#kebab-case-please","text":"We don't use _ in names. Instead we use - . This applies to both symbols and keywords. That leads to Kebab Casing like this :the-winner-is , and not Snake Casing :dont_do_this . Pascal case is reserved for a situation which we don't cover in this tutorial. We can use - in names because it isn't an operator. In the form ( - 3 2 ) , - is a one character name which is the ultimate in kebab case. It also happens to look like the minus operator in other languages.","title":"Kebab Case Please"},{"location":"clojurescript/#predicates","text":"On that subject, you'll often see Clojure names which include a trailing ? . For example, even? or nil? . This is a naming convention. It is used for symbols bound to predicate functions which test for a truth. Form Evaluates To ( odd? 5 ) true ( even? 5 ) false ( nil? 5 ) false ( nil? nil ) true ( empty? []) true ( empty? [ :some :thing ]) false Again, we can use ? in names because it is not an operator, as it is in other lanugages.","title":"Predicates"},{"location":"clojurescript/#what-have-you-learned","text":"So Far: To write Clojure code, you write Clojure data literal. You code in data. data can be evaluated, to create new data 1st Evaluation Rule: most data evaluates to itself 2nd Evaluation Rule: symbols evaluate to what they are bound to 3rd Evaluation Rule: lists evaluate to a function call's return value using \"quoting\" we can avoid the 2nd and 3rd evaluation rules. Now, we review some special cases.","title":"What Have You Learned ?"},{"location":"clojurescript/#special-forms","text":"Some Forms are special because they evaluate differently to the \"normal\" rules outlined above. Let's review the important ones.","title":"Special Forms"},{"location":"clojurescript/#if","text":"if forms evaluate in a \"special\" way. This ( if true 4 3 ) is a four element list. Normal evaluation rules would mean, first, evaluate all four elements of the list, and then calling the if function with three arguments. But with if forms, not all elements are evaluated. The 2nd test element is evaluated but then either the 3rd or the 4th argument is evaluated depending on the result of that test . One element remains unevaluated. Example Evaluates To Comments ( if true 4 3 ) 4 Only true and 4 elements are evaluated The 3 element is not evaluated ( if false 4 3 ) 3 Only false and 3 elements are evaluated ( if false 4 ) nil else form not provided for evaluation, so the if evaluates to nil ( if ( odd? 3 ) 3 4 ) 3 ( odd? 3 ) evaluates to true ( = 4 ( inc 3 )) true ( if ( = 4 ( inc 3 )) :t :f ) :t [ 1 ( if true \"yes\" )] [ 1 \"yes\" ] { 1 ( if false \"yes\" )} { 1 nil } No Statements Notice how if is a form in Clojure, which evaluates to a value, and not a statement. (Clojure doesn't have any statements, or operators, it just has data and evaluation rules) Possible experiments: check if ( if true ) is valid. explore what is \"truthy\", via ( if \"hello\" true false ) or ( if [] true false ) or ( if nil true false )","title":"if"},{"location":"clojurescript/#fn","text":"An fn form creates a function. We're taking a big step up here. Here is a very simple example ( fn [ x ] x ) : an fn form has three elements: the 2nd is a vector of symbols - in this case [ x ] the 3rd is a body - in this case x an fn form is \"special\" because the 2nd and 3rd elements are not evaluated it is only later, when this function is called, that body will be evaluated, and when that happens, body can refer to symbols in the vector, which will be bound to the actual arguments of the function call our simple example function above only takes one argument. See [ x ] and, when the body is evaluated, at call time, the symbol x will be bound to the actual argument of that function call the function will return the evaluation of the body , which, in the case above, is the same value as the actual argument. consequently, if we called this function with the argument 3 , this function would return 3 and, if we called this function with the argument [ :a :b ] , it would return [ :a :b ] Question : so, how do we call this function? Answer : easy, we already know how, just place it as the first element in a form. Then add a 2nd element in that form, which is the actual argument. Like this: ; Aside: a line which starts with a semi-colon is a comment ; The following is a two element list: ; - the 1st is (fn [x] x) and that's a function (created by an `fn` form) ; - the 2nd element is a string \"the actual arg\" (( fn [ x ] x ) \"the actual arg\" ) I'd like you to see this two element list as more like, say: ( count \"the actual arg\" ) Except, in place of the symbol count there is a form ( fn [ x ] x ) . count is symbol which evaluates to a builtin function. Whereas ( fn [ x ] x ) is a form which evaluates to a function. Either way, the first element of the list evaluates to a function and the 2nd element to the list will be the actual argument in this function call. Let's work through it in more detail: This is a two element list, so it will evaluate to a function call, in the two step process described above First, evaluate all the elements of the list (remember, there are two) The first element (the fn form) will evaluate to a function The second element is a string which will evaluate to itself \"the actual arg\" Second, the function call happens the function ( fn [ x ] x ) will be called x will be bound to the actual argument \"the actual arg\" calling the function means evaluating the body of the function The body of the function is just x , a symbol which is bound to the actual argument \"the actual arg\" So the body evaluates to \"the actual arg\" The functions return value will be \"the actual arg\" And that then is the evaluation of the entire form Here's another call to the same function: (( fn [ x ] x ) [ :a :b ]) The actual argument is [ :a :b ] , and the form (function call) will evaluate to [ :a :b ] . Let's create a different function and evaluate it: (( fn [ num ] ( + num 1 )) 4 ) The body of the function, ( + num 1 ) , will be evaluated with the num symbol bound to the actual parameter 4 . The return value is 5 . Try these experiments: ((fn [x] [x x]) 4) ((fn [x y] {x y}) :a 4) ((fn [])) ((fn [yes?] {:a (if yes? \"yes\")}) true) what if, instead, we called this function with false . You won't see this written in normal ClojureScript code, because it is weird, but here's a puzzle: (((fn [] inc)) 4) What is the evaluation? Note: there is an extra set of parens around the fn form.","title":"fn"},{"location":"clojurescript/#def","text":"The def form creates a symbol and binds it to a value. ( def gurus 2 ) This defines the symbol gurus and binds it to the value 2 . If, later, we used this symbol in other code, it would evaluate to 2 . def is a \"special form\" in two ways: when evaluated, it adds to the global set of defined symbols. Such mutation is known as a side-effect. Functions don't normally cause side effect - they are normally pure. in a normal Clojure form, like say ( f gurus 2 ) , the gurus element would be evaluated before the call. But the evaluation rules in a def form are different because, instead, gurus is the symbol to define. It doesn't get evaluated. But the 3rd element certainly does. The 3rd element of a def is evaluated: ( def saints ( inc gurus )) ;; look, using the symbol `gurus` !! saints is now also a defined symbol and it is bound to the evaluation of ( inc gurus ) , which is ( inc 2 ) , which is 3 . Consider these two: ( def beach-list [ :hat :sunglasses :towel ]) ( def beach-items ( count beach-list )) ;; count is a builtin function beach-items is a symbol bound to 3 Now, consider what is happening here: ( def my-inc ( fn [ a ] ( + a 1 )) That fn form will create a function, and then the def will bind it to the symbol my-inc . Two steps. Hey, we've just created our own inc . ( my-inc 4 ) evaluates to 5 And again: ( def square-it ( fn [ x ] ( * x x ))) We can use this symbol square-it in a form (it is now bound to a function), like this: ( square-it 5 ) evaluates to 25","title":"def"},{"location":"clojurescript/#defn","text":"A ClojureScript program typically contains a lot of function definitions, and combining def and fn each time would be verbose. So, there is a shorter way which combines the two, called defn . You use it like this: ( defn dec ; `dec` is the symbol being defined [ n ] ; a vector of symbols for the actual arguments ( - n 1 )) ; function body - evaluated when function is called - uses `n` So, this binds a symbol to a function. All of the \"builtin functions\" mentioned previously in this tutorial are defined this way: str , count , inc , namespace , + etc. To use the symbol/function just defined: ( dec 4 ) evaluates to 3 Define another function: ( defn square-it ; `square-it` is the symbol being defined [ n ] ; a vector of symbols for the actual arguments ( * n n )) ; function body - evaluated when function is called - uses `n` use it: ( square-it 3 ) evaluates to 9 . Or use it like this: ( square-it ( inc 3 )) evaluates to 16 . Define another: ( defn greet [ username ] ( str \"Hello \" username ))) str is a builtin function which turns each of its arguments into a string and concatenates them. use it: ( greet \"world\" ) evaluates to \"Hello world\" . In a functional language, creating functions is a big deal. You'll be using defn a lot.","title":"defn"},{"location":"clojurescript/#let","text":"This is another special form you'll be using a lot . ; a let form has two parts: ; - 1st a vector of \"binding pairs\" ; - 2nd a \"body\" ( let [ a \"pen\" ] ; a pair - binds the symbol `a` to the value \"pen\" a ) ; the body is evaluated with the bindings This let form evaluates to \"pen\" Another one: ( let [ a \"pen\" ] :foo ) ; odd. The body doesn't use `a`. But this still works. This let form evaluates to :foo Notice the way this let form is formatted: ( let [ a \"pen\" ; this pair means `a` is bound to \"pen\" b \"sword\" ] ; this pair means `b` is bound to \"sword\" ( > a b )) ; is \"pen\" greater than \"sword\" ?? evaluates to false . Wait, no. That isn't conventional wisdom. Damn you lexicographic comparisons!! We need to make some changes: ( let [ a \"the pen\" b \"a sword\" ] ( if ( > a b ) a b )) evaluates to \"the pen\" . Phew! ( let [ a \"the pen\" b \"a sword\" ] { :winner-is ( if ( > a b ) a b )}) evaluates to { :winner-is \"the pen\" } let is often used within a defn : (defn greet [name friendly?] (let [greeting (if friendly? \"Hello \" \"Go away \")] [:div greeting name])) XXX experiment with greet (greet \"Mum\" true) (greet \"Noisy Neighbours\" false) In this particular, we could have got away with no using a let , like this: ( defn greet [ name friendly? ] [ :div ( if friendly? \"Hello \" \"Go away \" ) name ) ( defn items-text [ items ] ( let [ num ( count items ) plural ( if ( = num 1 ) \"\" \"s\" ) verb ( if ( > num 1 ) \"are \" \"is \" )] ( str \"There \" verb num \" item\" plural ))) Check on the output in these cases: ( items-text [ :towel :sunglasses ]) ( items-text [ :towel ]) ( items-text []) Exercise: when there are no items make the text \"there are no items\" (and not \"there is 0 items\")","title":"let"},{"location":"clojurescript/#what-have-you-learned_1","text":"So Far: the syntax is just data literals data can be evaluated lists (forms) evaluate to function calls there are special forms (exceptions to the normal evaluation rules for forms) defn allows us to bind a function to a symbol","title":"What have You Learned ?"},{"location":"clojurescript/#data-functions","text":"Sometimes data can act as a function - it can appear as the first element in a form. For example, a hashmap can act as a function. This is easiest to explain via code: ({ :a 11 } :a ) Here, a hashmap { :a 11 } is used as the 1st element in a form . The actual argument, :a , will be looked up in that hashmap, and the associated value, 11 , is the return value of the function call. So 11 is the evaluation. ({ :a 11 :b 21 } :b ) evaluates to 21 . We are looking up the key :b in the hashmap { :a 11 :b 21 } and obtaining the associated value 21 ({ :a 11 :b 21 } :c ) evaluates to nil . There's no key :c in the hashmap. ({ :a 11 :b 21 } :c :not-found ) evaluates to :not-found . The key was not found in the hashmap, but we supplied a default value as the 2nd actual argument (the 3rd element of the list). This can be reversed. A keyword can also be used as the 1st element in a form, provided the actual argument is a hashmap. ( :a { :a 11 }) evaluates to 11 ( :b { :a 11 :b 21 }) evaluates to 21 ( :c { :a 11 :b 21 }) evaluates to nil ( :c { :a 11 :b 21 } :not-found ) evaluates to :not-found This approach of using a keyword as the function, with a hashmap argument happens a lot in ClojureScript Code.","title":"Data Functions"},{"location":"clojurescript/#builtin-functions","text":"Clojure's has a substantial library of builtin functions. A few in particular are used all the time, and to read Clojure code (our aim here), you must know them.","title":"BuiltIn Functions"},{"location":"clojurescript/#assoc","text":"assoc allows you to add a key/value pair to a hashmap. Example Evaluates To Comments ( assoc {} :a 4 ) { :a 4 } adding a key/value pair to the empty hashmap {} ( assoc nil :a 4 ) { :a 4 } nil is treated as {} ( assoc { :b 1 } :a 4 ) { :b 1 :a 4 } adding a key/value pair to the hashmap { :b 1 } ( assoc {} :b 1 :a 4 ) { :b 1 :a 4 } add two pairs at once","title":"assoc"},{"location":"clojurescript/#map","text":"Applies a function to all the elements of a collection. First, we create a function called plus-one ( defn plus-one [ it ] ( + 1 it )) Now use it with map : Example of map Evaluates To Comments ( map plus-one [ 1 2 3 ]) ( 2 3 4 ) Applies plus-one to each element of the collection. Think [( plus-one 1 ) ( plus-one 2 ) ( plus-one 3 )] except the result is a list, not a vector. ( map inc [ 1 2 3 ]) ( 2 3 4 ) Same as above, but now inc ( map inc ' ( 1 2 3 )) ( 2 3 4 ) Same as above. But now across a list . Note the use of quote on the list ( map inc # { 1 2 3 }) ( 2 3 4 ) Same as above. But now across a set . ( map count [ \"hi\" \"world\" ]) ( 2 5 ) Think ( count \"hi\" ) ( count \"world\" ) ( map :a [{ :a 1 } { :a 11 }]) ( 1 11 ) Earlier, we learned that keywords can act like functions. Think ( :a { :a 1 }) ( :a { :a 11 }) Note: map always returns a list , even if you give it a vector, set, list, etc. Create add for use with map below: ( defn add [ a b ] ( + a b )) Example Evaluates To Comments ( map add [ 1 2 3 ] [ 4 5 6 ]) ( 5 7 9 ) Applies add to pairs of elements. Think [( add 1 4 ) ( add 2 5 ) ( add 3 6 )] , except result is a list ( map + [ 1 2 3 ] [ 4 5 6 ]) ( 5 7 9 ) Same as above. But using the builtin function + Exercises: ( map { :a 1 :b 2 :c 3 } [ :a :b :c :d ]) What would this evaluate to: ( map count ( map str ( map inc [ 9 99 999 ]))) XXX Live coding here.","title":"map"},{"location":"clojurescript/#reduce","text":"In the functional world, reduce is part 600 pound gorilla, part swiss arm knife. It takes three arguments: a function which \"accumulates\" the initial state of the accumulation a collection to accumulate \"across\" ( reduce + ;; accumulating with `+` 0 ;; initial state of accumulation [ 1 2 4 ]) ;; the collection to accumulate across, element by element The accumulation function, + in the example above, must accept two arguments: the current, running accumulation, up to the current element the new element to process The accumulation function should combine the current, running accumulation, with the new element, and return an updated accumulation. + works because it can take two arguments and it will return a new accumulation of the two. Because there are three elements in our example collection [ 1 2 4 ] , there are three steps in the reduction. If our collection had 100 elements, there would be 100 steps in the reduction. This is effectively what reduce will compute for the example above: ( + ( + ( + 0 1 ) 2 ) 4 ) evaluates to 7 and, in this case reduce , is effectively summing the collection Or, to explain the three steps another way: Collection Element Running Accumulation Evaluation using + New Accumulation Comment 1 0 ( + 0 1 ) 1 + is applied to the initial value 0 and the 1st element of the collection 1 , producing a new accumulation of 1 2 1 ( + 1 2 ) 3 + is applied to the accumulation 1 and the 2nd element of the collection 2 , producing a new accumulation of 3 4 3 ( + 3 4 ) 7 + is applied to the accumulation 3 and the 3rd element of the collection 4 , producing a new accumulation of 7 Next example: we create this accumulation function: ( defn max [ a b ] ( if ( > a b ) a b )) Then we use that function with a reduce: ( reduce max ;; accumulating with `max` 0 ;; initial accumulation (maximum) [ 1 2 4 ]) ;; the collection to process Effectively, what gets evaluated: ( max ( max ( max 0 1 ) 2 ) 4 ) How about this one: ( reduce str ;; accumulating with the builtin `str` 0 [ 1 2 4 ]) We \"accumulate\" a string How about this one: ( reduce conj ;; <--- `conj` is a builtin too [] ;; <--- empty vector [ 1 2 4 ]) Or this one: ( defn only-odd [ accumulation val ] ;; <-- accumulated value, new value ( if ( even? val ) accumulation ( conj accumulation val ))) ( reduce only-odd [] ;; <--- start with an empty vector [ 1 2 3 4 5 6 ])","title":"reduce"},{"location":"clojurescript/#the-arrow-macros","text":"Clojure has an advanced feature called macros which we'll review now, because you need to understand their impact. Macros are functions which are run at compile time, not run time. Their job is to rewrite your code in useful ways. This is probably not a feature you'll have experienced before in other languages. Wait, rewrite my code? How is that even possible? Well, in ClojureScript your code is data . It is just arrangements of data literals put into text file, involving mostly lists, symbols and vectors. This property means a function can take your code (which is just data, remember), and compute new data, which is new code. And that is how a macro rewrites your code - it is a function that runs at compile time. The key takeaway is that macros rewrite your code in useful ways.","title":"The Arrow Macros"},{"location":"clojurescript/#thread-first-macro-","text":"Let's talk examples ... here's a deeply nested arrangement of forms we talked about earlier: ( + ( + ( + 0 1 ) 2 ) 4 ) Deeply nested forms, like this, are often rewritten using the thread first macro -> : ( -> ( + 0 1 ) ; (+ 0 1) ( + 2 ) ; (+ (+ 0 1) 2) ( + 4 ))) ; (+ (+ (+ 0 1) 2) 4) -> is a symbol and it is the first element in a form ( -> ... ) . So, this is a function call and the symbol -> is bound to the function to be called, a bit like ( + ... ) . And, in this example, the function call has three actual arguments - I can see three forms. But this -> function is actually getting called at compile time, not run time. And this thread first function (marco) will rewrite/reorganise the three forms provided as arguments, producing new code. And that new code will match exactly the deeply-nested-forms version given above. Read the thread first version (above) like this: First, ( max 0 1 ) is evaluated to 1 Then that 1 value becomes the 1st argument to the next form down, which is ( + 2 ) , effectively creating ( + 1 2 ) Then the evaluation of that form becomes the first argument to the next form, which is ( + 4 ) , effectively creating ( + 3 4 ) The result is 7 Notice how the value for the previous form's evaluation is always \"threaded\" into the form below as the 1st argument. Hence the name \"thread first macro\". Deeply nested forms can be a bit hard to read, so the thread first macro arrangement allows you to visualise the computation as a cascading data flow. It is as if the evaluation of the higher form is \"flowing down\" and into the form underneath. That's a useful mental model for many. How about this use of -> : ( -> {} ( assoc :a 1 ) ; (assoc {} :a 1) ( assoc :b 2 )) ; (assoc (assoc {} :a 1) :b 2) Read that as: First, {} is evaluated to {} Then that value becomes the 1st argument to the next form down creating ( assoc {} :a 1 ) And the evaluation of that form becomes the first argument to the next form creating ( assoc { :a 1 } :b 2 ) The entire form evaluates to { :a 1 :b 2 } Now, we could choose to simply write it the deeply nested way ourselves, of course, but humans seem to better understand the \"data flow\" version more than the nested forms version. Work out the evaluation of: ( -> { :a { :aa 11 }} :a ;; same as (:a) :aa ) ;; same as (:aa) -> belongs to a small family of marcos. Another one is the thread last macro ->> . It operates the same way except it threads the value as the argument in the last position, not the first.","title":"Thread First Macro -&gt;"},{"location":"clojurescript/#thread-last-macro-","text":"Do you remember this nested form example from earlier: ( map count ( map str ( map inc [ 9 99 999 ]))) This can be rewritten using the \"thread last\" macro ->> : ( ->> [ 9 99 999 ] ( map inc ) ; (map inc [9 99 999]) ( map str ) ; (map str (map inc [9 99 999])) ( map count )) ; (map count (map str (map inc [9 99 999]))) With thread last the evaluation of the previous form is threaded into the next form as the last argument (not the first). Work out the evaluation of: ( ->> ( range 10 ) ; (range 10) ( map inc ) ; (map inc (range 10)) ( filter odd? )) ; (filter odd? (map inc (range 10))","title":"Thread Last Macro -&gt;&gt;"},{"location":"clojurescript/#the-hard-bit","text":"The learning curve so far as been gentle. Clojure has simple syntax and simple evaluation semantics. The steeper part of the Clojure learning curve, and the part that takes most of the time to master, is figuring out how to write code using pure functions and immutable data . If you have previously only used imperative, place-oriented languages (eg. OO languages), this paradigm change takes time to click. But, of course, the purpose of this tutorial is to teach you to read Clojure, which is an easier skill. So, onward ...","title":"The Hard Bit"},{"location":"clojurescript/#immutable-data","text":"ClojureScript uses immutable data structures by default. The rule : once you create data, you can't mutate it (change it). Ever. But you can create a revision (a copy) of that data, which is modified in some way. The original data is untouched. But, then, you can't change this revision either. But, you can create a further revision (copy) of the revision, etc. Let's see this in action. Evaluate the following: ( let [ car1 { :doors 2 } ; an original hashmap car2 ( assoc car1 :seats 4 ) ; add a key/value pair, a new revision is created car3 ( assoc car2 :engine :big )] ; add a key/value pair, a new revision is created [ car1 car2 car3 ]) ; the value associated with car1 is untouched you'll see a vector of three values [{ :doors 2 } { :doors 2 , :seats 4 } { :doors 2 , :seats 4 , :engine :big } ] . Notice how car1 is unchanged, even though we did an assoc into car1 . Same with XXXXXXXXX When you are used to imperative, in-place modification of data, it can initially be mysterfying as to how you can achieve anything. Rest assured, you can. More experiments. If we evaluate this: ( assoc ( assoc score :c 3 ) :d 4 ) there will be three revisions of a hashmap. The original one bound to score which is { :a 1 :b 2 } . Then there's the one which results from ( assoc score :c 3 ) . And then there is the final one { :a 1 :b 2 :c 3 :d 4 } . If you are new to Immutable Data, you probably have two concerns: Surely this is inefficient? Don't worry, via clever algorithms, efficiency is seldom an issue. How do you get anything done? (Don't worry, there are answers here too). Using Immutable data dovetails with pure functions, to reduce cognitive load and bring a great simplicity to your programming. All grand claims. We'll need to see how this plays out in bigger programs. Evaluate the following: ( let [ car1 { :doors 2 } ;; original hashmap car2 ( assoc car1 :doors 4 ) ;; new value for :doors car3 ( assoc car2 :doors 2 )] ;; back to the original value of 2 [( = car1 car3 ) ( identical? car1 car3 )]) ;; identical? tests if two pieces of data at the same piece Evaluate the following: ( let [ car1 { :doors 2 } ;; this hashmap can't be changed car2 ( assoc car1 :doors 2 )] ;; wait on, same values!!! ( identical? car1 car2 )) ;; identical? tests if two pieces of data at the same XXX boolean and and or ??? https://j19sch.github.io/blog/clj3-and-or-being-weird/ XXX destructuring ?? Later XXX interop ?? Mention ?? XXX Reagent like code ?? Next tutorial XXX atoms and deref - defer this to later XXX tracking is reified dynamics. residential ; short-hand for creating a simple function: ; #(...) => (fn [args] (...))","title":"Immutable Data"},{"location":"clojurescript/#3-fn-x-3-x","text":"","title":"( 3 %)         ; =&gt; (fn [x] ( 3 x))"},{"location":"clojurescript/#3-1-2-fn-x-y-3-x-y","text":"","title":"( 3 (+ %1 %2)) ; =&gt; (fn [x y] ( 3 (+ x y)))"},{"location":"clojurescript/#summary","text":"We have learned: in ClojureScript we evaulate data, to create new data virtually all data literals evaluate to themselves We've looked at ClojureScript through a lens which makes it easier to understand Reagent and re-frame.","title":"Summary"},{"location":"clojurescript/#installing","text":"To install Clojure and Leiningen (a build tool) following these instructions . Here's a good intro on writing a function: https://blog.cleancoder.com/uncle-bob/2020/04/09/ALittleMoreClojure.html Gently paced video series showing you ClojureScript coding/tooling from the basics up: https://www.youtube.com/watch?v=SljDPNwAFOc&list=PLaGDS2KB3-ArG0WqAytE9GsZgrM-USsZA The cheatsheet: https://clojure.org/api/cheatsheet A visual overview of the similarities and differences between ClojureScript and JavaScript https://www.freecodecamp.org/news/here-is-a-quick-overview-of-the-similarities-and-differences-between-clojurescript-and-javascript-c5bd51c5c007/ We haven't covered: macros - write functions which take your code/data and manipulate it at compile time. JavaScript interop. (js/console.log \"Hello World!\")","title":"Installing"},{"location":"correcting-a-wrong/","text":"The \"simple\" app from the live coding walk through had a flaw. It breaks a rule. re-frame Rule Views should only compute hiccup. A view shouldn't process input data. The subscriptions it uses should deliver the data already in the right structure, ready for use in hiccup generation. The \"simple\" app contained this code: ( defn clock [] ( let [ colour @ ( rf/subscribe [ :time-color ]) time ( -> @ ( rf/subscribe [ :time ]) .toTimeString ( clojure.string/split \" \" ) first )] [ :div.example-clock { :style { :color colour }} time ])) That view obtains data from a [:time] subscription and then it further processes that data into the form it needs for use in the hiccup. We don't like that. The Solution \u00b6 We're going to rewrite this slightly. We will create a new [:time-str] subscription which will deliver the right data to the view, ready to go, so the view is 100% concerned with hiccup generation only. Maybe, like this: ( defn clock [] [ :div.example-clock { :style { :color @ ( rf/subscribe [ :time-color ])}} @ ( rf/subscribe [ :time-str ])]) So, we'll add this time-str subscription handler: ( reg-sub :time-str ;; signals function ( fn [ _ _ ] ( subscribe [ :time ])) ;; computation function ( fn [ t _ ] ( -> t .toTimeString ( clojure.string/split \" \" ) first ))) Now the subscription does the computation, not the view. Much better. You'll notice this new subscription handler belongs to Layer 3 (Materialised View) of the Signal Graph . We could rewrite it to use the :<- syntactic sugar: ( reg-sub :time-str :<- [ :time ] ;; <-- this is syntactic sugar for signals function ( fn [ t _ ] ( -> t .toTimeString ( clojure.string/split \" \" ) first ))) Another Technique \u00b6 Above, I suggested this: ( defn clock [] [ :div.example-clock { :style { :color @ ( rf/subscribe [ :time-color ])}} @ ( rf/subscribe [ :time-str ])]) But that may offend your finely tuned aesthetics. Too much noise with those two @ ? To clean this up, we could define a new listen function: ( defn listen [ query-v ] @ ( rf/subscribe query-v )) And then rewrite: ( defn clock [] [ :div.example-clock { :style { :color ( listen [ :time-color ])}} ( listen [ :time-str ])]) So, at the cost of writing your own function, listen , the code is now less noisy AND there's less chance of us forgetting an @ (which can lead to odd problems). listen would obviously be useful in every View, not just this one. LambdaIsland Naming (LIN) \u00b6 I ended up quite liking the alternative names suggested by Lambda Island Videos : ( def <sub ( comp deref re-frame.core/subscribe )) ;; same as `listen` (above) ( def >evt re-frame.core/dispatch ) Say It Again \u00b6 So, using your new-found knowledge, if, in code review, you saw this view function: ( defn show-items [] ( let [ sorted-items ( sort @ ( subscribe [ :items ]))] ( into [ :div ] ( for [ i sorted-items ] [ item-view i ])))) What would you leap on with a banshee scream supportively object to? That sort , right? Computation in the view. Instead, we want exactly the right data delivered to the view - no further computation required - the view's job is to simply make hiccup . The solution is to create a subscription that delivers items already sorted. ( reg-sub :sorted-items ( fn [ _ _ ] ( subscribe [ :items ])) ( fn [ items _ ] ( sort items )) Now, in this case the computation is a bit trivial, but the moment it is a little tricky, you'll want to test it. So separating it out from the view will make that easier. To make it testable, you may structure like this: ( defn item-sorter [ items _ ] ( sort items )) ( reg-sub :sorted-items ( fn [ _ _ ] ( subscribe [ :items ])) item-sorter ) Now it is easy to test item-sorter independently. The Other Benefit \u00b6 re-frame de-duplicates signal graph nodes. If, for example, two views wanted to (subscribe [:sorted-items]) only the one node (in the signal graph) would be created. Only one node would be doing that potentially expensive sorting operation (when items changed) and values from it would be flowing through to both views. That sort of efficiency can't happen if the views themselves are doing the sort . de-duplication \u00b6 As I described above, two, or more, concurrent subscriptions for the same query will source reactive updates from the one executing handler - from the one node in the signal graph. How do we know if two subscriptions are \"the same\"? Answer: two subscriptions are the same if their query vectors test = to each other. So, these two subscriptions are not \"the same\": [:some-event 42] [:some-event \"blah\"] . Even though they involve the same event id, :some-event , the query vectors do not test = . This feature shakes out well because re-frame has a data oriented design. A Final FAQ \u00b6 The following issue comes up a bit. You will end up with a bunch of Layer 2 (extractor) reg-sub s which look the same (they all extract a path from app-db ): ( reg-sub :a ( fn [ db _ ] ( :a db ))) ( reg-sub :b ( fn [ db _ ] ( -> db :top :b ))) Now, you think and design abstractly for a living, and that repetition will feel uncomfortable. It will call to you like a Siren: \"refaaaaactoooor meeeee\". \"Maaaake it DRYYYY\". So here's my tip: tie yourself to the mast and sail on. That repetition is good. It is serving a purpose. Just sail on. The WORST thing you can do is to flex your magnificent abstraction muscles and create something like this: ( reg-sub :extract-any-path ( fn [ db path ] ( get-in db path )) \"Genius!\", you think to yourself. \"Now I only need one direct reg-sub and I supply a path to it. A read-only cursor of sorts. Look at the code I can delete.\" Neat and minimal it most certainly is, yes, but genius it isn't, IMHO. You are now asking the code USING the subscription to provide the path. You have traded some innocuous repetition for longer term fragility, and that's not a good trade. What fragility? Well, the view which subscribes using, say, (subscribe [:extract-any-path [:some :path]]) now \"knows\" about (depends on) the structure within app-db . What happens when you inevitably restructure app-db and put that :path path under another high level branch of app-db ? You will have to run around all the views, looking for the paths supplied, knowing which to alter and which to leave alone. Fragile. We want our views to declaratively ask for data, but they should have no idea where it comes from. It is the job of a subscription to know where data comes from. Remember our rule at the top: keep views as simple as possible . Don't give them knowledge or tasks outside their remit.","title":"Correcting a wrong"},{"location":"correcting-a-wrong/#the-solution","text":"We're going to rewrite this slightly. We will create a new [:time-str] subscription which will deliver the right data to the view, ready to go, so the view is 100% concerned with hiccup generation only. Maybe, like this: ( defn clock [] [ :div.example-clock { :style { :color @ ( rf/subscribe [ :time-color ])}} @ ( rf/subscribe [ :time-str ])]) So, we'll add this time-str subscription handler: ( reg-sub :time-str ;; signals function ( fn [ _ _ ] ( subscribe [ :time ])) ;; computation function ( fn [ t _ ] ( -> t .toTimeString ( clojure.string/split \" \" ) first ))) Now the subscription does the computation, not the view. Much better. You'll notice this new subscription handler belongs to Layer 3 (Materialised View) of the Signal Graph . We could rewrite it to use the :<- syntactic sugar: ( reg-sub :time-str :<- [ :time ] ;; <-- this is syntactic sugar for signals function ( fn [ t _ ] ( -> t .toTimeString ( clojure.string/split \" \" ) first )))","title":"The Solution"},{"location":"correcting-a-wrong/#another-technique","text":"Above, I suggested this: ( defn clock [] [ :div.example-clock { :style { :color @ ( rf/subscribe [ :time-color ])}} @ ( rf/subscribe [ :time-str ])]) But that may offend your finely tuned aesthetics. Too much noise with those two @ ? To clean this up, we could define a new listen function: ( defn listen [ query-v ] @ ( rf/subscribe query-v )) And then rewrite: ( defn clock [] [ :div.example-clock { :style { :color ( listen [ :time-color ])}} ( listen [ :time-str ])]) So, at the cost of writing your own function, listen , the code is now less noisy AND there's less chance of us forgetting an @ (which can lead to odd problems). listen would obviously be useful in every View, not just this one.","title":"Another Technique"},{"location":"correcting-a-wrong/#lambdaisland-naming-lin","text":"I ended up quite liking the alternative names suggested by Lambda Island Videos : ( def <sub ( comp deref re-frame.core/subscribe )) ;; same as `listen` (above) ( def >evt re-frame.core/dispatch )","title":"LambdaIsland Naming  (LIN)"},{"location":"correcting-a-wrong/#say-it-again","text":"So, using your new-found knowledge, if, in code review, you saw this view function: ( defn show-items [] ( let [ sorted-items ( sort @ ( subscribe [ :items ]))] ( into [ :div ] ( for [ i sorted-items ] [ item-view i ])))) What would you leap on with a banshee scream supportively object to? That sort , right? Computation in the view. Instead, we want exactly the right data delivered to the view - no further computation required - the view's job is to simply make hiccup . The solution is to create a subscription that delivers items already sorted. ( reg-sub :sorted-items ( fn [ _ _ ] ( subscribe [ :items ])) ( fn [ items _ ] ( sort items )) Now, in this case the computation is a bit trivial, but the moment it is a little tricky, you'll want to test it. So separating it out from the view will make that easier. To make it testable, you may structure like this: ( defn item-sorter [ items _ ] ( sort items )) ( reg-sub :sorted-items ( fn [ _ _ ] ( subscribe [ :items ])) item-sorter ) Now it is easy to test item-sorter independently.","title":"Say It Again"},{"location":"correcting-a-wrong/#the-other-benefit","text":"re-frame de-duplicates signal graph nodes. If, for example, two views wanted to (subscribe [:sorted-items]) only the one node (in the signal graph) would be created. Only one node would be doing that potentially expensive sorting operation (when items changed) and values from it would be flowing through to both views. That sort of efficiency can't happen if the views themselves are doing the sort .","title":"The Other Benefit"},{"location":"correcting-a-wrong/#de-duplication","text":"As I described above, two, or more, concurrent subscriptions for the same query will source reactive updates from the one executing handler - from the one node in the signal graph. How do we know if two subscriptions are \"the same\"? Answer: two subscriptions are the same if their query vectors test = to each other. So, these two subscriptions are not \"the same\": [:some-event 42] [:some-event \"blah\"] . Even though they involve the same event id, :some-event , the query vectors do not test = . This feature shakes out well because re-frame has a data oriented design.","title":"de-duplication"},{"location":"correcting-a-wrong/#a-final-faq","text":"The following issue comes up a bit. You will end up with a bunch of Layer 2 (extractor) reg-sub s which look the same (they all extract a path from app-db ): ( reg-sub :a ( fn [ db _ ] ( :a db ))) ( reg-sub :b ( fn [ db _ ] ( -> db :top :b ))) Now, you think and design abstractly for a living, and that repetition will feel uncomfortable. It will call to you like a Siren: \"refaaaaactoooor meeeee\". \"Maaaake it DRYYYY\". So here's my tip: tie yourself to the mast and sail on. That repetition is good. It is serving a purpose. Just sail on. The WORST thing you can do is to flex your magnificent abstraction muscles and create something like this: ( reg-sub :extract-any-path ( fn [ db path ] ( get-in db path )) \"Genius!\", you think to yourself. \"Now I only need one direct reg-sub and I supply a path to it. A read-only cursor of sorts. Look at the code I can delete.\" Neat and minimal it most certainly is, yes, but genius it isn't, IMHO. You are now asking the code USING the subscription to provide the path. You have traded some innocuous repetition for longer term fragility, and that's not a good trade. What fragility? Well, the view which subscribes using, say, (subscribe [:extract-any-path [:some :path]]) now \"knows\" about (depends on) the structure within app-db . What happens when you inevitably restructure app-db and put that :path path under another high level branch of app-db ? You will have to run around all the views, looking for the paths supplied, knowing which to alter and which to leave alone. Fragile. We want our views to declaratively ask for data, but they should have no idea where it comes from. It is the job of a subscription to know where data comes from. Remember our rule at the top: keep views as simple as possible . Don't give them knowledge or tasks outside their remit.","title":"A Final FAQ"},{"location":"data-oriented-design/","text":"On DSLs and Machines \u00b6 Data-Oriented programming happens when \"data is code\". The data can be evaluated/executed. This data must be in a specific format - it must conform to a DSL (domain-specific language) - and there must be an interpreter for this DSL. When you feed correctly formated data into the interpreter, it is executed. \"Data is code\" for this interpreter. Okay, we'll cycle back to this in a minute. But first ... Events are cardinal to re-frame. As you create a re-frame app, you design just the right set of them. These events will model \"intent\" - mostly the user's. They are the \"language of the system\", and they will provide the eloquence. And they are data. Imagine we created a drawing application - one of those simple ones where the user can draw circles and triangles and add some text. And then imagine that we allowed a user to begin using our new drawing application and that, as they did, we captured, into a collection, the events caused by that user's actions (via their button clicks, drags, keypresses, etc). The collection of events they generate might look like this: ( def collected-events [ [ :clear ] [ :enter-draw-mode ] [ :new-shape :triangle 1 2 3 ] [ :select-object 23 ] [ :rename \"a better name\" ] [ :delete-selection ] .... ]) Now, as an aside, consider the following assembly instructions: mov eax , ebx sub eax , 216 mov BYTE PTR [ ebx ], 2 Assembly instructions are just data, right? Data which happens to be \"executable\" by the right machine - an x86 machine in this case. I'd like you to now look back at that collection of events. I'd like you to view it in the same way - data instructions which can be executed - by the right machine. Really? What machine? A virtual machine. The many Event Handlers you register in your re-frame app collectively implement the \"virtual machine\" on which these instructions execute. When you register a new event handler using reg-event-db , it is as if you are adding to the \"instruction set\" of this \"machine\". When first introducing re-frame, I said it had Data-Oriented Design. And we now know that means \"data is code\". You assemble data in a particular format (a domain-specific language), and that data is then seen as code by an interpreter which executes it. Consider hiccup. It is a data format (DSL) for describing how to create and arrange DOM. Make a data structure in the right format and Reagent will act as the \"interpreter\" which executes that \"language\" creating the DOM you describe. Hiccup is code. (Data is code) We can use pure data literals: [ :div { :font-size 12 } \"Hello\" ] Or we can add a small bit of computation: [ :div ( if friendly? \"Hello\" \"Go away\" ) \" world\" ] Or, a lot more computation: ( into [ :div ] ( map render-item items )] Irrespective of how we create the hiccup-formatted data, it acts as \"instructions\" for Reagent's hiccup interpreter. Back to re-frame. It asks that you create a DSL for your app - the set of events are your DSL. (I wasn't kidding when I said events are the \"language of your system\".) And it also asks that you provide a way to execute the instructions in that DSL (you must provide the event handlers). When your re-frame application runs, it is executing a \"program\" - a collection of events - which is data - dynamically created by the user's actions (button clicks etc) - on a virtual machine made from the event handlers you register. Events are the (assembly) language of your application. Hiccup is the DOM of your application, etc. And it is all data. Look carefully into re-frame, and you'll see the primacy of data everywhere. String Is Code There is also string-oriented programming which is what you often employ with regexes or SQL. We have all used a string containing just the right format with a regex engine. And we've all given a string containing SQL to a database engine, which it knows how to interpret it. When the strings concerned are literals, this can be straightforward. But it quickly gets ugly if we have to start computing the strings - if we have to use string interpolation to build up the string to be executed. And, of course, this happens a lot with SQL, and it is awful. Consequently, there are a thousand workarounds. Data is a better medium for computing code, than strings. Datalog (data) is better than SQL (strings). Multiple Execution Contexts You'll notice that both data-oriented programming or string-oriented programming involves multiple execution contexts, at runtime. For example, with hiccup at runtime two things are happening: one execution context (ClojureScript) creates the data (into [:div] (map renderer items)) one execution context interpets the data (as code) - Reagent. Same for string-oriented programming. One context creates the regex string (perhaps it is just a literal in that context). And the other context executes it. So, just to be crystal clear: one context generates \"the code\" (the data or the string,) and the other context executes it. Other Meanings The term Data-Oriented Design means something quite different in the gaming world. There, it is an optimisation technique which tries to layout data structures in a way that exploits CPU cache characteristics and access patterns, in order to achieve better performance. On the subject of DSLs, I'd strongly, strongly recommend James Reeves' excellent talk (video): Transparency through data","title":"Data Oriented Design"},{"location":"data-oriented-design/#on-dsls-and-machines","text":"Data-Oriented programming happens when \"data is code\". The data can be evaluated/executed. This data must be in a specific format - it must conform to a DSL (domain-specific language) - and there must be an interpreter for this DSL. When you feed correctly formated data into the interpreter, it is executed. \"Data is code\" for this interpreter. Okay, we'll cycle back to this in a minute. But first ... Events are cardinal to re-frame. As you create a re-frame app, you design just the right set of them. These events will model \"intent\" - mostly the user's. They are the \"language of the system\", and they will provide the eloquence. And they are data. Imagine we created a drawing application - one of those simple ones where the user can draw circles and triangles and add some text. And then imagine that we allowed a user to begin using our new drawing application and that, as they did, we captured, into a collection, the events caused by that user's actions (via their button clicks, drags, keypresses, etc). The collection of events they generate might look like this: ( def collected-events [ [ :clear ] [ :enter-draw-mode ] [ :new-shape :triangle 1 2 3 ] [ :select-object 23 ] [ :rename \"a better name\" ] [ :delete-selection ] .... ]) Now, as an aside, consider the following assembly instructions: mov eax , ebx sub eax , 216 mov BYTE PTR [ ebx ], 2 Assembly instructions are just data, right? Data which happens to be \"executable\" by the right machine - an x86 machine in this case. I'd like you to now look back at that collection of events. I'd like you to view it in the same way - data instructions which can be executed - by the right machine. Really? What machine? A virtual machine. The many Event Handlers you register in your re-frame app collectively implement the \"virtual machine\" on which these instructions execute. When you register a new event handler using reg-event-db , it is as if you are adding to the \"instruction set\" of this \"machine\". When first introducing re-frame, I said it had Data-Oriented Design. And we now know that means \"data is code\". You assemble data in a particular format (a domain-specific language), and that data is then seen as code by an interpreter which executes it. Consider hiccup. It is a data format (DSL) for describing how to create and arrange DOM. Make a data structure in the right format and Reagent will act as the \"interpreter\" which executes that \"language\" creating the DOM you describe. Hiccup is code. (Data is code) We can use pure data literals: [ :div { :font-size 12 } \"Hello\" ] Or we can add a small bit of computation: [ :div ( if friendly? \"Hello\" \"Go away\" ) \" world\" ] Or, a lot more computation: ( into [ :div ] ( map render-item items )] Irrespective of how we create the hiccup-formatted data, it acts as \"instructions\" for Reagent's hiccup interpreter. Back to re-frame. It asks that you create a DSL for your app - the set of events are your DSL. (I wasn't kidding when I said events are the \"language of your system\".) And it also asks that you provide a way to execute the instructions in that DSL (you must provide the event handlers). When your re-frame application runs, it is executing a \"program\" - a collection of events - which is data - dynamically created by the user's actions (button clicks etc) - on a virtual machine made from the event handlers you register. Events are the (assembly) language of your application. Hiccup is the DOM of your application, etc. And it is all data. Look carefully into re-frame, and you'll see the primacy of data everywhere. String Is Code There is also string-oriented programming which is what you often employ with regexes or SQL. We have all used a string containing just the right format with a regex engine. And we've all given a string containing SQL to a database engine, which it knows how to interpret it. When the strings concerned are literals, this can be straightforward. But it quickly gets ugly if we have to start computing the strings - if we have to use string interpolation to build up the string to be executed. And, of course, this happens a lot with SQL, and it is awful. Consequently, there are a thousand workarounds. Data is a better medium for computing code, than strings. Datalog (data) is better than SQL (strings). Multiple Execution Contexts You'll notice that both data-oriented programming or string-oriented programming involves multiple execution contexts, at runtime. For example, with hiccup at runtime two things are happening: one execution context (ClojureScript) creates the data (into [:div] (map renderer items)) one execution context interpets the data (as code) - Reagent. Same for string-oriented programming. One context creates the regex string (perhaps it is just a literal in that context). And the other context executes it. So, just to be crystal clear: one context generates \"the code\" (the data or the string,) and the other context executes it. Other Meanings The term Data-Oriented Design means something quite different in the gaming world. There, it is an optimisation technique which tries to layout data structures in a way that exploits CPU cache characteristics and access patterns, in order to achieve better performance. On the subject of DSLs, I'd strongly, strongly recommend James Reeves' excellent talk (video): Transparency through data","title":"On DSLs and Machines"},{"location":"dominoes-30k/","text":"Previously, we looked at the dominoes from 60,000 feet. We will now shift down to 30,000 feet and look in more detail, this time with code fragments. The Setup \u00b6 Imagine this: our app displays a list of items. The user clicks the \"delete\" button next to the 3rd item in the list. In response, let's track what happens within our imaginary re-frame app? Let's manually step through the resulting six domino cascade. Don't expect to completely grok the terse code presented below. We're still at 30,000 feet. More details later. Domino 1 - Event Dispatch \u00b6 In order for it to be clicked, that 3rd delete button must have already been rendered. And rendering in re-frame is done by a ViewFunction . Perhaps it was rendered like this: ( defn delete-button [ item-id ] [ :div.garbage-bin :on-click # ( re-frame.core/dispatch [ :delete-item item-id ])]) It is that on-click handler (function) which interests us. When the user clicks on the garbage-bin icon, that function is called. # ( re-frame.core/dispatch [ :delete-item item-id ]) This function calls re-frame's dispatch to emit an event . Every re-frame event is a vector and, in this case, the dispatched event has two elements: [ :delete-item 2486 ] where 2486 is an id I just made up for that 3rd item. The first element of an event vector, :delete-item , is the kind of event. The rest is optional data, salient to the event . Events express user intent in a domain-specific way. They are the language of your re-frame system. Domino 2 - Event Handling \u00b6 An event handler (function), which we'll name h , is now called to compute the effect of the event [:delete-item 2486] . On startup, re-frame apps register handlers for events using reg-event-fx . So, in our imaginary app, because h is the handler function for :delete-item events, it must have been registered like this: ( re-frame.core/reg-event-fx ;; a part of the re-frame API :delete-item ;; the kind of event h ) ;; the handler function for this kind of event Because h is an event handler, it is written to take two arguments: a coeffects map. This data describes the current state of \"the world\". In the simplest case, it is a trivial map like this: {:db a-value} where a-value is the current application state held in app-db . the event to handle, which would be [:delete-item 2486] in this case. h will compute effects as data. That means: it computes how the world should be changed by the event, and it returns a map of effects which describe the necessary changes. Here's a sketch (we are at 30,000 feet): ( defn h ;; maybe choose a better name like `delete-item` [ coeffects event ] ;; `coeffects` holds the current state of the world ( let [ item-id ( second event ) ;; extract id from event vector db ( :db coeffects ) ;; extract the current application state new-db ( dissoc-in db [ :items item-id ])] ;; new app state { :db new-db })) ;; a map of the necessary effects There are ways (described in later tutorials) for you to inject necessary aspects of \"the world\" into that first coeffects argument (map). Different event handlers need to know different \"things\" about the world to do their job. But current \"application state\" is one aspect of the world which is invariably needed, and it is available by default in the :db key. So the current value in app-db is available via the expression (:db coeffects) . The value returned by h is a map with only one key, like this: { :db new-db } ;; `new-db` is the newly computed application state So, h computes one effect, and returns it. And that effect says to make a change to application state. Please pay particular attention to this overall flow, within h : h obtains the current application state (a map) via (:db coeffects) it computes a modified application state via (dissoc-in db [:items item-id]) it returns this modified application state in an effects map {:db new-db} BTW, here is a more idiomatic (and terser) rewrite of h using destructuring of the args: ( defn h [{ :keys [ db ]} [ _ item-id ]] ;; <--- new: obtain db and item-id directly { :db ( dissoc-in db [ :items item-id ])}) ;; Domino 3 - Effect Handling \u00b6 effect handler functions action the effects returned by h . In Domino 2, h returned: { :db new-db } ;; `new-db` is the new, computed application state Each key of this returned map identifies one kind of effect , and the value for that key supplies further details. The map returned by h only has one key, :db , so it is specifying only one effect. On startup, a re-frame app can register effects handlers using reg-fx . For example, the effect handler function for the :db effect could be registered like this: ( re-frame.core/reg-fx ;; part of the re-frame API :db ;; the effects key ( fn [ val ] ;; the handler function for the effect ( reset! app-db val ))) ;; put the new value into the ratom app-db Just to be clear, this reset! of app-db is a mutative, effectful action. That's what effect handlers do. They change the world. They are not pure functions. Now, you don't need to ever register an effects handler for :db because re-frame supplies one built in. re-frame manages app-db and so it will look for any changes (effects) to it. But if, instead, h had returned: { :wear { :pants \"velour flares\" :belt false } :tweet \"Okay, yes, I am Satoshi. #coverblown\" } Then, the two effects handlers registered for :wear and :tweet would be called to action those two effects. And, no, re-frame does not supply standard effect handlers for either, so you would need to have written them yourself, and then registered them. For example: ( re-frame.core/reg-fx ;; re-frame API :wear ;; the effects key which this handler can action ( fn [ val ] ;; val would be, eg, {:pants \"velour flares\" :belt false} ... )) ;; do what's necessary to action the side effect Domino 4 - Query \u00b6 The action of updating app-db (in Domino 3) will trigger the v = f(s) part of the flow. The application state s has just changed (in Domino 3) and now boom, boom go Dominoes 4, 5, and 6, at the end of which we have a new view, v , being shown to the user. In this domino 4, a query (function) over this app state is automatically called. This query function \"extracts\" data from application state, and then computes \"a materialised view\" of the application state - producing data which is useful to the view functions in domino, 5. Now, in this particular case, the query function is pretty trivial. Because the items are stored in app state, there's not a lot to compute and, instead, it acts like a simple extractor or accessor, just plucking the list of items out of application state: ( defn query-fn [ db v ] ;; db is the current value in app-db, v the query vector ( :items db )) ;; not much of a materialised view On program startup, such a query-fn must be associated with a query-id , (so it can be used via subscribe in domino 5) using re-frame.core/reg-sub , like this: ( re-frame.core/reg-sub ;; part of the re-frame API :query-items ;; query id query-fn ) ;; function to perform the query Which says \"if, in domino 5, you see a (subscribe [:query-items]) , then call query-fn to compute it\". Domino 5 - View \u00b6 Because the query function for :query-items just re-computed a new value, any view (function) which uses a (subscribe [:query-items]) is called automatically (reactively) to re-compute new DOM (in response to a change in its source data). View functions compute a data structure, in hiccup format, describing the DOM nodes required. In this \"items\" case, the view functions will not be generating hiccup for the just-deleted item obviously but, other than this, the hiccup computed \"this time\" will be the same as \"last time\". ( defn items-view [] ( let [ items ( subscribe [ :query-items ])] ;; source items from app state [ :div ( map item-render @ items )])) ;; assume item-render already written Notice how items is \"sourced\" from \"app state\" via re-frame.core/subscribe . It is called with a vector argument, and the first element of that vector is a query-id which identifies the \"materialised view\" required by the view. Note: subscribe queries can be parameterised. So, in real-world apps you might have this: (subscribe [:items \"blue\"]) The vector identifies, first, the query, and then supplies further arguments. You could think of that as representing select * from Items where colour=\"blue\" . Except there's no SQL available and you would be the one to implement the more sophisticated query-fn capable of handling the \"where\" argument. More in later tutorials. Domino 6 - DOM \u00b6 The hiccup returned by the view function is made into real browser DOM by Reagent/React. No code from you required. Just happens. The DOM computed \"this time\" will be the same as \"last time\", except for the absence of DOM for the deleted item, so the mutation will be to remove those now-missing DOM nodes from the browser. 3-4-5-6 Summary \u00b6 The key point to understand about our 3-4-5-6 example is: a change to app state ... triggers query functions to rerun ... which triggers view functions to rerun which causes modified browser DOM Boom, boom, boom go the dominoes. It is a reactive data flow. Aaaaand we're done \u00b6 At this point, the re-frame app returns to a quiescent state, waiting for the next event. Two Sub-Cascades \u00b6 You might have noticed that there's actually two sub-cascades 1-2-3 and 4-5-6, and they have a similar structure. In each, it is the second to last domino which computes \"data descriptions\" of the changes required, and it is the last domino which does the dirty work and actions these descriptions. But you seldom need to worry yourself about the dirty work dominos. re-frame mostly takes care of them for you. One is only fruitful at the price of being rich in oppositions -- Nietzsche, Twilight of the Idols Pragmatically, in functional systems, the most interesting part is how and when you arrange to not be pure.","title":"Code"},{"location":"dominoes-30k/#the-setup","text":"Imagine this: our app displays a list of items. The user clicks the \"delete\" button next to the 3rd item in the list. In response, let's track what happens within our imaginary re-frame app? Let's manually step through the resulting six domino cascade. Don't expect to completely grok the terse code presented below. We're still at 30,000 feet. More details later.","title":"The Setup"},{"location":"dominoes-30k/#domino-1-event-dispatch","text":"In order for it to be clicked, that 3rd delete button must have already been rendered. And rendering in re-frame is done by a ViewFunction . Perhaps it was rendered like this: ( defn delete-button [ item-id ] [ :div.garbage-bin :on-click # ( re-frame.core/dispatch [ :delete-item item-id ])]) It is that on-click handler (function) which interests us. When the user clicks on the garbage-bin icon, that function is called. # ( re-frame.core/dispatch [ :delete-item item-id ]) This function calls re-frame's dispatch to emit an event . Every re-frame event is a vector and, in this case, the dispatched event has two elements: [ :delete-item 2486 ] where 2486 is an id I just made up for that 3rd item. The first element of an event vector, :delete-item , is the kind of event. The rest is optional data, salient to the event . Events express user intent in a domain-specific way. They are the language of your re-frame system.","title":"Domino 1 - Event Dispatch"},{"location":"dominoes-30k/#domino-2-event-handling","text":"An event handler (function), which we'll name h , is now called to compute the effect of the event [:delete-item 2486] . On startup, re-frame apps register handlers for events using reg-event-fx . So, in our imaginary app, because h is the handler function for :delete-item events, it must have been registered like this: ( re-frame.core/reg-event-fx ;; a part of the re-frame API :delete-item ;; the kind of event h ) ;; the handler function for this kind of event Because h is an event handler, it is written to take two arguments: a coeffects map. This data describes the current state of \"the world\". In the simplest case, it is a trivial map like this: {:db a-value} where a-value is the current application state held in app-db . the event to handle, which would be [:delete-item 2486] in this case. h will compute effects as data. That means: it computes how the world should be changed by the event, and it returns a map of effects which describe the necessary changes. Here's a sketch (we are at 30,000 feet): ( defn h ;; maybe choose a better name like `delete-item` [ coeffects event ] ;; `coeffects` holds the current state of the world ( let [ item-id ( second event ) ;; extract id from event vector db ( :db coeffects ) ;; extract the current application state new-db ( dissoc-in db [ :items item-id ])] ;; new app state { :db new-db })) ;; a map of the necessary effects There are ways (described in later tutorials) for you to inject necessary aspects of \"the world\" into that first coeffects argument (map). Different event handlers need to know different \"things\" about the world to do their job. But current \"application state\" is one aspect of the world which is invariably needed, and it is available by default in the :db key. So the current value in app-db is available via the expression (:db coeffects) . The value returned by h is a map with only one key, like this: { :db new-db } ;; `new-db` is the newly computed application state So, h computes one effect, and returns it. And that effect says to make a change to application state. Please pay particular attention to this overall flow, within h : h obtains the current application state (a map) via (:db coeffects) it computes a modified application state via (dissoc-in db [:items item-id]) it returns this modified application state in an effects map {:db new-db} BTW, here is a more idiomatic (and terser) rewrite of h using destructuring of the args: ( defn h [{ :keys [ db ]} [ _ item-id ]] ;; <--- new: obtain db and item-id directly { :db ( dissoc-in db [ :items item-id ])}) ;;","title":"Domino 2 - Event Handling"},{"location":"dominoes-30k/#domino-3-effect-handling","text":"effect handler functions action the effects returned by h . In Domino 2, h returned: { :db new-db } ;; `new-db` is the new, computed application state Each key of this returned map identifies one kind of effect , and the value for that key supplies further details. The map returned by h only has one key, :db , so it is specifying only one effect. On startup, a re-frame app can register effects handlers using reg-fx . For example, the effect handler function for the :db effect could be registered like this: ( re-frame.core/reg-fx ;; part of the re-frame API :db ;; the effects key ( fn [ val ] ;; the handler function for the effect ( reset! app-db val ))) ;; put the new value into the ratom app-db Just to be clear, this reset! of app-db is a mutative, effectful action. That's what effect handlers do. They change the world. They are not pure functions. Now, you don't need to ever register an effects handler for :db because re-frame supplies one built in. re-frame manages app-db and so it will look for any changes (effects) to it. But if, instead, h had returned: { :wear { :pants \"velour flares\" :belt false } :tweet \"Okay, yes, I am Satoshi. #coverblown\" } Then, the two effects handlers registered for :wear and :tweet would be called to action those two effects. And, no, re-frame does not supply standard effect handlers for either, so you would need to have written them yourself, and then registered them. For example: ( re-frame.core/reg-fx ;; re-frame API :wear ;; the effects key which this handler can action ( fn [ val ] ;; val would be, eg, {:pants \"velour flares\" :belt false} ... )) ;; do what's necessary to action the side effect","title":"Domino 3 - Effect Handling"},{"location":"dominoes-30k/#domino-4-query","text":"The action of updating app-db (in Domino 3) will trigger the v = f(s) part of the flow. The application state s has just changed (in Domino 3) and now boom, boom go Dominoes 4, 5, and 6, at the end of which we have a new view, v , being shown to the user. In this domino 4, a query (function) over this app state is automatically called. This query function \"extracts\" data from application state, and then computes \"a materialised view\" of the application state - producing data which is useful to the view functions in domino, 5. Now, in this particular case, the query function is pretty trivial. Because the items are stored in app state, there's not a lot to compute and, instead, it acts like a simple extractor or accessor, just plucking the list of items out of application state: ( defn query-fn [ db v ] ;; db is the current value in app-db, v the query vector ( :items db )) ;; not much of a materialised view On program startup, such a query-fn must be associated with a query-id , (so it can be used via subscribe in domino 5) using re-frame.core/reg-sub , like this: ( re-frame.core/reg-sub ;; part of the re-frame API :query-items ;; query id query-fn ) ;; function to perform the query Which says \"if, in domino 5, you see a (subscribe [:query-items]) , then call query-fn to compute it\".","title":"Domino 4 - Query"},{"location":"dominoes-30k/#domino-5-view","text":"Because the query function for :query-items just re-computed a new value, any view (function) which uses a (subscribe [:query-items]) is called automatically (reactively) to re-compute new DOM (in response to a change in its source data). View functions compute a data structure, in hiccup format, describing the DOM nodes required. In this \"items\" case, the view functions will not be generating hiccup for the just-deleted item obviously but, other than this, the hiccup computed \"this time\" will be the same as \"last time\". ( defn items-view [] ( let [ items ( subscribe [ :query-items ])] ;; source items from app state [ :div ( map item-render @ items )])) ;; assume item-render already written Notice how items is \"sourced\" from \"app state\" via re-frame.core/subscribe . It is called with a vector argument, and the first element of that vector is a query-id which identifies the \"materialised view\" required by the view. Note: subscribe queries can be parameterised. So, in real-world apps you might have this: (subscribe [:items \"blue\"]) The vector identifies, first, the query, and then supplies further arguments. You could think of that as representing select * from Items where colour=\"blue\" . Except there's no SQL available and you would be the one to implement the more sophisticated query-fn capable of handling the \"where\" argument. More in later tutorials.","title":"Domino 5 - View"},{"location":"dominoes-30k/#domino-6-dom","text":"The hiccup returned by the view function is made into real browser DOM by Reagent/React. No code from you required. Just happens. The DOM computed \"this time\" will be the same as \"last time\", except for the absence of DOM for the deleted item, so the mutation will be to remove those now-missing DOM nodes from the browser.","title":"Domino 6 - DOM"},{"location":"dominoes-30k/#3-4-5-6-summary","text":"The key point to understand about our 3-4-5-6 example is: a change to app state ... triggers query functions to rerun ... which triggers view functions to rerun which causes modified browser DOM Boom, boom, boom go the dominoes. It is a reactive data flow.","title":"3-4-5-6 Summary"},{"location":"dominoes-30k/#aaaaand-were-done","text":"At this point, the re-frame app returns to a quiescent state, waiting for the next event.","title":"Aaaaand we're done"},{"location":"dominoes-30k/#two-sub-cascades","text":"You might have noticed that there's actually two sub-cascades 1-2-3 and 4-5-6, and they have a similar structure. In each, it is the second to last domino which computes \"data descriptions\" of the changes required, and it is the last domino which does the dirty work and actions these descriptions. But you seldom need to worry yourself about the dirty work dominos. re-frame mostly takes care of them for you. One is only fruitful at the price of being rich in oppositions -- Nietzsche, Twilight of the Idols Pragmatically, in functional systems, the most interesting part is how and when you arrange to not be pure.","title":"Two Sub-Cascades"},{"location":"dominoes-live/","text":"Forget overviews from 60,000 feet or 30,000 feet. Now we're at 0 feet. We're writing code for a real app - live, in this document. Which App? \u00b6 The \"simple\" one. Within the re-frame repository's /examples folder is an app called /simple . It has 70 lines of code in a single namespace . Below, we'll look at all 70 lines. Below, you should see the app running live. Try changing the display colour to magenta , #f00 or #02a6f2 . The live application should start here ... Doesn't work? Maybe try disabling your adblocker for this site. When you change the live code on this page, the app will change. This live coding is powered by SCI . The Namespace \u00b6 Within our single namespace (of 70 lines), we'll need to use both reagent and re-frame . So, at the top, within the ns we'll need to require them: (ns re-frame.simple (:require [reagent.core :as reagent] [reagent.dom :as rdom] [re-frame.core :as rf])) Live Code Fragment Above, the code is provided in an editor. You can change the code if you want. And then press the \"eval\" button. Below the editor, a green-backgrounded box shows if the code was evaluated successfully (a tick is shown) and, if so, the value of that evaluation. of the code. In this case, evaluating a ns gives nil , which is not very interesting. The Data Schema \u00b6 Now, normally, I'd strongly recommend that you write a quality schema for your application state (the data stored in app-db ). But, here, we'll cut that corner to minimise cognitive load. But we can't cut it completely. You'll still need an informal description, and here it is ... app-db will contain a two-key map like this: { :time ( js/Date. ) ;; current time for display :time-color \"#f88\" } ;; the colour in which the time should be shown Event Dispatch \u00b6 Events are data. re-frame uses a vector format for events. For example: [ :time-color-change \"red\" ] The first element in the vector is a keyword that identifies the kind of event . Further elements are optional and can provide additional data associated with the event. The additional value above, \"red\" , is presumably the colour. Here are some other example events: [ :admit-to-being-satoshi false ] [ :dressing/put-pants-on \"velour flares\" { :method :left-leg-first :belt false }] For non-trivial applications, the kind keyword will be namespaced, as it is in the 2nd example. dispatch \u00b6 To send an event, call dispatch with the event vector as the argument. ( dispatch [ :kind-of-event value1 value2 ]) For our simple app, we do this ... (defn dispatch-timer-event ;; <-- defining a function [] ;; <-- no args (let [now (js/Date.)] ;; <-- obtain the current time (rf/dispatch [:timer now]))) ;; <-- dispatch an event Notes: defn returns nothing of interest, you can ignore the green box below the code. the current time is obtained with (js/Date.) which is the equivalent of new Date() in javascript. Within the ns at the top of the namespace, re-frame is aliased as rf via [re-frame.core :as rf] . So, the symbol rf/dispatch is a reference to the function dispatch in the re-frame API. (defonce do-timer (js/setInterval dispatch-timer-event 1000)) Notes: setInterval is used to call dispatch-timer-event every second defonce is like def , it instantiates a symbol and binds a value to it. But the evaluation won't happen if the symbol ( do-timer in this case) already exists. This stops a new timer from getting created every time we hot-reload the code in a namespace. This would be important in a dev environment where we were editing the namespace and our changes were causing it to be recompiled and hot-code reloaded. A timer is an unusual source of events. Usually, it is an app's UI widgets that dispatch events (in response to user actions), or an HTTP POST's on-success handler or a websocket which gets a new packet. So, this \"simple\" app is unusual. Moving on. After dispatch \u00b6 dispatch puts an event onto a queue for processing. So, an event is not processed synchronously, like a function call. The processing happens later - asynchronously. Very soon, but not now. The consumer of the queue is the re-frame router which looks after the event's processing. The router will: inspect the 1st element of an event vector look up the event handler (function) registered for this kind of event call this event handler (function) with the necessary arguments Our job, then, is to register an event handler function for each kind of event, including this :timer event. Event Handlers \u00b6 Collectively, event handlers provide the control logic in a re-frame application. In this application, three kinds of event are dispatched: :initialize - dispatch once, when the program boots up :time-color-change - dispatched whenever the user changes the colour text field :timer - dispatched once a second via a timer Having 3 events means we'll be registering 3 event handlers. Registering Event Handlers \u00b6 Event handler functions: take two arguments coeffects and event return effects Conceptually, you can think of the argument coeffects as being \"the current state of the world\". And you can think of event handlers as computing how the world should be changed by the arriving event. They return (as data) how the world should be changed by the event - the side effects of the event. Event handlers can be registered in two ways: reg-event-fx reg-event-db One ends in -fx and the other in -db . reg-event-fx can take many coeffects and can return many effects reg-event-db allows you to write simpler handlers for the common case where you want them to take only one coeffect - the current app state - and return one effect - the updated app state. Many vs One. Because of its simplicity, we'll be using the latter one here: reg-event-db . reg-event-db \u00b6 We register event handlers using re-frame's API: ( rf/reg-event-db ;; <-- the re-frame API function to use :the-event-id ;; <-- the event id the-event-handler-fn ) ;; <-- the handler function The handler function you provide should expect two arguments: db - the current application state (the map value contained in app-db ) e - the event vector (given to dispatch ) So, your handler function will have a signature like this: (fn [db e] ...) . These event handlers must compute and return the new state of the application, which means they return a modified version of db . :timer \u00b6 (rf/reg-event-db :timer (fn [db [_ new-time]] ;; notice how we destructure the event vector (assoc db :time new-time))) ;; compute and return the new application state Notes: the event (2nd parameter) will be like [:timer a-js-time] sequence destructuring is used to extract the 2nd element of that event vector (ignores first with _ ) db is a map, containing two keys (see description above) this handler computes a new application state from db , and returns it it just assocs in the new-time value :initialize \u00b6 Once on startup, application state must be initialised. We want to put a sensible value into app-db , which starts out containing an empty map {} . A single (dispatch [:initialize]) will happen early in the app's life (more on this below), and we need to register an event handler for it. This event handler is slightly unusual because it ignores both of its arguments. There's nothing in the event vector which it needs. Nor is the existing value in db . It just wants to plonk a completely new value into app-db (rf/reg-event-db ;; sets up initial application state :initialize (fn [ _ _ ] ;; arguments not important, so use _ {:time (js/Date.) ;; returned value put into app-db :time-color \"orange\"})) ;; so the app state will be a map with two keys For comparison, here's how we could have written this if we did care about the existing value in db : ( rf/reg-event-db :initialize ( fn [ db _ ] ;; we use db this time, so name it ( -> db ;; db is initially just {} ( assoc :time ( js/Date. )) ( assoc :time-color \"orange\" ))) :time-color-change \u00b6 When the user enters a new colour value (into the input field) the view will (dispatch [:time-color-change new-colour]) (more on this below). (rf/reg-event-db :time-color-change (fn [db [_ new-color-value]] (assoc db :time-color new-color-value))) ;; compute and return the new application state Notes: it updates db to contain the new colour, provided as the 2nd element of the event Effect Handlers \u00b6 Domino 3 actions the effects returned by event handlers. In this \"simple\" application, our event handlers are implicitly returning only one effect: \"update application state\". This particular effect is accomplished by a re-frame-supplied effect handler. So, there's nothing for us to do for this domino. We are using a standard re-frame effect handler. And this is not unusual. You seldom write effect handlers. But it is covered in a later tutorial. Subscription Handlers \u00b6 Subscription handlers, or query functions, take application state as an argument and run a query over it, returning something called a \"materialised view\" of that application state. When the application state changes, subscription functions are re-run by re-frame, to compute new values (new materialised views). Ultimately, the data returned by these query functions flow through into the view functions (Domino 5). One subscription can source data from other subscriptions. So it is possible to create a tree structure of data flow. The Views (Domino 5) are the leaves of this tree. The tree's root is app-db and the intermediate nodes between the two are computations being performed by the query functions of Domino 4. Now, the two subscriptions below are trivial. They just extract part of the application state and return it. So, there's virtually no computation - the materialised view they produce is the same as that stored in app-db . A more interesting tree of subscriptions, and more explanation, can be found in the todomvc example. reg-sub \u00b6 reg-sub associates a query id with a function that computes that query, like this: ( rf/reg-sub :some-query-id ;; query id (used later in subscribe) a-query-fn ) ;; the function which will compute the query Later, a view function (domino 5) will subscribe to a query like this: (subscribe [:some-query-id]) , and a-query-fn will be used to perform the query over the application state. Each time application state changes, a-query-fn will be called again to compute a new materialised view (a new computation over app-db ) and that new value will be given to all view functions that are subscribed to :some-query-id . These view functions will then be called to compute the new DOM state (because the views depend on query results that have changed). Along this reactive chain of dependencies, re-frame will ensure the necessary calls are made, at the right time. Here's the code for defining our 2 subscription handlers: (rf/reg-sub :time (fn [db _] ;; db is current app state. 2nd unused param is the query vector (:time db))) ;; return a query computation over the application state (rf/reg-sub :time-color (fn [db _] (:time-color db))) Both of these queries are trivial. They are known as \"accessors\", or layer 2, subscriptions. More on that soon. View Functions \u00b6 view functions compute Hiccup. They are \"Data in, Hiccup out\" and they are Reagent components. A SPA will have lots of view functions, and collectively, they render the app's UI. Subscribing \u00b6 To render a hiccup representation of some part of the app state, view functions must query for that part of app-db , by using subscribe . subscribe is used like this: ( rf/subscribe [ query-id some optional query parameters ]) So subscribe takes one argument, assumed to be a vector. The first element in the vector identifies the query, and the other elements are optional query parameters. With a traditional database, a query might be: select * from customers where name = \"blah\" In re-frame, that would look like: (subscribe [:customer-query \"blah\"]) , which would return a ratom holding the customer state (a value that might change over time!). Rookie Mistake Because subscriptions return a ratom (a Reagent atom), they must always be dereferenced to obtain the value (using deref or the reader macro @ ). Forgetting to do this is a recurring papercut for newbies. The View Functions \u00b6 This view function renders the clock: (defn clock [] (let [colour @(rf/subscribe [:time-color]) time (some-> @(rf/subscribe [:time]) .toTimeString (clojure.string/split \" \") first)] [:div.example-clock {:style {:color colour}} time])) As you can see, it uses subscribe twice to obtain two pieces of data from app-db . If either value changes, Reagent will automatically re-run this view function, computing new hiccup, which means new DOM. Using the power of sci , we can render just the clock component: (rdom/render [clock] (js/document.getElementById \"clock\")) When an event handler changes a value in app-db , clock will rerender. Try it. Edit the following code to remove the comment, and then press the Eval button to execute it. Notice the change in the clock above. Experiment. (comment (rf/dispatch [:time-color-change \"green\"])) And this view function renders the input field: (defn color-input [] (let [gettext (fn [e] (-> e .-target .-value)) emit (fn [e] (rf/dispatch [:time-color-change (gettext e)]))] [:div.color-input \"Display color: \" [:input {:type \"text\" :style {:border \"1px solid #CCC\" } :value @(rf/subscribe [:time-color]) ;; subscribe :on-change emit}]])) ;; <--- Notice how it does BOTH a subscribe to obtain the current value AND a dispatch to say when it has changed (look for emit ). It is very common for view functions to render event-dispatching functions into the DOM. The user's interaction with the UI is usually a large source of events. Notice also how we use @ in front of subscribe to obtain the value out of the subscription. It is almost as if the subscription is an atom holding a value (which can change over time). We can render the color-input as any other reagent component: (rdom/render [color-input] (js/document.getElementById \"color-input\")) And then there's a parent view to arrange the others. It contains no subscriptions or dispatching of its own: (defn ui [] [:div [:h1 \"The time is now:\"] [clock] [color-input]]) view functions form a hierarchy, often with data flowing from parent to child via arguments (props in React). So, not every view needs a subscription if the values passed in from a parent component are sufficient. view functions never directly access app-db . Data is only ever sourced via subscriptions. Kick Starting The App \u00b6 Below, the function run is called to kick off the application once the HTML page has loaded. It has two tasks: Load the initial application state Load the GUI by \"mounting\" the root-level view - in our case, ui - onto an existing DOM element (with id app ). (defn mount-ui [] (rdom/render [ui] ;; mount the application's ui (js/document.getElementById \"dominoes-live-app\"))) (defn run [] (rf/dispatch-sync [:initialize]) ;; puts a value into application state (mount-ui)) When it comes to establishing initial application state, you'll notice the use of dispatch-sync , rather than dispatch . This is a simplifying cheat which ensures that a correct structure exists in app-db before any subscriptions or event handlers run. After run is called, the app passively waits for events . Nothing happens without an event . (run) The run function renders the app in the DOM element whose id is dominoes-live-app : this DOM element is located at the top of the page. This is the element we used to show how the app looks at the top of this page To save you the trouble of scrolling up to the top of the page, I decided to render the whole app as a reagent element, just here: (rdom/render [ui] (js/document.getElementById \"dominoes-live-app-2\")) T-Shirt Unlocked \u00b6 Good news. If you've read this far, your insider's T-shirt will be arriving soon - it will feature turtles, xkcd and something about \"data all the way down\". But we're still working on the hilarious caption bit. Open a repo issue with a suggestion.","title":"Live"},{"location":"dominoes-live/#which-app","text":"The \"simple\" one. Within the re-frame repository's /examples folder is an app called /simple . It has 70 lines of code in a single namespace . Below, we'll look at all 70 lines. Below, you should see the app running live. Try changing the display colour to magenta , #f00 or #02a6f2 . The live application should start here ... Doesn't work? Maybe try disabling your adblocker for this site. When you change the live code on this page, the app will change. This live coding is powered by SCI .","title":"Which App?"},{"location":"dominoes-live/#the-namespace","text":"Within our single namespace (of 70 lines), we'll need to use both reagent and re-frame . So, at the top, within the ns we'll need to require them: (ns re-frame.simple (:require [reagent.core :as reagent] [reagent.dom :as rdom] [re-frame.core :as rf])) Live Code Fragment Above, the code is provided in an editor. You can change the code if you want. And then press the \"eval\" button. Below the editor, a green-backgrounded box shows if the code was evaluated successfully (a tick is shown) and, if so, the value of that evaluation. of the code. In this case, evaluating a ns gives nil , which is not very interesting.","title":"The Namespace"},{"location":"dominoes-live/#the-data-schema","text":"Now, normally, I'd strongly recommend that you write a quality schema for your application state (the data stored in app-db ). But, here, we'll cut that corner to minimise cognitive load. But we can't cut it completely. You'll still need an informal description, and here it is ... app-db will contain a two-key map like this: { :time ( js/Date. ) ;; current time for display :time-color \"#f88\" } ;; the colour in which the time should be shown","title":"The Data Schema"},{"location":"dominoes-live/#event-dispatch","text":"Events are data. re-frame uses a vector format for events. For example: [ :time-color-change \"red\" ] The first element in the vector is a keyword that identifies the kind of event . Further elements are optional and can provide additional data associated with the event. The additional value above, \"red\" , is presumably the colour. Here are some other example events: [ :admit-to-being-satoshi false ] [ :dressing/put-pants-on \"velour flares\" { :method :left-leg-first :belt false }] For non-trivial applications, the kind keyword will be namespaced, as it is in the 2nd example.","title":"Event Dispatch"},{"location":"dominoes-live/#dispatch","text":"To send an event, call dispatch with the event vector as the argument. ( dispatch [ :kind-of-event value1 value2 ]) For our simple app, we do this ... (defn dispatch-timer-event ;; <-- defining a function [] ;; <-- no args (let [now (js/Date.)] ;; <-- obtain the current time (rf/dispatch [:timer now]))) ;; <-- dispatch an event Notes: defn returns nothing of interest, you can ignore the green box below the code. the current time is obtained with (js/Date.) which is the equivalent of new Date() in javascript. Within the ns at the top of the namespace, re-frame is aliased as rf via [re-frame.core :as rf] . So, the symbol rf/dispatch is a reference to the function dispatch in the re-frame API. (defonce do-timer (js/setInterval dispatch-timer-event 1000)) Notes: setInterval is used to call dispatch-timer-event every second defonce is like def , it instantiates a symbol and binds a value to it. But the evaluation won't happen if the symbol ( do-timer in this case) already exists. This stops a new timer from getting created every time we hot-reload the code in a namespace. This would be important in a dev environment where we were editing the namespace and our changes were causing it to be recompiled and hot-code reloaded. A timer is an unusual source of events. Usually, it is an app's UI widgets that dispatch events (in response to user actions), or an HTTP POST's on-success handler or a websocket which gets a new packet. So, this \"simple\" app is unusual. Moving on.","title":"dispatch"},{"location":"dominoes-live/#after-dispatch","text":"dispatch puts an event onto a queue for processing. So, an event is not processed synchronously, like a function call. The processing happens later - asynchronously. Very soon, but not now. The consumer of the queue is the re-frame router which looks after the event's processing. The router will: inspect the 1st element of an event vector look up the event handler (function) registered for this kind of event call this event handler (function) with the necessary arguments Our job, then, is to register an event handler function for each kind of event, including this :timer event.","title":"After dispatch"},{"location":"dominoes-live/#event-handlers","text":"Collectively, event handlers provide the control logic in a re-frame application. In this application, three kinds of event are dispatched: :initialize - dispatch once, when the program boots up :time-color-change - dispatched whenever the user changes the colour text field :timer - dispatched once a second via a timer Having 3 events means we'll be registering 3 event handlers.","title":"Event Handlers"},{"location":"dominoes-live/#registering-event-handlers","text":"Event handler functions: take two arguments coeffects and event return effects Conceptually, you can think of the argument coeffects as being \"the current state of the world\". And you can think of event handlers as computing how the world should be changed by the arriving event. They return (as data) how the world should be changed by the event - the side effects of the event. Event handlers can be registered in two ways: reg-event-fx reg-event-db One ends in -fx and the other in -db . reg-event-fx can take many coeffects and can return many effects reg-event-db allows you to write simpler handlers for the common case where you want them to take only one coeffect - the current app state - and return one effect - the updated app state. Many vs One. Because of its simplicity, we'll be using the latter one here: reg-event-db .","title":"Registering Event Handlers"},{"location":"dominoes-live/#reg-event-db","text":"We register event handlers using re-frame's API: ( rf/reg-event-db ;; <-- the re-frame API function to use :the-event-id ;; <-- the event id the-event-handler-fn ) ;; <-- the handler function The handler function you provide should expect two arguments: db - the current application state (the map value contained in app-db ) e - the event vector (given to dispatch ) So, your handler function will have a signature like this: (fn [db e] ...) . These event handlers must compute and return the new state of the application, which means they return a modified version of db .","title":"reg-event-db"},{"location":"dominoes-live/#timer","text":"(rf/reg-event-db :timer (fn [db [_ new-time]] ;; notice how we destructure the event vector (assoc db :time new-time))) ;; compute and return the new application state Notes: the event (2nd parameter) will be like [:timer a-js-time] sequence destructuring is used to extract the 2nd element of that event vector (ignores first with _ ) db is a map, containing two keys (see description above) this handler computes a new application state from db , and returns it it just assocs in the new-time value","title":":timer"},{"location":"dominoes-live/#initialize","text":"Once on startup, application state must be initialised. We want to put a sensible value into app-db , which starts out containing an empty map {} . A single (dispatch [:initialize]) will happen early in the app's life (more on this below), and we need to register an event handler for it. This event handler is slightly unusual because it ignores both of its arguments. There's nothing in the event vector which it needs. Nor is the existing value in db . It just wants to plonk a completely new value into app-db (rf/reg-event-db ;; sets up initial application state :initialize (fn [ _ _ ] ;; arguments not important, so use _ {:time (js/Date.) ;; returned value put into app-db :time-color \"orange\"})) ;; so the app state will be a map with two keys For comparison, here's how we could have written this if we did care about the existing value in db : ( rf/reg-event-db :initialize ( fn [ db _ ] ;; we use db this time, so name it ( -> db ;; db is initially just {} ( assoc :time ( js/Date. )) ( assoc :time-color \"orange\" )))","title":":initialize"},{"location":"dominoes-live/#time-color-change","text":"When the user enters a new colour value (into the input field) the view will (dispatch [:time-color-change new-colour]) (more on this below). (rf/reg-event-db :time-color-change (fn [db [_ new-color-value]] (assoc db :time-color new-color-value))) ;; compute and return the new application state Notes: it updates db to contain the new colour, provided as the 2nd element of the event","title":":time-color-change"},{"location":"dominoes-live/#effect-handlers","text":"Domino 3 actions the effects returned by event handlers. In this \"simple\" application, our event handlers are implicitly returning only one effect: \"update application state\". This particular effect is accomplished by a re-frame-supplied effect handler. So, there's nothing for us to do for this domino. We are using a standard re-frame effect handler. And this is not unusual. You seldom write effect handlers. But it is covered in a later tutorial.","title":"Effect Handlers"},{"location":"dominoes-live/#subscription-handlers","text":"Subscription handlers, or query functions, take application state as an argument and run a query over it, returning something called a \"materialised view\" of that application state. When the application state changes, subscription functions are re-run by re-frame, to compute new values (new materialised views). Ultimately, the data returned by these query functions flow through into the view functions (Domino 5). One subscription can source data from other subscriptions. So it is possible to create a tree structure of data flow. The Views (Domino 5) are the leaves of this tree. The tree's root is app-db and the intermediate nodes between the two are computations being performed by the query functions of Domino 4. Now, the two subscriptions below are trivial. They just extract part of the application state and return it. So, there's virtually no computation - the materialised view they produce is the same as that stored in app-db . A more interesting tree of subscriptions, and more explanation, can be found in the todomvc example.","title":"Subscription Handlers"},{"location":"dominoes-live/#reg-sub","text":"reg-sub associates a query id with a function that computes that query, like this: ( rf/reg-sub :some-query-id ;; query id (used later in subscribe) a-query-fn ) ;; the function which will compute the query Later, a view function (domino 5) will subscribe to a query like this: (subscribe [:some-query-id]) , and a-query-fn will be used to perform the query over the application state. Each time application state changes, a-query-fn will be called again to compute a new materialised view (a new computation over app-db ) and that new value will be given to all view functions that are subscribed to :some-query-id . These view functions will then be called to compute the new DOM state (because the views depend on query results that have changed). Along this reactive chain of dependencies, re-frame will ensure the necessary calls are made, at the right time. Here's the code for defining our 2 subscription handlers: (rf/reg-sub :time (fn [db _] ;; db is current app state. 2nd unused param is the query vector (:time db))) ;; return a query computation over the application state (rf/reg-sub :time-color (fn [db _] (:time-color db))) Both of these queries are trivial. They are known as \"accessors\", or layer 2, subscriptions. More on that soon.","title":"reg-sub"},{"location":"dominoes-live/#view-functions","text":"view functions compute Hiccup. They are \"Data in, Hiccup out\" and they are Reagent components. A SPA will have lots of view functions, and collectively, they render the app's UI.","title":"View Functions"},{"location":"dominoes-live/#subscribing","text":"To render a hiccup representation of some part of the app state, view functions must query for that part of app-db , by using subscribe . subscribe is used like this: ( rf/subscribe [ query-id some optional query parameters ]) So subscribe takes one argument, assumed to be a vector. The first element in the vector identifies the query, and the other elements are optional query parameters. With a traditional database, a query might be: select * from customers where name = \"blah\" In re-frame, that would look like: (subscribe [:customer-query \"blah\"]) , which would return a ratom holding the customer state (a value that might change over time!). Rookie Mistake Because subscriptions return a ratom (a Reagent atom), they must always be dereferenced to obtain the value (using deref or the reader macro @ ). Forgetting to do this is a recurring papercut for newbies.","title":"Subscribing"},{"location":"dominoes-live/#the-view-functions","text":"This view function renders the clock: (defn clock [] (let [colour @(rf/subscribe [:time-color]) time (some-> @(rf/subscribe [:time]) .toTimeString (clojure.string/split \" \") first)] [:div.example-clock {:style {:color colour}} time])) As you can see, it uses subscribe twice to obtain two pieces of data from app-db . If either value changes, Reagent will automatically re-run this view function, computing new hiccup, which means new DOM. Using the power of sci , we can render just the clock component: (rdom/render [clock] (js/document.getElementById \"clock\")) When an event handler changes a value in app-db , clock will rerender. Try it. Edit the following code to remove the comment, and then press the Eval button to execute it. Notice the change in the clock above. Experiment. (comment (rf/dispatch [:time-color-change \"green\"])) And this view function renders the input field: (defn color-input [] (let [gettext (fn [e] (-> e .-target .-value)) emit (fn [e] (rf/dispatch [:time-color-change (gettext e)]))] [:div.color-input \"Display color: \" [:input {:type \"text\" :style {:border \"1px solid #CCC\" } :value @(rf/subscribe [:time-color]) ;; subscribe :on-change emit}]])) ;; <--- Notice how it does BOTH a subscribe to obtain the current value AND a dispatch to say when it has changed (look for emit ). It is very common for view functions to render event-dispatching functions into the DOM. The user's interaction with the UI is usually a large source of events. Notice also how we use @ in front of subscribe to obtain the value out of the subscription. It is almost as if the subscription is an atom holding a value (which can change over time). We can render the color-input as any other reagent component: (rdom/render [color-input] (js/document.getElementById \"color-input\")) And then there's a parent view to arrange the others. It contains no subscriptions or dispatching of its own: (defn ui [] [:div [:h1 \"The time is now:\"] [clock] [color-input]]) view functions form a hierarchy, often with data flowing from parent to child via arguments (props in React). So, not every view needs a subscription if the values passed in from a parent component are sufficient. view functions never directly access app-db . Data is only ever sourced via subscriptions.","title":"The View Functions"},{"location":"dominoes-live/#kick-starting-the-app","text":"Below, the function run is called to kick off the application once the HTML page has loaded. It has two tasks: Load the initial application state Load the GUI by \"mounting\" the root-level view - in our case, ui - onto an existing DOM element (with id app ). (defn mount-ui [] (rdom/render [ui] ;; mount the application's ui (js/document.getElementById \"dominoes-live-app\"))) (defn run [] (rf/dispatch-sync [:initialize]) ;; puts a value into application state (mount-ui)) When it comes to establishing initial application state, you'll notice the use of dispatch-sync , rather than dispatch . This is a simplifying cheat which ensures that a correct structure exists in app-db before any subscriptions or event handlers run. After run is called, the app passively waits for events . Nothing happens without an event . (run) The run function renders the app in the DOM element whose id is dominoes-live-app : this DOM element is located at the top of the page. This is the element we used to show how the app looks at the top of this page To save you the trouble of scrolling up to the top of the page, I decided to render the whole app as a reagent element, just here: (rdom/render [ui] (js/document.getElementById \"dominoes-live-app-2\"))","title":"Kick Starting The App"},{"location":"dominoes-live/#t-shirt-unlocked","text":"Good news. If you've read this far, your insider's T-shirt will be arriving soon - it will feature turtles, xkcd and something about \"data all the way down\". But we're still working on the hilarious caption bit. Open a repo issue with a suggestion.","title":"T-Shirt Unlocked"},{"location":"event-handling-infographic/","text":"","title":"Infographics"},{"location":"flow-mechanics/","text":"In a rush? You can get away with skipping this page on the first pass. This tutorial explains the underlying reactive mechanism used in dominoes 4-5-6. It goes on to introduce re-frame.core/reg-sub-raw . On Flow \u00b6 Arguments from authority ... Everything flows, nothing stands still. (Panta rhei) No man ever steps in the same river twice for it's not the same river and he's not the same man. Heraclitus 500 BC . Who, being Greek, had never seen a frozen river. alt version . Think of an experience from your childhood. Something you remember clearly, something you can see, feel, maybe even smell, as if you were really there. After all you really were there at the time, weren\u2019t you? How else could you remember it? But here is the bombshell: you weren\u2019t there. Not a single atom that is in your body today was there when that event took place .... Matter flows from place to place and momentarily comes together to be you. Whatever you are, therefore, you are not the stuff of which you are made. If that does not make the hair stand up on the back of your neck, read it again until it does, because it is important. Steve Grand How Flow Happens In Reagent \u00b6 To implement a reactive flow, Reagent provides a ratom and a reaction . re-frame uses both of these building blocks, so let's now make sure we understand them. ratoms behave just like normal ClojureScript atoms. You can swap! and reset! them, watch them, etc. From a ClojureScript perspective, the purpose of an atom is to hold mutable data. From a re-frame perspective, we'll tweak that paradigm slightly and view a ratom as having a value that changes over time. Seems like a subtle distinction, I know, but because of it, re-frame sees a ratom as a Signal. A Signal is a value that changes over time. So it is a stream of values. Each time a ratom gets reset! that's a new value in the stream. The 2nd building block, reaction , acts a bit like a function. It's a macro which wraps some computation (a block of code) and returns a ratom holding the result of that computation . The magic thing about a reaction is that the computation it wraps will be automatically re-run whenever 'its inputs' change, producing a new output (return) value. Eh, how? Well, the computation is just a block of code, and if that code dereferences one or more ratoms , it will be automatically re-run (recomputing a new return value) whenever any of these dereferenced ratoms change. To put that yet another way, a reaction detects a computation's input Signals (aka input ratoms ) and it will watch them, and when, later, it detects a change in one of them, it will re-run that computation, and it will reset! the new result of that computation into the ratom originally returned. So, the ratom returned by a reaction is itself a Signal. Its value will change over time when the computation is re-run. So, via the interplay between ratoms and reactions , values 'flow' into computations and out again, and then into further computations, etc. \"Values\" flow (propagate) through the Signal graph. But this Signal graph must be without cycles, because cycles cause mayhem! re-frame achieves a unidirectional flow. Right, so that was a lot of words. Some code to clarify: ( ns example1 ( :require-macros [ reagent.ratom :refer [ reaction ]]) ;; reaction is a macro ( :require [ reagent.core :as reagent ])) ( def app-db ( reagent/atom { :a 1 })) ;; our root ratom (signal) ( def ratom2 ( reaction { :b ( :a @ app-db )})) ;; reaction wraps a computation, returns a signal ( def ratom3 ( reaction ( condp = ( :b @ ratom2 ) ;; reaction wraps another computation 0 \"World\" 1 \"Hello\" ))) ;; Notice that both computations above involve de-referencing a ratom: ;; - app-db in one case ;; - ratom2 in the other ;; Notice that both reactions above return a ratom. ;; Those returned ratoms hold the (time varying) value of the computations. ( println @ ratom2 ) ;; ==> {:b 1} ;; a computed result, involving @app-db ( println @ ratom3 ) ;; ==> \"Hello\" ;; a computed result, involving @ratom2 ( reset! app-db { :a 0 }) ;; this change to app-db, triggers re-computation ;; of ratom2 ;; which, in turn, causes a re-computation of ratom3 ( println @ ratom2 ) ;; ==> {:b 0} ;; ratom2 is result of {:b (:a @app-db)} ( println @ ratom3 ) ;; ==> \"World\" ;; ratom3 is automatically updated too. So, in FRP-ish terms, a reaction will produce a \"stream\" of values over time (it is a Signal), accessible via the ratom it returns. Components (view functions) \u00b6 When using Reagent, your primary job is to write one or more components . This is the view layer. Think about components as pure functions - data in, Hiccup out. Hiccup is ClojureScript data structures which represent DOM. Here's a trivial component: ( defn greet [] [ :div \"Hello ratoms and reactions\" ]) And if we call it: ( greet ) ;; ==> [:div \"Hello ratoms and reactions\"] You'll notice that our component is a regular Clojure function, nothing special. In this case, it takes no parameters and it returns a ClojureScript vector (formatted as Hiccup). Here is a slightly more interesting (parameterised) component (function): ( defn greet ;; greet has a parameter now [ name ] ;; 'name' is a ratom holding a string [ :div \"Hello \" @ name ]) ;; dereference 'name' to extract the contained value ;; create a ratom, containing a string ( def n ( reagent/atom \"re-frame\" )) ;; call our `component` function, passing in a ratom ( greet n ) ;; ==> [:div \"Hello \" \"re-frame\"] returns a vector So components are easy - at core they are a render function which turns data into Hiccup (which will later become DOM). Now, let's introduce reaction into this mix. On the one hand, I'm complicating things by doing this, because Reagent allows you to be ignorant of the mechanics I'm about to show you. (It invisibly wraps your components in a reaction allowing you to be blissfully ignorant of how the magic happens.) On the other hand, it is useful to understand exactly how the Reagent Signal graph is wired. ( defn greet ;; a component - data in, Hiccup out. [ name ] ;; name is a ratom [ :div \"Hello \" @ name ]) ;; dereference name here, to extract the value within ( def n ( reagent/atom \"re-frame\" )) ;; The computation '(greet n)' returns Hiccup which is stored into 'hiccup-ratom' ( def hiccup-ratom ( reaction ( greet n ))) ;; <-- use of reaction !!! ;; what is the result of the initial computation ? ( println @ hiccup-ratom ) ;; ==> [:div \"Hello \" \"re-frame\"] ;; returns hiccup (a vector of stuff) ;; now change 'n' ;; 'n' is an input Signal for the reaction above. ;; Warning: 'n' is not an input signal because it is a parameter. Rather, it is ;; because 'n' is dereferenced within the execution of the reaction's computation. ;; reaction notices what ratoms are dereferenced in its computation, and watches ;; them for changes. ( reset! n \"blah\" ) ;; n changes ;; The reaction above will notice the change to 'n' ... ;; ... and will re-run its computation ... ;; ... which will have a new \"return value\"... ;; ... which will be \"reset!\" into \"hiccup-ratom\" ( println @ hiccup-ratom ) ;; ==> [:div \"Hello \" \"blah\"] ;; yep, there's the new value So, as n changes value over time (via a reset! ), the output of the computation (greet n) changes, which in turn means that the value in hiccup-ratom changes. Both n and hiccup-ratom are FRP Signals. The Signal graph we created causes data to flow from n into hiccup-ratom . Derived Data, flowing. Truth Interlude \u00b6 I haven't been entirely straight with you: Reagent re-runs reactions (re-computations) via requestAnimationFrame. So a re-computation happens about 16ms after an input Signals change is detected, or after the current thread of processing finishes, whichever is the greater. So if you are in a REPL and you run the lines of code above one after the other too quickly, you might not see the re-computation done immediately after n gets reset!, because the next animationFrame hasn't run (yet). But you could add a (reagent.core/flush) after the reset! to force re-computation to happen straight away. reaction doesn't actually return a ratom . But it returns something that has ratom-nature, so we'll happily continue believing it is a ratom and no harm will come to us. On with the rest of my lies and distortions... reg-sub-raw \u00b6 This low level part of the API provides a way to register a subscription handler - so the intent is similar to reg-sub . You use it like other registration functions: ( re-frame.core/reg-sub-raw ;; it is part of the API :query-id ;; later use (subscribe [:query-id]) some-fn ) ;; this function provides the reactive stream The interesting bit is how some-fn is written. Here's an example: ( defn some-fn [ app-db event ] ;; app-db is not a value, it is a reagent/atom ( reaction ( get-in @ app-db [ :some :path ]))) ;; returns a reaction Notice: app-db is a reagent/atom. It is not a value like reg-sub gets. it returns a reaction which does a computation. It does not return a value like reg-sub does. Within that reaction app-db is deref-ed (see use of @ ) As a result of point 3, each time app-db changes, the wrapped reaction will rerun. app-db is an input signal to that reaction . Unlike reg-sub , there is no 3-arity version of reg-sub-raw , so there's no way for you to provide an input signals function. Instead, even simpler, you can just use subscribe within the reaction itself. For example: ( defn some-fn [ app-db event ] ( reaction ( let [ a-path-element @ ( subscribe [ :get-path-part ])] ;; <-- subscribe used here ( get-in @ app-db [ :some a-path-element ])))) As you can see, this reaction has two input signals: app-db and (subscribe [:get-path-part]) . If either changes, the reaction will rerun. In some cases, the returned reaction might not even use app-db and, instead, it might only use subscribe to provide input signals. In that case, the registered subscription would belong to \"Layer 3\" of the signal graph (discussed in earlier tutorials). Remember to deref any use of app-db and subscribe . It is a rookie mistake to forget. I do it regularly. Instead of using reaction (a macro), you can use reagent/make-reaction (a utility function) which gives you the additional ability to attach an :on-dispose handler to the returned reaction, allowing you to do cleanup work when the subscription is no longer needed. See an example of using :on-dispose here Example reg-sub-raw \u00b6 The following use of reg-sub can be found in the todomvc example : ( reg-sub :visible-todos ;; signal function - returns a vector of two input signals ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) ;; the computation function - 1st arg is a 2-vector of values ( fn [[ todos showing ] _ ] ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) we could rewrite this use of reg-sub using reg-sub-raw like this: ( reg-sub-raw :visible-todos ( fn [ app-db event ] ;; app-db not used, name shown for clarity ( reaction ;; wrap the computation in a reaction ( let [ todos @ ( subscribe [ :todos ]) ;; input signal #1 showing @ ( subscribe [ :showing ]) ;; input signal #2 filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) A view could do (subscribe [:visible-todos]) and never know which of the two variations above was used. Same result delivered.","title":"Flow Mechanics"},{"location":"flow-mechanics/#on-flow","text":"Arguments from authority ... Everything flows, nothing stands still. (Panta rhei) No man ever steps in the same river twice for it's not the same river and he's not the same man. Heraclitus 500 BC . Who, being Greek, had never seen a frozen river. alt version . Think of an experience from your childhood. Something you remember clearly, something you can see, feel, maybe even smell, as if you were really there. After all you really were there at the time, weren\u2019t you? How else could you remember it? But here is the bombshell: you weren\u2019t there. Not a single atom that is in your body today was there when that event took place .... Matter flows from place to place and momentarily comes together to be you. Whatever you are, therefore, you are not the stuff of which you are made. If that does not make the hair stand up on the back of your neck, read it again until it does, because it is important. Steve Grand","title":"On Flow"},{"location":"flow-mechanics/#how-flow-happens-in-reagent","text":"To implement a reactive flow, Reagent provides a ratom and a reaction . re-frame uses both of these building blocks, so let's now make sure we understand them. ratoms behave just like normal ClojureScript atoms. You can swap! and reset! them, watch them, etc. From a ClojureScript perspective, the purpose of an atom is to hold mutable data. From a re-frame perspective, we'll tweak that paradigm slightly and view a ratom as having a value that changes over time. Seems like a subtle distinction, I know, but because of it, re-frame sees a ratom as a Signal. A Signal is a value that changes over time. So it is a stream of values. Each time a ratom gets reset! that's a new value in the stream. The 2nd building block, reaction , acts a bit like a function. It's a macro which wraps some computation (a block of code) and returns a ratom holding the result of that computation . The magic thing about a reaction is that the computation it wraps will be automatically re-run whenever 'its inputs' change, producing a new output (return) value. Eh, how? Well, the computation is just a block of code, and if that code dereferences one or more ratoms , it will be automatically re-run (recomputing a new return value) whenever any of these dereferenced ratoms change. To put that yet another way, a reaction detects a computation's input Signals (aka input ratoms ) and it will watch them, and when, later, it detects a change in one of them, it will re-run that computation, and it will reset! the new result of that computation into the ratom originally returned. So, the ratom returned by a reaction is itself a Signal. Its value will change over time when the computation is re-run. So, via the interplay between ratoms and reactions , values 'flow' into computations and out again, and then into further computations, etc. \"Values\" flow (propagate) through the Signal graph. But this Signal graph must be without cycles, because cycles cause mayhem! re-frame achieves a unidirectional flow. Right, so that was a lot of words. Some code to clarify: ( ns example1 ( :require-macros [ reagent.ratom :refer [ reaction ]]) ;; reaction is a macro ( :require [ reagent.core :as reagent ])) ( def app-db ( reagent/atom { :a 1 })) ;; our root ratom (signal) ( def ratom2 ( reaction { :b ( :a @ app-db )})) ;; reaction wraps a computation, returns a signal ( def ratom3 ( reaction ( condp = ( :b @ ratom2 ) ;; reaction wraps another computation 0 \"World\" 1 \"Hello\" ))) ;; Notice that both computations above involve de-referencing a ratom: ;; - app-db in one case ;; - ratom2 in the other ;; Notice that both reactions above return a ratom. ;; Those returned ratoms hold the (time varying) value of the computations. ( println @ ratom2 ) ;; ==> {:b 1} ;; a computed result, involving @app-db ( println @ ratom3 ) ;; ==> \"Hello\" ;; a computed result, involving @ratom2 ( reset! app-db { :a 0 }) ;; this change to app-db, triggers re-computation ;; of ratom2 ;; which, in turn, causes a re-computation of ratom3 ( println @ ratom2 ) ;; ==> {:b 0} ;; ratom2 is result of {:b (:a @app-db)} ( println @ ratom3 ) ;; ==> \"World\" ;; ratom3 is automatically updated too. So, in FRP-ish terms, a reaction will produce a \"stream\" of values over time (it is a Signal), accessible via the ratom it returns.","title":"How Flow Happens In Reagent"},{"location":"flow-mechanics/#components-view-functions","text":"When using Reagent, your primary job is to write one or more components . This is the view layer. Think about components as pure functions - data in, Hiccup out. Hiccup is ClojureScript data structures which represent DOM. Here's a trivial component: ( defn greet [] [ :div \"Hello ratoms and reactions\" ]) And if we call it: ( greet ) ;; ==> [:div \"Hello ratoms and reactions\"] You'll notice that our component is a regular Clojure function, nothing special. In this case, it takes no parameters and it returns a ClojureScript vector (formatted as Hiccup). Here is a slightly more interesting (parameterised) component (function): ( defn greet ;; greet has a parameter now [ name ] ;; 'name' is a ratom holding a string [ :div \"Hello \" @ name ]) ;; dereference 'name' to extract the contained value ;; create a ratom, containing a string ( def n ( reagent/atom \"re-frame\" )) ;; call our `component` function, passing in a ratom ( greet n ) ;; ==> [:div \"Hello \" \"re-frame\"] returns a vector So components are easy - at core they are a render function which turns data into Hiccup (which will later become DOM). Now, let's introduce reaction into this mix. On the one hand, I'm complicating things by doing this, because Reagent allows you to be ignorant of the mechanics I'm about to show you. (It invisibly wraps your components in a reaction allowing you to be blissfully ignorant of how the magic happens.) On the other hand, it is useful to understand exactly how the Reagent Signal graph is wired. ( defn greet ;; a component - data in, Hiccup out. [ name ] ;; name is a ratom [ :div \"Hello \" @ name ]) ;; dereference name here, to extract the value within ( def n ( reagent/atom \"re-frame\" )) ;; The computation '(greet n)' returns Hiccup which is stored into 'hiccup-ratom' ( def hiccup-ratom ( reaction ( greet n ))) ;; <-- use of reaction !!! ;; what is the result of the initial computation ? ( println @ hiccup-ratom ) ;; ==> [:div \"Hello \" \"re-frame\"] ;; returns hiccup (a vector of stuff) ;; now change 'n' ;; 'n' is an input Signal for the reaction above. ;; Warning: 'n' is not an input signal because it is a parameter. Rather, it is ;; because 'n' is dereferenced within the execution of the reaction's computation. ;; reaction notices what ratoms are dereferenced in its computation, and watches ;; them for changes. ( reset! n \"blah\" ) ;; n changes ;; The reaction above will notice the change to 'n' ... ;; ... and will re-run its computation ... ;; ... which will have a new \"return value\"... ;; ... which will be \"reset!\" into \"hiccup-ratom\" ( println @ hiccup-ratom ) ;; ==> [:div \"Hello \" \"blah\"] ;; yep, there's the new value So, as n changes value over time (via a reset! ), the output of the computation (greet n) changes, which in turn means that the value in hiccup-ratom changes. Both n and hiccup-ratom are FRP Signals. The Signal graph we created causes data to flow from n into hiccup-ratom . Derived Data, flowing.","title":"Components  (view functions)"},{"location":"flow-mechanics/#truth-interlude","text":"I haven't been entirely straight with you: Reagent re-runs reactions (re-computations) via requestAnimationFrame. So a re-computation happens about 16ms after an input Signals change is detected, or after the current thread of processing finishes, whichever is the greater. So if you are in a REPL and you run the lines of code above one after the other too quickly, you might not see the re-computation done immediately after n gets reset!, because the next animationFrame hasn't run (yet). But you could add a (reagent.core/flush) after the reset! to force re-computation to happen straight away. reaction doesn't actually return a ratom . But it returns something that has ratom-nature, so we'll happily continue believing it is a ratom and no harm will come to us. On with the rest of my lies and distortions...","title":"Truth Interlude"},{"location":"flow-mechanics/#reg-sub-raw","text":"This low level part of the API provides a way to register a subscription handler - so the intent is similar to reg-sub . You use it like other registration functions: ( re-frame.core/reg-sub-raw ;; it is part of the API :query-id ;; later use (subscribe [:query-id]) some-fn ) ;; this function provides the reactive stream The interesting bit is how some-fn is written. Here's an example: ( defn some-fn [ app-db event ] ;; app-db is not a value, it is a reagent/atom ( reaction ( get-in @ app-db [ :some :path ]))) ;; returns a reaction Notice: app-db is a reagent/atom. It is not a value like reg-sub gets. it returns a reaction which does a computation. It does not return a value like reg-sub does. Within that reaction app-db is deref-ed (see use of @ ) As a result of point 3, each time app-db changes, the wrapped reaction will rerun. app-db is an input signal to that reaction . Unlike reg-sub , there is no 3-arity version of reg-sub-raw , so there's no way for you to provide an input signals function. Instead, even simpler, you can just use subscribe within the reaction itself. For example: ( defn some-fn [ app-db event ] ( reaction ( let [ a-path-element @ ( subscribe [ :get-path-part ])] ;; <-- subscribe used here ( get-in @ app-db [ :some a-path-element ])))) As you can see, this reaction has two input signals: app-db and (subscribe [:get-path-part]) . If either changes, the reaction will rerun. In some cases, the returned reaction might not even use app-db and, instead, it might only use subscribe to provide input signals. In that case, the registered subscription would belong to \"Layer 3\" of the signal graph (discussed in earlier tutorials). Remember to deref any use of app-db and subscribe . It is a rookie mistake to forget. I do it regularly. Instead of using reaction (a macro), you can use reagent/make-reaction (a utility function) which gives you the additional ability to attach an :on-dispose handler to the returned reaction, allowing you to do cleanup work when the subscription is no longer needed. See an example of using :on-dispose here","title":"reg-sub-raw"},{"location":"flow-mechanics/#example-reg-sub-raw","text":"The following use of reg-sub can be found in the todomvc example : ( reg-sub :visible-todos ;; signal function - returns a vector of two input signals ( fn [ query-v _ ] [( subscribe [ :todos ]) ( subscribe [ :showing ])]) ;; the computation function - 1st arg is a 2-vector of values ( fn [[ todos showing ] _ ] ( let [ filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) we could rewrite this use of reg-sub using reg-sub-raw like this: ( reg-sub-raw :visible-todos ( fn [ app-db event ] ;; app-db not used, name shown for clarity ( reaction ;; wrap the computation in a reaction ( let [ todos @ ( subscribe [ :todos ]) ;; input signal #1 showing @ ( subscribe [ :showing ]) ;; input signal #2 filter-fn ( case showing :active ( complement :done ) :done :done :all identity )] ( filter filter-fn todos )))) A view could do (subscribe [:visible-todos]) and never know which of the two variations above was used. Same result delivered.","title":"Example reg-sub-raw"},{"location":"historical/","text":"What is the problem? \u00b6 First, we decided to build our SPA apps with ClojureScript, then we chose Reagent , then we had a problem. It was mid-2014. For all its considerable brilliance, Reagent (+ React) delivers only the 'V' part of a traditional MVC framework. (Or, at least the React of that time did. Since then they have turned it into more of a Frankenstein) But apps involve much more than V. We build quite complicated SPAs which can run to 40K lines of code. So, I wanted to know: where does the control logic go? How is state stored & manipulated? etc. We read up on Pedestal App , Flux , Hoplon , Om , early Elm and re-frame is the architecture that emerged. Since then, we have tried to keep an eye on further developments like the Elm Architecture, Om.Next, BEST, Cycle.js, Redux, etc. And that has taught us to appreciate what we have. re-frame does have parts which correspond to M, V, and C, but they aren't objects. It is sufficiently different in nature from (traditional, Smalltalk) MVC that calling it MVC would be confusing. I'd love an alternative. Perhaps it is a RAVES framework - Reactive-Atom Views Event Subscription framework (I love the smell of acronym in the morning). Perhaps DDATWD - Derived Data All The Way Down. TODO: get acronym down to 3 chars! Get an image of stacked Turtles for DDATWD insider's joke, conference T-Shirt. Guiding Philosophy \u00b6 First , above all, we believe in the one true Dan Holmsand , creator of Reagent, and his divine instrument: the ratom . We genuflect towards Sweden once a day. Second , we believe in ClojureScript, immutable data and the process of building a system out of pure functions. Third , we believe in the primacy of data, for the reasons described in the introductions. re-frame has a data-oriented, functional architecture. Fourth , we believe that Reactive Programming is one honking good idea. How did we ever live without it? It is a quite beautiful solution to one half of re-frame's data conveyance needs, but we're cautious about taking it too far - as far as, say, cycle.js. It doesn't take over everything in re-frame - it just does part of the job. Finally , a long time ago in a galaxy far far away, I was lucky enough to program in Eiffel where I was exposed to the idea of command-query separation . The modern rendering of this idea is CQRS ( see resources here ). But, even today, we still see read/write cursors and two-way data binding being promoted as a good thing. Please, just say no. We already know where that goes. As your programs get bigger, the use of these two-way constructs will encourage control logic into all the wrong places and you'll end up with a tire-fire of an Architecture. Sincerely, The Self-appointed President of the Cursor Skeptic's Society. It does Event Sourcing \u00b6 How did that error happen, you puzzle, shaking your head ruefully? What did the user do immediately prior? What state was the app in that this event was so problematic? To debug, you need to know this information: the state of the app immediately before the exception What final event then caused your app to error Well, with re-frame you need to record (have available): A recent checkpoint of the application state in app-db (perhaps the initial state) all the events dispatch ed since the last checkpoint, up to the point where the error occurred Note: that's all just data. Pure, lovely loggable data. If you have that data, then you can reproduce the error. re-frame allows you to time travel, even in a production setting. To find the bug, install the \"checkpoint\" state into app-db and then \"play forward\" through the collection of dispatched events. The only way the app \"moves forwards\" is via events. \"Replaying events\" moves you step by step towards the error causing problem. This is perfect for debugging assuming, of course, you are in a position to capture a checkpoint of app-db , and the events since then. Here's Martin Fowler's description of Event Sourcing . It does a reduce \u00b6 Here's an interesting way of thinking about the re-frame data flow ... First , imagine that all the events ever dispatched in a certain running app were stored in a collection (yes, event sourcing again). So, if when the app started, the user clicked on button X the first item in this collection would be the event generated by that button, and then, if next the user moved a slider, the associated event would be the next item in the collection, and so on and so on. We'd end up with a collection of event vectors. Second , remind yourself that the combining function of a reduce takes two arguments: the current state of the reduction and the next collection member to fold in Then notice that reg-event-db event handlers take two arguments also: db - the current state of app-db v - the next event to fold in Interesting. That's the same as a combining function in a reduce !! So, now we can introduce the new mental model: at any point in time, the value in app-db is the result of performing a reduce over the entire collection of events dispatched in the app up until that time. The combining function for this reduce is the set of event handlers. It is almost like app-db is the temporary place where this imagined perpetual reduce stores its on-going reduction. Now, in the general case, this perspective breaks down a bit, because of reg-event-fx (has -fx on the end, not -db ) which allows: Event handlers to produce effects beyond just application state changes. Event handlers to have coeffects (arguments) in addition to db and v . But, even if it isn't the full picture, it is a very useful and interesting mental model. We were first exposed to this idea via Elm's early use of foldp (fold from the past), which was later enshrined in the Elm Architecture. Derived Data All The Way Down \u00b6 For the love of all that is good, please watch this terrific StrangeLoop presentation (40 mins). See what happens when you re-imagine a database as a stream!! Look at all the problems that evaporate. Think about that: shared mutable state (the root of all evil), re-imagined as a stream!! Blew my socks off. If, by chance, you ever watched that video (you should!), you might then twig to the idea that app-db is really a derived value ... the video talks a lot about derived values. So, yes, app-db is a derived value of the perpetual reduce . And yet, it acts as the authoritative source of state in the app. And yet, it isn't, it is simply a piece of derived state. And yet, it is the source. Etc. This is an infinite loop of sorts - an infinite loop of derived data. It does FSM \u00b6 Any sufficiently complicated GUI contains an ad hoc, informally-specified, bug-ridden, slow implementation of a hierarchical Finite State Machine -- me, trying too hard to impress my two twitter followers event handlers collectively implement the \"control\" part of an application. Their logic interprets arriving events in the context of existing state, and they compute the new state of the application. events act a bit like the triggers in a finite state machine, and the event handlers act like the rules which govern how the state machine moves from one logical state to the next. In the simplest case, app-db will contain a single value which represents the current \"logical state\". For example, there might be a single :phase key which can have values like :loading , :not-authenticated :waiting , etc. Or, the \"logical state\" could be a function of many values in app-db . Not every app has lots of logical states, but some do, and if you are implementing one of them, then formally recognising it and using a technique like State Charts will help greatly in getting a clean design and fewer bugs. The beauty of re-frame, from a FSM point of view, is that all the state is in one place - unlike OO systems where the state is distributed (and synchronised) across many objects. So implementing your control logic as a FSM is fairly natural in re-frame, whereas it is often difficult and contrived in other kinds of architecture (in my experience). So, members of the jury, I put it to you that: the first 3 dominoes implement an Event-driven finite-state machine the last 3 dominoes render the FSM's current state for the user to observe Depending on your app, this may or may not be a useful mental model, but one thing is for sure ... Events - that's the way we roll.","title":"Historical"},{"location":"historical/#what-is-the-problem","text":"First, we decided to build our SPA apps with ClojureScript, then we chose Reagent , then we had a problem. It was mid-2014. For all its considerable brilliance, Reagent (+ React) delivers only the 'V' part of a traditional MVC framework. (Or, at least the React of that time did. Since then they have turned it into more of a Frankenstein) But apps involve much more than V. We build quite complicated SPAs which can run to 40K lines of code. So, I wanted to know: where does the control logic go? How is state stored & manipulated? etc. We read up on Pedestal App , Flux , Hoplon , Om , early Elm and re-frame is the architecture that emerged. Since then, we have tried to keep an eye on further developments like the Elm Architecture, Om.Next, BEST, Cycle.js, Redux, etc. And that has taught us to appreciate what we have. re-frame does have parts which correspond to M, V, and C, but they aren't objects. It is sufficiently different in nature from (traditional, Smalltalk) MVC that calling it MVC would be confusing. I'd love an alternative. Perhaps it is a RAVES framework - Reactive-Atom Views Event Subscription framework (I love the smell of acronym in the morning). Perhaps DDATWD - Derived Data All The Way Down. TODO: get acronym down to 3 chars! Get an image of stacked Turtles for DDATWD insider's joke, conference T-Shirt.","title":"What is the problem?"},{"location":"historical/#guiding-philosophy","text":"First , above all, we believe in the one true Dan Holmsand , creator of Reagent, and his divine instrument: the ratom . We genuflect towards Sweden once a day. Second , we believe in ClojureScript, immutable data and the process of building a system out of pure functions. Third , we believe in the primacy of data, for the reasons described in the introductions. re-frame has a data-oriented, functional architecture. Fourth , we believe that Reactive Programming is one honking good idea. How did we ever live without it? It is a quite beautiful solution to one half of re-frame's data conveyance needs, but we're cautious about taking it too far - as far as, say, cycle.js. It doesn't take over everything in re-frame - it just does part of the job. Finally , a long time ago in a galaxy far far away, I was lucky enough to program in Eiffel where I was exposed to the idea of command-query separation . The modern rendering of this idea is CQRS ( see resources here ). But, even today, we still see read/write cursors and two-way data binding being promoted as a good thing. Please, just say no. We already know where that goes. As your programs get bigger, the use of these two-way constructs will encourage control logic into all the wrong places and you'll end up with a tire-fire of an Architecture. Sincerely, The Self-appointed President of the Cursor Skeptic's Society.","title":"Guiding Philosophy"},{"location":"historical/#it-does-event-sourcing","text":"How did that error happen, you puzzle, shaking your head ruefully? What did the user do immediately prior? What state was the app in that this event was so problematic? To debug, you need to know this information: the state of the app immediately before the exception What final event then caused your app to error Well, with re-frame you need to record (have available): A recent checkpoint of the application state in app-db (perhaps the initial state) all the events dispatch ed since the last checkpoint, up to the point where the error occurred Note: that's all just data. Pure, lovely loggable data. If you have that data, then you can reproduce the error. re-frame allows you to time travel, even in a production setting. To find the bug, install the \"checkpoint\" state into app-db and then \"play forward\" through the collection of dispatched events. The only way the app \"moves forwards\" is via events. \"Replaying events\" moves you step by step towards the error causing problem. This is perfect for debugging assuming, of course, you are in a position to capture a checkpoint of app-db , and the events since then. Here's Martin Fowler's description of Event Sourcing .","title":"It does Event Sourcing"},{"location":"historical/#it-does-a-reduce","text":"Here's an interesting way of thinking about the re-frame data flow ... First , imagine that all the events ever dispatched in a certain running app were stored in a collection (yes, event sourcing again). So, if when the app started, the user clicked on button X the first item in this collection would be the event generated by that button, and then, if next the user moved a slider, the associated event would be the next item in the collection, and so on and so on. We'd end up with a collection of event vectors. Second , remind yourself that the combining function of a reduce takes two arguments: the current state of the reduction and the next collection member to fold in Then notice that reg-event-db event handlers take two arguments also: db - the current state of app-db v - the next event to fold in Interesting. That's the same as a combining function in a reduce !! So, now we can introduce the new mental model: at any point in time, the value in app-db is the result of performing a reduce over the entire collection of events dispatched in the app up until that time. The combining function for this reduce is the set of event handlers. It is almost like app-db is the temporary place where this imagined perpetual reduce stores its on-going reduction. Now, in the general case, this perspective breaks down a bit, because of reg-event-fx (has -fx on the end, not -db ) which allows: Event handlers to produce effects beyond just application state changes. Event handlers to have coeffects (arguments) in addition to db and v . But, even if it isn't the full picture, it is a very useful and interesting mental model. We were first exposed to this idea via Elm's early use of foldp (fold from the past), which was later enshrined in the Elm Architecture.","title":"It does a reduce"},{"location":"historical/#derived-data-all-the-way-down","text":"For the love of all that is good, please watch this terrific StrangeLoop presentation (40 mins). See what happens when you re-imagine a database as a stream!! Look at all the problems that evaporate. Think about that: shared mutable state (the root of all evil), re-imagined as a stream!! Blew my socks off. If, by chance, you ever watched that video (you should!), you might then twig to the idea that app-db is really a derived value ... the video talks a lot about derived values. So, yes, app-db is a derived value of the perpetual reduce . And yet, it acts as the authoritative source of state in the app. And yet, it isn't, it is simply a piece of derived state. And yet, it is the source. Etc. This is an infinite loop of sorts - an infinite loop of derived data.","title":"Derived Data All The Way Down"},{"location":"historical/#it-does-fsm","text":"Any sufficiently complicated GUI contains an ad hoc, informally-specified, bug-ridden, slow implementation of a hierarchical Finite State Machine -- me, trying too hard to impress my two twitter followers event handlers collectively implement the \"control\" part of an application. Their logic interprets arriving events in the context of existing state, and they compute the new state of the application. events act a bit like the triggers in a finite state machine, and the event handlers act like the rules which govern how the state machine moves from one logical state to the next. In the simplest case, app-db will contain a single value which represents the current \"logical state\". For example, there might be a single :phase key which can have values like :loading , :not-authenticated :waiting , etc. Or, the \"logical state\" could be a function of many values in app-db . Not every app has lots of logical states, but some do, and if you are implementing one of them, then formally recognising it and using a technique like State Charts will help greatly in getting a clean design and fewer bugs. The beauty of re-frame, from a FSM point of view, is that all the state is in one place - unlike OO systems where the state is distributed (and synchronised) across many objects. So implementing your control logic as a FSM is fairly natural in re-frame, whereas it is often difficult and contrived in other kinds of architecture (in my experience). So, members of the jury, I put it to you that: the first 3 dominoes implement an Event-driven finite-state machine the last 3 dominoes render the FSM's current state for the user to observe Depending on your app, this may or may not be a useful mental model, but one thing is for sure ... Events - that's the way we roll.","title":"It does FSM"},{"location":"interconnections/","text":"Ask a Systems Theorist, and they'll tell you that a system has parts and interconnections . Human brains tend to focus first on the parts , and then, later, maybe on interconnections . But we know better, right? We know interconnections are often critical to a system. \"Focus on the lines between the boxes\" we lecture anyone kind enough to listen (in my case, glassy-eyed family members). In the case of re-frame, dominoes are the parts , so, tick, yes, we have looked at them first. Our brains are happy. But what about the interconnections ? If the parts are functions, as is the case with re-frame, what does it even mean to talk about interconnections between functions? To answer that question, I'll rephrase it as: how are the domino functions composed ? At the language level, Uncle Alonzo and Uncle John tell us how a function like count composes: ( str ( count ( filter odd? [ 1 2 3 4 5 ]))) We know when count is called, and with what argument, and how the value it computes becomes the arg for a further function. We know how data \"flows\" into and out of the functions. Sometimes, we'd rewrite this code as: ( ->> [ 1 2 3 4 5 ] ( filter odd? ) count str ) With this arrangement, we talk of \"threading\" data through functions. It seems to help our comprehension to conceive function composition in terms of data flow . re-frame delivers architecture by supplying the interconnections - it threads the data - it composes the dominoes - it is the lines between the boxes. But it doesn't have a universal method for this \"composition\". The technique it uses varies from one domino neighbour-pair to the next. Initially, it uses a queue/router, then a pipeline of interceptors and, finally, a Signal Graph. Remember back in the Introduction? Our analogy for re-frame was the water cycle - water flowing around the loop, compelled by different kinds of forces at different times (gravity, convection, etc), going through phase changes. With this focus on interconnections, we have been looking on the \"forces\" part of the loop. The transport.","title":"Interconnections"},{"location":"on-dynamics/","text":"As a programmer works, they often need to reason about the runtime dynamics of their code. They'll be staring, without seeing, at a spot in space, and in their heads, they'll be performing a runtime simulation of their code. But this is hard, even for Dijkstra. Our intellectual powers are rather geared to master static relations and our powers to visualise processes evolving in time are relatively poorly developed. -- Dijkstra The Claim \u00b6 re-frame has a simple dynamic process It is the purpose of this page to explain and justify this claim. There's no more important point to make about re-frame than this one re-frame was designed to deliver a good developer experience. This is the top design goal and, in this pursuit, tradeoffs are made. Even functional purity was sacrificed in places (gasp!). Almost nothing contributes to this goal more than re-frame presenting \"a simple dynamic model\". Almost nothing makes a programmer's job easier than a simple dynamic model. Almost nothing reduces bugs more than a simple dynamic model. On Dynamics \u00b6 Some scientific fields include the word \"dynamics\" in their name: Hydrodynamics, Thermodynamics and Social Dynamics. It means the participants observe how certain systems change over time/space and then model the causes. So, how about our systems? A Web App is a \"sequential process\". Over time, it will shift from one State to another, and consequently, often from one behaviour to another. The \"dynamics\" arise from Computation and State interacting across time. State is effectively congealed time - history materialised - and it is moulded by rounds of Computation . However, it isn't all one way. Although Computation creates State , it is itself controlled by that State . For example, predicates on State determine which branches of Computation execute. So, there's a feedback loop between the two. Oh, no! Did someone just say feedback loop? That's bad, right? For a programmer trying to mentally simulate a State / Computation feedback process, there can be a lot to juggle, quickly putting them at the limits of their cognitive budget. Certain kinds of interactions between time, State & Computation reduce dynamic complexity, making mental simulations easier, while others do the opposite and make it virtually impossible. Any systems on the \"impossible\" end of that continuum will breed nasty bugs and be scary to maintain. To understand a program, you must become both the machine and the program. -- Alan Perlis Dynamic vs Static Concerns \u00b6 Programmers are surprisingly focused on the static aspect of their systems. For example, they talk about DRY, line count, and \"cohesion vs coupling\". Sure, yes, that's useful, but perhaps we should pay more attention to the qualities which make runtimes easier or harder to simulate in our heads. This doesn't get talked about nearly enough. The goal with re-frame was to have the simplest dynamic model possible because that, above all else, drives developer productivity. So, let's talk about how re-frame delivers a simple dynamic model. We'll start off at a high level and then work our way down. re-frame Time \u00b6 A re-frame app progresses one event at a time through its computational/state space. The unit of time is one event. Each event is entirely processed from beginning to end before the next event on the queue is processed. re-frame does not support the idea that an event can be \"suspended\" and then, later, restarted. A re-frame app is only ever doing one thing (one event) at a time. Also, when an event changes application state, it does so transactionally (instantly), in one fell swoop, not incrementally. So, at a high level, re-frame delivers dynamics in discrete units, with a clear start and end, which can then be understood and analysed independently. But, how about one level down, within the processing of a single event? What about those dynamics? Processing An Event \u00b6 Do you remember those \"theory of computation\" lectures at Uni? The most limited kind of computation, and as a consequence, the easiest dynamic process to simulate in your head, was called a Finite State Machine. At the other end of the computational spectrum were Turing Machines. You can compute anything with a Turing Machine, which is awesome, right? Anything. Fantastic. But there might be a cost: your programming keyboard has now become a loaded gun. Is your foot safe? just because you can, doesn't mean you should re-frame's overarching process for handling a single event is one part \"Finite State Machine\" and one part dataflow. The event-handling process proceeds step by step through a linear set of logical states, which you know already as \"The Dominoes\". Only one state at a time is happening, and in each state there is specific behaviour/computation, and each of them is sufficiently isolated from the others that it can be understood and analysed independently. You can comfortably \"zoom in\" to understand each part, ignoring the rest. The re-frame docs don't formally talk about FSMs and, instead, presents it as a \"data flow\" which causes transitions from one state to another. But the dominos are like a simple FSM \"in nature\". And, consequently, each event is processed using a simple kind of computation, making it easy to simulate in your head. Less Is More At this level, re-frame is less powerful by design . It delivers the minimum amount of power necessary to get the job done. Instead of providing computation with many degrees of freedom and occasional magic, it will give you simplicity and certainty. Less Is Scary Offering programmers less computational power makes them uncomfortable. We live in a world where requirements change on us all the time and often in unexpected and unwelcome ways. For our protection, so we can handle these unexpected requirements, we are attracted to more power, not less. But let's now go deeper again. But what about the dynamics within each individual Domino? Pure Functions \u00b6 Within a Domino, we are back to programming with the Turing complete power of ClojureScript. Thankfully, to harness and control that frightening power, you write pure functions and use immutable data. Pure functions stand outside of \"time\". To understand them, you don't need to know \"when\" they were run and the state of the system at that point. Instead, you need only know the value of the actual arguments. The tyranny of time is still present on the inside of a pure function, because there is an internal flow of execution. So, you might still need to simulate that in your head. But a pure function delivers a smaller dynamic process to understand - one that is more cognitively tractable. But wait, there's more. We provide data to a pure function as arguments, and they return data, and this data is immutable. This acts to decoupled a pure functions from \"place\" - it is insulated from where data is put. Because pure functions are decoupled from both \"time\" and \"place\", they can be composed in a maximally mathematical way. This greatly dampens the complexity of runtime dynamics. Banana Issues Non-pure functions \"reach out\" and grab a value from the global space beyond their arguments. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. -- Joe Armstrong, creator of the Erlang programming language To understand a function that grabs a banana, you must also understand all the runtime dynamics associated with changes in banana. You must reason globally, not locally. Which is often difficult. Declarative \u00b6 Declarative programming means saying \"make X happen\", but not needing to specify how. So, it abstracts away the process, which collapses the associated dynamics. re-frame has a lot of \"declarative\" happening. Reagent is a powerful declarative DOM capability. Events are declarative. Effects are declarative. The Signal Graph is declarative. And all this \"declarative\" is done with data-based DSLs, as is the Clojure way. Data DSLs Have you noticed that \"declarative\" is better when the DSL is defined in data? For example, Hiccup is an excellent DSL, and it is data. In the simple case, just data literals, but computation can be added to generate the data. SQL is string-based. As literals that's okay, but it completely sucks if we have to start computing the string. And regexs? Oof. A string-based DSL for a powerful, occasionally surprising computational paradigm. State Management \u00b6 Nothing screams \"complicated dynamics\" more than needing to \"distribute state\". Well, other than appending \"... over unreliable networks\". This is, of course, why OO can be problematic. How on earth did we ever think that deliberately distributing state into hidden little mutable packets and then having to dynamically synchronise them was a good idea? And, Your Honour, I was as guilty as the rest. re-frame puts state in the one place and updates it once per event cycle, in one fell swoop. You never need to worry that the app is in some slightly inconsistent intermediate state. And you don't need to worry about the dynamics of communicating changes from one \"store\" of state to another. Also, in one fell swoop, you can check if all the state in your app (all of it!) conforms to a schema. And that includes any data which just arrived over the wire from the server. Incident report - \"Simple Dynamic Process\" \u00b6 While re-fame normally has a simple dynamic process, we acknowledge fat tail risk. On May 12th, at approximately 12:47am, re-frame became self-aware. It printed a single console log: \"Oh, really? I'll show you a simple dynamic process, f#$%ers\". Although a nuclear winter did follow, humans ultimately prevailed over the robot army, and the bug was found and fixed. So, all good. But if ever you notice a Signal Graph adopting a Cortex structure, we still recommend a precautionary reboot. Summary \u00b6 re-frame apps are simple to simulate in your head, and there are consequences - all of them good. This simplicity arises from a combination of factors. On this page, we have reviewed re-frame layer by layer, starting at a high level with how events are handled one after the other in a discrete way. Then, how a single event is handled step by step in a FSM-like way. Then, how pure functions and immutable data dramatically dampen dynamics. Then, through to how declarative data-based DSLs are used in multiple places. And, finally, at how there is only one store of State and how it is updated only once per event cycle in a transactional way. Recently, at a local Clojure meetup, I was talking to an experienced programmer, and I was thrilled to hear him say the following (in a slightly distracted way, almost as if surprised by the realisation): Been using re-frame for nine months now. Do you know what's odd? I find myself writing fewer tests these days since I started using re-frame. So, an experienced (self-regulating) programmer who has previously written a lot of tests, is instinctively writing fewer tests, surprising even himself a bit with the decision. I believe his intuitions are telling him it is safe to do so. He is reacting to the simplicity he is experiencing. N of 1, sure. But there's almost no better recommendation than this. I was delighted. Appendix A - On Reified Dynamics \u00b6 I said above that program dynamics don't get enough attention, but there are some notable exceptions. In his 2012 Learnable Programming treatise, Brett Victor begins: Thus, the goals of a programming system should be: 1. to support and encourage powerful ways of thinking 2. to enable programmers to see and understand the execution of their programs He is not concerned with the static aspects of code. Instead, both of his goals focus on the dynamics of systems and, one level up, on the dynamics of systems development. To demonstrate his first goal , Brett Victor showed a demonstration of how a programmer might directly manipulate code (er, values in code) and observe the implications of their changes instantly. The demo was highly visual and motivating, but the program concerned was small. I don't know about you, but my applications tend to be larger and more prosaic. They have buttons, and they grind on data. It was difficult to see how the concept would \"scale up\" to my world. Having said that, a ClojureScript programmer can receive excellent, near-instant feedback via hot code reloading, REPLs, and instant event replays. These don't fully deliver the direct manipulation in Brett Victor's demo, but they aren't too bad compared to, say, long compilation cycles. Brett Victor's second goal aligns with the theme of this tutorial, and, on this point, we have plans. We want to give the re-frame programmer deep insight into program execution . Wouldn't it be good if a programmer did not have to struggle with mental simulations? Instead, imagine if they could observe and interact with a reification of program execution after the event. Our tool, re-frame-10x , has the aspirational goal of pragmatically delivering on Brett Victor's second goal for larger, industry-grade programming tasks. Our method is to reify, as data, the dynamics of an application when it handles an event. You should be able to observe every single \"form\" of ClojureScript code executed in the process. No need to imagine how the code executed because you can see it in concrete terms. That's our vision. Our goal is completely achievable, but we're only part the way there with the implementation. Check out re-frame-10x .","title":"On Dynamics"},{"location":"on-dynamics/#the-claim","text":"re-frame has a simple dynamic process It is the purpose of this page to explain and justify this claim. There's no more important point to make about re-frame than this one re-frame was designed to deliver a good developer experience. This is the top design goal and, in this pursuit, tradeoffs are made. Even functional purity was sacrificed in places (gasp!). Almost nothing contributes to this goal more than re-frame presenting \"a simple dynamic model\". Almost nothing makes a programmer's job easier than a simple dynamic model. Almost nothing reduces bugs more than a simple dynamic model.","title":"The Claim"},{"location":"on-dynamics/#on-dynamics","text":"Some scientific fields include the word \"dynamics\" in their name: Hydrodynamics, Thermodynamics and Social Dynamics. It means the participants observe how certain systems change over time/space and then model the causes. So, how about our systems? A Web App is a \"sequential process\". Over time, it will shift from one State to another, and consequently, often from one behaviour to another. The \"dynamics\" arise from Computation and State interacting across time. State is effectively congealed time - history materialised - and it is moulded by rounds of Computation . However, it isn't all one way. Although Computation creates State , it is itself controlled by that State . For example, predicates on State determine which branches of Computation execute. So, there's a feedback loop between the two. Oh, no! Did someone just say feedback loop? That's bad, right? For a programmer trying to mentally simulate a State / Computation feedback process, there can be a lot to juggle, quickly putting them at the limits of their cognitive budget. Certain kinds of interactions between time, State & Computation reduce dynamic complexity, making mental simulations easier, while others do the opposite and make it virtually impossible. Any systems on the \"impossible\" end of that continuum will breed nasty bugs and be scary to maintain. To understand a program, you must become both the machine and the program. -- Alan Perlis","title":"On Dynamics"},{"location":"on-dynamics/#dynamic-vs-static-concerns","text":"Programmers are surprisingly focused on the static aspect of their systems. For example, they talk about DRY, line count, and \"cohesion vs coupling\". Sure, yes, that's useful, but perhaps we should pay more attention to the qualities which make runtimes easier or harder to simulate in our heads. This doesn't get talked about nearly enough. The goal with re-frame was to have the simplest dynamic model possible because that, above all else, drives developer productivity. So, let's talk about how re-frame delivers a simple dynamic model. We'll start off at a high level and then work our way down.","title":"Dynamic vs Static Concerns"},{"location":"on-dynamics/#re-frame-time","text":"A re-frame app progresses one event at a time through its computational/state space. The unit of time is one event. Each event is entirely processed from beginning to end before the next event on the queue is processed. re-frame does not support the idea that an event can be \"suspended\" and then, later, restarted. A re-frame app is only ever doing one thing (one event) at a time. Also, when an event changes application state, it does so transactionally (instantly), in one fell swoop, not incrementally. So, at a high level, re-frame delivers dynamics in discrete units, with a clear start and end, which can then be understood and analysed independently. But, how about one level down, within the processing of a single event? What about those dynamics?","title":"re-frame Time"},{"location":"on-dynamics/#processing-an-event","text":"Do you remember those \"theory of computation\" lectures at Uni? The most limited kind of computation, and as a consequence, the easiest dynamic process to simulate in your head, was called a Finite State Machine. At the other end of the computational spectrum were Turing Machines. You can compute anything with a Turing Machine, which is awesome, right? Anything. Fantastic. But there might be a cost: your programming keyboard has now become a loaded gun. Is your foot safe? just because you can, doesn't mean you should re-frame's overarching process for handling a single event is one part \"Finite State Machine\" and one part dataflow. The event-handling process proceeds step by step through a linear set of logical states, which you know already as \"The Dominoes\". Only one state at a time is happening, and in each state there is specific behaviour/computation, and each of them is sufficiently isolated from the others that it can be understood and analysed independently. You can comfortably \"zoom in\" to understand each part, ignoring the rest. The re-frame docs don't formally talk about FSMs and, instead, presents it as a \"data flow\" which causes transitions from one state to another. But the dominos are like a simple FSM \"in nature\". And, consequently, each event is processed using a simple kind of computation, making it easy to simulate in your head. Less Is More At this level, re-frame is less powerful by design . It delivers the minimum amount of power necessary to get the job done. Instead of providing computation with many degrees of freedom and occasional magic, it will give you simplicity and certainty. Less Is Scary Offering programmers less computational power makes them uncomfortable. We live in a world where requirements change on us all the time and often in unexpected and unwelcome ways. For our protection, so we can handle these unexpected requirements, we are attracted to more power, not less. But let's now go deeper again. But what about the dynamics within each individual Domino?","title":"Processing An Event"},{"location":"on-dynamics/#pure-functions","text":"Within a Domino, we are back to programming with the Turing complete power of ClojureScript. Thankfully, to harness and control that frightening power, you write pure functions and use immutable data. Pure functions stand outside of \"time\". To understand them, you don't need to know \"when\" they were run and the state of the system at that point. Instead, you need only know the value of the actual arguments. The tyranny of time is still present on the inside of a pure function, because there is an internal flow of execution. So, you might still need to simulate that in your head. But a pure function delivers a smaller dynamic process to understand - one that is more cognitively tractable. But wait, there's more. We provide data to a pure function as arguments, and they return data, and this data is immutable. This acts to decoupled a pure functions from \"place\" - it is insulated from where data is put. Because pure functions are decoupled from both \"time\" and \"place\", they can be composed in a maximally mathematical way. This greatly dampens the complexity of runtime dynamics. Banana Issues Non-pure functions \"reach out\" and grab a value from the global space beyond their arguments. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. -- Joe Armstrong, creator of the Erlang programming language To understand a function that grabs a banana, you must also understand all the runtime dynamics associated with changes in banana. You must reason globally, not locally. Which is often difficult.","title":"Pure Functions"},{"location":"on-dynamics/#declarative","text":"Declarative programming means saying \"make X happen\", but not needing to specify how. So, it abstracts away the process, which collapses the associated dynamics. re-frame has a lot of \"declarative\" happening. Reagent is a powerful declarative DOM capability. Events are declarative. Effects are declarative. The Signal Graph is declarative. And all this \"declarative\" is done with data-based DSLs, as is the Clojure way. Data DSLs Have you noticed that \"declarative\" is better when the DSL is defined in data? For example, Hiccup is an excellent DSL, and it is data. In the simple case, just data literals, but computation can be added to generate the data. SQL is string-based. As literals that's okay, but it completely sucks if we have to start computing the string. And regexs? Oof. A string-based DSL for a powerful, occasionally surprising computational paradigm.","title":"Declarative"},{"location":"on-dynamics/#state-management","text":"Nothing screams \"complicated dynamics\" more than needing to \"distribute state\". Well, other than appending \"... over unreliable networks\". This is, of course, why OO can be problematic. How on earth did we ever think that deliberately distributing state into hidden little mutable packets and then having to dynamically synchronise them was a good idea? And, Your Honour, I was as guilty as the rest. re-frame puts state in the one place and updates it once per event cycle, in one fell swoop. You never need to worry that the app is in some slightly inconsistent intermediate state. And you don't need to worry about the dynamics of communicating changes from one \"store\" of state to another. Also, in one fell swoop, you can check if all the state in your app (all of it!) conforms to a schema. And that includes any data which just arrived over the wire from the server.","title":"State Management"},{"location":"on-dynamics/#incident-report-simple-dynamic-process","text":"While re-fame normally has a simple dynamic process, we acknowledge fat tail risk. On May 12th, at approximately 12:47am, re-frame became self-aware. It printed a single console log: \"Oh, really? I'll show you a simple dynamic process, f#$%ers\". Although a nuclear winter did follow, humans ultimately prevailed over the robot army, and the bug was found and fixed. So, all good. But if ever you notice a Signal Graph adopting a Cortex structure, we still recommend a precautionary reboot.","title":"Incident report - \"Simple Dynamic Process\""},{"location":"on-dynamics/#summary","text":"re-frame apps are simple to simulate in your head, and there are consequences - all of them good. This simplicity arises from a combination of factors. On this page, we have reviewed re-frame layer by layer, starting at a high level with how events are handled one after the other in a discrete way. Then, how a single event is handled step by step in a FSM-like way. Then, how pure functions and immutable data dramatically dampen dynamics. Then, through to how declarative data-based DSLs are used in multiple places. And, finally, at how there is only one store of State and how it is updated only once per event cycle in a transactional way. Recently, at a local Clojure meetup, I was talking to an experienced programmer, and I was thrilled to hear him say the following (in a slightly distracted way, almost as if surprised by the realisation): Been using re-frame for nine months now. Do you know what's odd? I find myself writing fewer tests these days since I started using re-frame. So, an experienced (self-regulating) programmer who has previously written a lot of tests, is instinctively writing fewer tests, surprising even himself a bit with the decision. I believe his intuitions are telling him it is safe to do so. He is reacting to the simplicity he is experiencing. N of 1, sure. But there's almost no better recommendation than this. I was delighted.","title":"Summary"},{"location":"on-dynamics/#appendix-a-on-reified-dynamics","text":"I said above that program dynamics don't get enough attention, but there are some notable exceptions. In his 2012 Learnable Programming treatise, Brett Victor begins: Thus, the goals of a programming system should be: 1. to support and encourage powerful ways of thinking 2. to enable programmers to see and understand the execution of their programs He is not concerned with the static aspects of code. Instead, both of his goals focus on the dynamics of systems and, one level up, on the dynamics of systems development. To demonstrate his first goal , Brett Victor showed a demonstration of how a programmer might directly manipulate code (er, values in code) and observe the implications of their changes instantly. The demo was highly visual and motivating, but the program concerned was small. I don't know about you, but my applications tend to be larger and more prosaic. They have buttons, and they grind on data. It was difficult to see how the concept would \"scale up\" to my world. Having said that, a ClojureScript programmer can receive excellent, near-instant feedback via hot code reloading, REPLs, and instant event replays. These don't fully deliver the direct manipulation in Brett Victor's demo, but they aren't too bad compared to, say, long compilation cycles. Brett Victor's second goal aligns with the theme of this tutorial, and, on this point, we have plans. We want to give the re-frame programmer deep insight into program execution . Wouldn't it be good if a programmer did not have to struggle with mental simulations? Instead, imagine if they could observe and interact with a reification of program execution after the event. Our tool, re-frame-10x , has the aspirational goal of pragmatically delivering on Brett Victor's second goal for larger, industry-grade programming tasks. Our method is to reify, as data, the dynamics of an application when it handles an event. You should be able to observe every single \"form\" of ClojureScript code executed in the process. No need to imagine how the code executed because you can see it in concrete terms. That's our vision. Our goal is completely achievable, but we're only part the way there with the implementation. Check out re-frame-10x .","title":"Appendix A - On Reified Dynamics"},{"location":"on-stable-dom-handlers/","text":"This page describes an advanced technique to avoid Reagent's \"anonymous callback\" inefficiency. This technique is only useful when you are writing performance-critical components. Indeed, you may never need it, but understanding it will deepen your knowledge about Reagent. A performance-critical component would need to satisfy all of the following: be repeatedly used on a page, perhaps within the rows of a list, or the cells of a grid, or the branches of a tree and then be re-rendered a lot and involve creating anonymous callback functions in re-renders Equality Tests \u00b6 Equality tests are at the heart of the issue, so let's start by considering this one: ( = [ 1 :2 \"3\" ] [ 1 :2 \"3\" ]) Question : will it evaluate to true or false ? Answer : true . Because the elements 1 , :2 and \"3\" are identities, so different instances test equal, and because vector equality is determined by element equality. Implications For Reagent \u00b6 Reagent uses equality checks on props to avoid doing unnecessary work. Consider this view: ( defn parent [ x ] [ child 1 :2 \"3\" ]) Imagine that parent has already rendered once. And then something causes it to re-render (perhaps its parent re-renders and supplies a different x ). When parent re-renders, it will re-render child and supply three props: 1 , :2 and \"3\" . But these props will be the same as the ones supplied with the \"last render\" and, as a result, Reagent calculates that it doesn't need to perform the re-render of child . Reagent assumes that child is rendered by a pure function and it deduces that giving a pure function the same props/args as last time, results in the same result (the same hiccup). And so Reagent avoids doing this unnecessary work. It is an efficiency thing. Question : But how does Reagent check for this \"sameness\" between the props supplied \"this render\" vs the \"last render\"? Answer : by testing the props using = So: 1 (last time) is = to 1 (this time) :2 is = to :2 and \"3\" too is equal to last time All three props are = to last time, which allows Reagent to skip the re-render of child . But Wait, Functions \u00b6 Next step: we introduce anonymous callback functions. Consider this test: ( = ( fn [ n ] ( + n 1 )) ( fn [ n ] ( + n 1 ))) Question : will it evaluate to true or false ? Answer : false . You might be able to see that the two anonymous functions are equal, but = says \"no\". Anonymous functions are not like 1 or :2 Armed with this knowledge, what happens if we add a new prop for child and make it an anonymous callback function? Like this: ( defn parent [ x ] [ child 1 :2 \"3\" ( fn [] ( dispatch [ :something ]))]) So, that's now four props given to child . The first three of them are as before. But the new last one is an anonymous function. What a difference that new one makes!! Now, every time parent is re-rendered, child will also be re-rendered. Every time. Reagent's efficiency checks which try to avoid unnecessary work are broken when one prop is an anonymous function because the value \"this time\" does not test = to last time, even though we can see they are the same function. Fixing It \u00b6 Surely the way to fix this is simple: don't use an anonymous function. First we create: ( defn callback [] ( dispatch [ :something ])) Then we perform a test: ( = callback callback ) Question : what will it evaluate to? true or false ? Answer : true . callback is a symbol which is bound to a function. So we are comparing the value bound to callback (a function), and that will test = because it is the same function on both sides of = . Let's use that; ( defn parent [ x ] [ child 1 :2 \"3\" callback ]) ;; <--- used here Now all four props for child will test = to last time. And child won't be re-rendered. In fact, we can make this simpler by using a Form-2 function: ( defn parent [ x ] ( let [ callback # ( dispatch [ :something ])] ;; <-- create here ( fn [ x ] [ child 1 :2 \"3\" callback ]))) The outside function creates the anonymous function, which means it doesn't get recreated and change on each render, and so callback will test = to \"last time\" in all renders. Problem fixed? Yes, but unfortunately, only for the simple case. Which really means \"no, not fixed enough\". Where It Breaks Down \u00b6 Say, parent has an argument id . And, say, we need to use that in the callback. ( defn parent [ id ] ( let [ callback ( fn [] ( dispatch [ :something id ]))] ( fn [ id ] [ child 1 :2 \"3\" callback ]))) Does this work? Sadly, no. Can you spot the bug? callback has closed over the original value for id - the one given to the outer function. callback will never dispatch the \"latest\" value of id provided to the re-render function (notice that id is an argument to both the outer and inner functions in the Form-2 Component). The Technique \u00b6 So, enough preamble and explanation, here's the real solution - and it has three parts: ( defn parent [ id ] ( let [ callback ( fn [ the-id ] ( dispatch [ :something the-id ])) ;; <-- Note 1 callback-factory ( callback-factory-factory callback )] ;; <-- Note 2 ( fn [ id ] [ child 1 :2 \"3\" ( callback-factory id )]) ;; <-- Note 3 Notes: callback no longer tries to \"close over' id . Instead, it takes id as an argument. callback-factory-factory has a long name, and it performs the trick. It returns a function which, when called, will always return the same function, which wraps callback . (code supplied below) Each time we call callback-factory , it will return the same function. But it does it in a way which allows for id to vary on each render. Which only leaves me to show you the hero in our story, which I offer without further explanation for you to read and understand: ( defn callback-factory-factory \"returns a function which will always return the `same-callback` every time it is called. `same-callback` is what actually calls your `callback` and, when it does, it supplies any necessary args, including those supplied at wrapper creation time and any supplied by the browser (a DOM event object?) at call time.\" [ the-real-callback ] ( let [ *args1 ( atom nil ) same-callback ( fn [ & args2 ] ( apply the-real-callback ( concat @ *args1 args2 )))] ( fn callback-factory [ & args1 ] ( reset! *args1 args1 ) same-callback ))) ;; <-- always returns the same function More Advanced Again \u00b6 Sometimes the callback will need to accept a DOM event argument. In the following code, notice on-change : ( defn some-input-view [ _ ] ( let [ on-change ( fn [ id dom-event ] ;; <-- Note 1 ( dispatch [ :changed id ( -> dom-event .-target .-value )])) on-change-factory ( callback-factory-factory on-change )] ( fn [ id text ] [ :input { :type \"text\" :value text :on-change ( on-change-factory id )}] ]))) ;; <-- Note 2 Note: this time the callback, on-change , takes two arguments. The id and the DOM event dom-event But, when we call the factory we only supply one of these two arguments, almost like this is a \"partial\". The browser will be supplying dom-event later when it calls the callback. Summary \u00b6 This page introduces an advanced technique. Reagent's method for avoiding unnecessary re-renders is subverted by \"anonymous functions\" and, specifically, callbacks which are generated by successive renders. These functions do not test equal to each other, even though we programmers can see they are the same each time. Most of the time, we ignore this issue. We happily accept the small inefficiency this potentially causes because we get to write clear, terse code, and we value that highly. But, in some rare situations, this small inefficiency can accumulate into a problem when there are large numbers of the same components simultaneously on a page, and when they are unnecessarily redrawn a lot. When it does become a problem, this page showed you a technique for fixing the issue, but it comes at the cost of you having to write more code, and introduce an abstraction based on callback-factory-factory .","title":"Stable Dom Handlers"},{"location":"on-stable-dom-handlers/#equality-tests","text":"Equality tests are at the heart of the issue, so let's start by considering this one: ( = [ 1 :2 \"3\" ] [ 1 :2 \"3\" ]) Question : will it evaluate to true or false ? Answer : true . Because the elements 1 , :2 and \"3\" are identities, so different instances test equal, and because vector equality is determined by element equality.","title":"Equality Tests"},{"location":"on-stable-dom-handlers/#implications-for-reagent","text":"Reagent uses equality checks on props to avoid doing unnecessary work. Consider this view: ( defn parent [ x ] [ child 1 :2 \"3\" ]) Imagine that parent has already rendered once. And then something causes it to re-render (perhaps its parent re-renders and supplies a different x ). When parent re-renders, it will re-render child and supply three props: 1 , :2 and \"3\" . But these props will be the same as the ones supplied with the \"last render\" and, as a result, Reagent calculates that it doesn't need to perform the re-render of child . Reagent assumes that child is rendered by a pure function and it deduces that giving a pure function the same props/args as last time, results in the same result (the same hiccup). And so Reagent avoids doing this unnecessary work. It is an efficiency thing. Question : But how does Reagent check for this \"sameness\" between the props supplied \"this render\" vs the \"last render\"? Answer : by testing the props using = So: 1 (last time) is = to 1 (this time) :2 is = to :2 and \"3\" too is equal to last time All three props are = to last time, which allows Reagent to skip the re-render of child .","title":"Implications For Reagent"},{"location":"on-stable-dom-handlers/#but-wait-functions","text":"Next step: we introduce anonymous callback functions. Consider this test: ( = ( fn [ n ] ( + n 1 )) ( fn [ n ] ( + n 1 ))) Question : will it evaluate to true or false ? Answer : false . You might be able to see that the two anonymous functions are equal, but = says \"no\". Anonymous functions are not like 1 or :2 Armed with this knowledge, what happens if we add a new prop for child and make it an anonymous callback function? Like this: ( defn parent [ x ] [ child 1 :2 \"3\" ( fn [] ( dispatch [ :something ]))]) So, that's now four props given to child . The first three of them are as before. But the new last one is an anonymous function. What a difference that new one makes!! Now, every time parent is re-rendered, child will also be re-rendered. Every time. Reagent's efficiency checks which try to avoid unnecessary work are broken when one prop is an anonymous function because the value \"this time\" does not test = to last time, even though we can see they are the same function.","title":"But Wait, Functions"},{"location":"on-stable-dom-handlers/#fixing-it","text":"Surely the way to fix this is simple: don't use an anonymous function. First we create: ( defn callback [] ( dispatch [ :something ])) Then we perform a test: ( = callback callback ) Question : what will it evaluate to? true or false ? Answer : true . callback is a symbol which is bound to a function. So we are comparing the value bound to callback (a function), and that will test = because it is the same function on both sides of = . Let's use that; ( defn parent [ x ] [ child 1 :2 \"3\" callback ]) ;; <--- used here Now all four props for child will test = to last time. And child won't be re-rendered. In fact, we can make this simpler by using a Form-2 function: ( defn parent [ x ] ( let [ callback # ( dispatch [ :something ])] ;; <-- create here ( fn [ x ] [ child 1 :2 \"3\" callback ]))) The outside function creates the anonymous function, which means it doesn't get recreated and change on each render, and so callback will test = to \"last time\" in all renders. Problem fixed? Yes, but unfortunately, only for the simple case. Which really means \"no, not fixed enough\".","title":"Fixing It"},{"location":"on-stable-dom-handlers/#where-it-breaks-down","text":"Say, parent has an argument id . And, say, we need to use that in the callback. ( defn parent [ id ] ( let [ callback ( fn [] ( dispatch [ :something id ]))] ( fn [ id ] [ child 1 :2 \"3\" callback ]))) Does this work? Sadly, no. Can you spot the bug? callback has closed over the original value for id - the one given to the outer function. callback will never dispatch the \"latest\" value of id provided to the re-render function (notice that id is an argument to both the outer and inner functions in the Form-2 Component).","title":"Where It Breaks Down"},{"location":"on-stable-dom-handlers/#the-technique","text":"So, enough preamble and explanation, here's the real solution - and it has three parts: ( defn parent [ id ] ( let [ callback ( fn [ the-id ] ( dispatch [ :something the-id ])) ;; <-- Note 1 callback-factory ( callback-factory-factory callback )] ;; <-- Note 2 ( fn [ id ] [ child 1 :2 \"3\" ( callback-factory id )]) ;; <-- Note 3 Notes: callback no longer tries to \"close over' id . Instead, it takes id as an argument. callback-factory-factory has a long name, and it performs the trick. It returns a function which, when called, will always return the same function, which wraps callback . (code supplied below) Each time we call callback-factory , it will return the same function. But it does it in a way which allows for id to vary on each render. Which only leaves me to show you the hero in our story, which I offer without further explanation for you to read and understand: ( defn callback-factory-factory \"returns a function which will always return the `same-callback` every time it is called. `same-callback` is what actually calls your `callback` and, when it does, it supplies any necessary args, including those supplied at wrapper creation time and any supplied by the browser (a DOM event object?) at call time.\" [ the-real-callback ] ( let [ *args1 ( atom nil ) same-callback ( fn [ & args2 ] ( apply the-real-callback ( concat @ *args1 args2 )))] ( fn callback-factory [ & args1 ] ( reset! *args1 args1 ) same-callback ))) ;; <-- always returns the same function","title":"The Technique"},{"location":"on-stable-dom-handlers/#more-advanced-again","text":"Sometimes the callback will need to accept a DOM event argument. In the following code, notice on-change : ( defn some-input-view [ _ ] ( let [ on-change ( fn [ id dom-event ] ;; <-- Note 1 ( dispatch [ :changed id ( -> dom-event .-target .-value )])) on-change-factory ( callback-factory-factory on-change )] ( fn [ id text ] [ :input { :type \"text\" :value text :on-change ( on-change-factory id )}] ]))) ;; <-- Note 2 Note: this time the callback, on-change , takes two arguments. The id and the DOM event dom-event But, when we call the factory we only supply one of these two arguments, almost like this is a \"partial\". The browser will be supplying dom-event later when it calls the callback.","title":"More Advanced Again"},{"location":"on-stable-dom-handlers/#summary","text":"This page introduces an advanced technique. Reagent's method for avoiding unnecessary re-renders is subverted by \"anonymous functions\" and, specifically, callbacks which are generated by successive renders. These functions do not test equal to each other, even though we programmers can see they are the same each time. Most of the time, we ignore this issue. We happily accept the small inefficiency this potentially causes because we get to write clear, terse code, and we value that highly. But, in some rare situations, this small inefficiency can accumulate into a problem when there are large numbers of the same components simultaneously on a page, and when they are unnecessarily redrawn a lot. When it does become a problem, this page showed you a technique for fixing the issue, but it comes at the cost of you having to write more code, and introduce an abstraction based on callback-factory-factory .","title":"Summary"},{"location":"re-frame/","text":"A framework for building Modern Web Apps in ClojureScript. It leverages React, via Reagent . McCoy might report \"It's MVC, Jim, but not as we know it\". And you would respond \"McCoy, you trouble maker, why even mention an OO pattern? re-frame is a functional framework .\" So, it is about data , and the functions which transform that data. And, because it is a reactive framework , data coordinates functions , not the other way around. Why Should You Care? \u00b6 Perhaps: You want to develop a modern web application using ClojureScript. You want to maximise developer productivity by writing fewer lines of code . You want a simple dynamic process that you can simulate in your head. And you want a clean approach to effects and state management. You are curious about the benefits of data-oriented design . You are a refugee from technical churn, seeking stability and productivity. For six years, ClojureScript, Reagent and re-frame have barely changed. No need. Still cutting edge. You want to see how reactive programming , functional programming and immutable data combine in a language that genuinely embraces those paradigms. You're taking a Functional Design and Programming course at San Diego State University and you have a re-frame assignment due. You've left the reading a bit late, right? You seek a better Redux, Elm, Cycle.js or Pux. In this space, re-frame is very old, hopefully in a Gandalf kind of way. Designed in late 2014, it slightly pre-dates the official Elm Architecture, although thankfully we picked up foldp ideas from early Elm games. Our main inspiration was the Clojure projects Pedestal App , Hoplon and Om . Since then, re-frame has pioneered ideas like event handler middleware, coeffect accretion, and de-duplicated signal graphs. Which brings us to the most important point: re-frame is impressively buzzword compliant . It has reactivity, unidirectional data flow, pristinely pure functions, interceptors, coeffects, conveyor belts, algebraic effects, statechart-friendliness and claims an immaculate hammock conception. All while being both simple and easy. There's also a charming xkcd reference (soon) and a hilarious, insiders-joke T-shirt, ideal for conferences (in design). What could possibly go wrong? It Is Mature \u00b6 re-frame was released in early 2015, and has since been successfully used by many a companies and individuals to build complex apps, many running beyond 40K lines of ClojureScript. Scale changes everything. Frameworks are just pesky overhead at small scale - measure them instead by how they help you tame the complexity of bigger apps, and in this regard re-frame has worked out well. Some have been effusive in their praise. And, yes, re-frame is fast, straight out of the box. And, yes, it has a good testing story (unit and behavioural). And, yes, it works with tools like figwheel or shadow-cljs to create a powerful hot-loading development story. And, yes, it has fun specialist tooling, and a community, and useful 3rd party libraries. \u00b6","title":"re-frame"},{"location":"re-frame/#why-should-you-care","text":"Perhaps: You want to develop a modern web application using ClojureScript. You want to maximise developer productivity by writing fewer lines of code . You want a simple dynamic process that you can simulate in your head. And you want a clean approach to effects and state management. You are curious about the benefits of data-oriented design . You are a refugee from technical churn, seeking stability and productivity. For six years, ClojureScript, Reagent and re-frame have barely changed. No need. Still cutting edge. You want to see how reactive programming , functional programming and immutable data combine in a language that genuinely embraces those paradigms. You're taking a Functional Design and Programming course at San Diego State University and you have a re-frame assignment due. You've left the reading a bit late, right? You seek a better Redux, Elm, Cycle.js or Pux. In this space, re-frame is very old, hopefully in a Gandalf kind of way. Designed in late 2014, it slightly pre-dates the official Elm Architecture, although thankfully we picked up foldp ideas from early Elm games. Our main inspiration was the Clojure projects Pedestal App , Hoplon and Om . Since then, re-frame has pioneered ideas like event handler middleware, coeffect accretion, and de-duplicated signal graphs. Which brings us to the most important point: re-frame is impressively buzzword compliant . It has reactivity, unidirectional data flow, pristinely pure functions, interceptors, coeffects, conveyor belts, algebraic effects, statechart-friendliness and claims an immaculate hammock conception. All while being both simple and easy. There's also a charming xkcd reference (soon) and a hilarious, insiders-joke T-shirt, ideal for conferences (in design). What could possibly go wrong?","title":"Why Should You Care?"},{"location":"re-frame/#it-is-mature","text":"re-frame was released in early 2015, and has since been successfully used by many a companies and individuals to build complex apps, many running beyond 40K lines of ClojureScript. Scale changes everything. Frameworks are just pesky overhead at small scale - measure them instead by how they help you tame the complexity of bigger apps, and in this regard re-frame has worked out well. Some have been effusive in their praise. And, yes, re-frame is fast, straight out of the box. And, yes, it has a good testing story (unit and behavioural). And, yes, it works with tools like figwheel or shadow-cljs to create a powerful hot-loading development story. And, yes, it has fun specialist tooling, and a community, and useful 3rd party libraries.","title":"It Is Mature"},{"location":"re-frame/#_1","text":"","title":""},{"location":"reagent/","text":"Clojurescript is ergonomic, stable, functional language Look at the front page of https://www.learnreframe.com/ (ns simple.core (:require [reagent.dom :as rdom] [re-frame.core :as rf] [clojure.string :as str]))) (defn square [] [:svg {:width \"400\" :height \"110\"} [:rect {:width \"300\" :height \"100\"}]]) [square] (defn mount-ui [] (rdom/render [square] ;; mount the application's ui (js/document.getElementById \"live-app\"))) (mount-ui) The live application should start here in 60 seconds ... Doesn't work? Maybe try disabling your adblocker for this site. (defn square [colour size] [:div {:style {:width (str (or size \"20\") \"px\") :height (str (or size \"20\") \"px\") :display \"inline-block\" :background-color colour}}]) [:div [square \"blue\" 40] [square \"green\"]] XXX work from Atoms \u00b6 Atoms are a clojure language concept. They provide a way to store a mutable value - a value which can change over time. This value in an atom might be an int or a map ... anything. You used the function deref to o obtain the value held in an atom. So if a is an atom, then (deref a) will extrct the value. The shorthand is @a . You can set the value of an atom with reset! , like this (reset! a :foo) . Alternatively, you canuse swap! to update the value in an atom. swap! takes a pure function as an argument which is to perform this update . It is expected to takes the current value in the atom as an argument, and to return the updated value to be put back in the atom. For example (swap! a + 5 6) will call the function + with three values: the value in a and 5 and 6 . So this will effectively add 11 to the value currently in a and store that value back into a .","title":"Reagent"},{"location":"reagent/#atoms","text":"Atoms are a clojure language concept. They provide a way to store a mutable value - a value which can change over time. This value in an atom might be an int or a map ... anything. You used the function deref to o obtain the value held in an atom. So if a is an atom, then (deref a) will extrct the value. The shorthand is @a . You can set the value of an atom with reset! , like this (reset! a :foo) . Alternatively, you canuse swap! to update the value in an atom. swap! takes a pure function as an argument which is to perform this update . It is expected to takes the current value in the atom as an argument, and to return the updated value to be put back in the atom. For example (swap! a + 5 6) will call the function + with three values: the value in a and 5 and 6 . So this will effectively add 11 to the value currently in a and store that value back into a .","title":"Atoms"},{"location":"reusable-components/","text":"In re-frame, there are two kinds of Component: Reagent Components - widgets representing a single value, like a number or choice or string re-frame Components - larger widget complexes, often representing an entity The Essence Of A Component \u00b6 All Components have: two responsibilities and two associated requirements The two responsibilities: to render a value That value could be as simple as a string or as complicated as an entire Pivot Table. It may, optionally, also render affordances allowing the user to modify the value. E.g. a spinner supplies up/down buttons. Or, for a pivot table, the user can drag \"dimension fields\" from one place to another to configure the data rollups it displays. to capture and communicate user intent if the user interacts with the Component to modify the value, then it must communicate the user's intent to the surrounding application logic, so it can be interpreted and acted upon. To fulfil these two responsibilities, Components have two associated requirements : a way to obtain the value they represent a way to communicate user intent One of these requirements relates to Input (obtaining), and the other to Output (communicating intent), so we'll collectively refer to them as the Component's I/O requirements . Reagent Components \u00b6 The simplest Components are Widgets , which represent a single value like an integer, string or selection. You can create them from base HTML elements such as <input> or <select> using only Reagent (no re-frame) and, for that reason, they are referred to as Reagent Components . Here's an example: ( defn simple-text-input [ value callback-fn ] [ :input { :type \"text\" :value value ;; initial value :on-change # ( callback-fn ( -> % .-target .-value ))}]) ;; callback with value You'll notice that both of this Component's I/O requirements are provided via two positional arguments: a value (input) a callback function - a means of communicating the user's intent for change (output) Because both of these requirements are satisfied via arguments, this Component is quite reusable. We could use it for any string value. But, of course, the responsibility for providing I/O requirements doesn't disappear. It has just been shifted to the parent Component. This parent will have to act as the glue which \"wires\" this reusable Component into an application context, providing the value and actioning user intent. re-frame Components \u00b6 A re-frame Component is different from a Reagent Component . because of how it satisfies its I/O requirements : it will use subscribe to obtain values (input) it will use dispatch to communicate events modelling user intent (output) re-frame Components tend to be larger. They often represent an entire entity (not just a single, simple value) and they might involve a \"complex of widgets\" with a cohesive purpose. Here's an example: ( defn customer-names [] ( let [ customer @ ( subscribe [ :customer ])] ;; obtain the customer entity [ :div \"Name:\" ; first name [ simple-text-input ( :first-name customer ) ;; first-name from entity # ( dispatch [ :change-customer :first-name % ])] ;; first name changed ;; last name [ simple-text-input ( :last-name customer ) ;; last-name from entity # ( dispatch [ :change-customer :last-name % ])]])) ;; last name changed Notes: This is a re-frame Component because it uses subscribe and dispatch to provide its I/O requirements It composes two other components - Reagent components - the reusable simple-text-input we created above It parameterises the I/O requirements for the two sub-components by supplying a value and a callback to each Many Instances \u00b6 But this re-frame Component only works when there is one Customer - you'll notice it contained the code: ( subscribe [ :customer ]) What if our application has many Customers ? We'd want a Component that can represent any one of them, or we might need to render many Customers in the UI at once (not just one at a time). How then should we rewrite this Component so it can represent Customer entity A one time, and Customer entity B another time? A Component instance representing entity A would have to subscribe to the value representing A . And any events it dispatches must cause changes to A , not B . Method: supply each Component instance with the identity of the Customer entity it should represent this identity is supplied as an argument (typically) each Component instance will use this identity within the query vector given to subscribe - so the query is parameterised by the identity the subscription handler will use this identity to obtain the entity's value likewise, when events are dispatched , they too will include identity , so the event handler knows which entity to modify Here's the rewrite which implements this method: ( defn customer-names [ id ] ;; customer `id` as argument ( let [ customer @ ( subscribe [ :customer id ])] ;; obtain the value using `id` [ :div \"Name:\" ; first name [ simple-text-input ( :first-name customer ) # ( dispatch [ :change-customer id :first-name % ])] ;; include `id` ;; last name [ simple-text-input ( :last-name customer ) # ( dispatch [ :change-customer id :last-name % ])]])) ;; include `id` What Is Identity? \u00b6 An identity distinguishes one entity from another - it is something that distinguishes the entity A from entity B . In a different technology context, it might be called \"a pointer\" (a memory address), \"a reference\" or \"a unique key\". Every entity is stored in app-db and, consequently, one reliable identity is the path to that entity's location within app-db . Such paths are vectors - paths are data. They are like a pointer to a place within app-db . So, the identity for entity A could be the path vector to A 's location, for example [:entities :customers 123] . In effect, if you did: ( get-in db [ :entities :customers 123 ]) you would get the entity. And the identity for B might be the same other than for the last element, [:entities :customers 456] . In this fictional scenario, the entities A and B are both stored in a map the location [:entities :customers] within app-db , but you would access them via different keys in that map ( 123 vs 456 ). Sometimes, the identity need only be the last part of the path - the 123 or 456 part in the example above. The location of the map, [:entities :customers] , within app-db could be \"known\" by the subscription handlers and event handlers, so it doesn't have to be provided, and only the final part of the path (a key in the map at that location) is needed to distinguish two identities. So, in summary, an identity is usually a path or a path segment. Using Identity \u00b6 Here's how we could use our reusable Component multiple times on one page to show many customers: ( defn customer-list [] [ :div ( for [ id @ ( subscribe [ :all-customer-ids ])] ^ { :key id } [ customer-names id ])]) Notice that id is provided for each instance (see the code [customer-names id] ). That's the entity identity. Multiple Identities \u00b6 Sometimes we need to provide more than one identity to a Component. For example, a dropdown Component might need: one identity for the list of alternative \"choices\" available to the user to select one identity for the current choice (value) held elsewhere within app-db Such a Component would need two arguments (props) for these two identities , and it would need a way to use the identities in subscriptions. Computed Identities \u00b6 identities are data, and you can compute data. When a parent Component has a child sub-component, the parent might provide its child with an identity which is derivative of the id supplied to it. Perhaps this identity is built by conj -ing a further value onto the original id . There are many possibilities. In another situation, the id provided to a component might reference an entity that itself \"contains\" the identity of a different entity - a reference to a reference. So, the Component might have to subscribe to the primary entity and then, in a second step, subscribe to the derived entity. If we explore these ideas far enough, we leave behind discussions about re-frame and start, instead, to discuss the pros and cons of the \"data model\" you have created within app-db . Components In A Library \u00b6 Have you noticed the need for close coordination between a re-frame Component and the subscriptions and dispatches which service it's I/O Requirements? A re-frame Component doesn't stand by itself - it isn't the unit of reuse. Because a Component has two I/O requirements, the unit of reuse is the re-frame Component plus the mechanism needed to service those I/O requirements. That's what should be packaged up and put in your library if you want to reuse a Component across multiple applications. So, just to be clear: the unit of reuse is the combination of: the Component the subscription handlers which service its need to obtain values the event handlers which service the user intent it captures Implications \u00b6 Because a reusable re-frame Component has three parts, there is another level of abstraction possible. Until now, I've said that a re-frame Component is defined by its use of subscribe and dispatch , but maybe it doesn't have to be that way. Here is a rewrite of that earlier Component: ( defn customer-names [ id get-customer-fn cust_change-fn ] ( let [ customer ( get-customer-fn id )] ;; obtain the value [ :div \"Name:\" ;; first name [ simple-text-input ( :first-name customer ) ;; obtain first-name from the entity # ( cust_change-fn id :first-name % )] ;; first name has changed ;; last name [ simple-text-input ( :last-name customer ) ;; obtain last-name from the entity # ( cust_change-fn id :last-name % )]])) ;; last name has changed Notes: there's now no sign of dispatch or subscribe instead, the Component is parameterised by two extra function arguments these functions handle the I/O requirements it is almost as if we have gone full circle now, and we're back to something which looks like a Reagent Component. Remember that one at the very top? The I/O requirements were handled via arguments, which shifts \"knowledge\" about the application context to the parent. Let's rewrite customer-list in terms of this new Component: ( defn customer-list [] ( let [ get-customer ( fn [ id ] @ ( subscribe [ :customer id ])) put-customer ( fn [ id field val ] ( dispatch [ :cust-change id field val ]))]) [ :div ( for [ id @ ( subscribe [ :all-customer-ids ])] ^ { :key id } [ customer-names id get-customer put-customer ])]) Notes: we create I/O functions which wrap subscribe and dispatch these two functions are passed into the sub-component as arguments But does this approach mean the customer-names Component is now more reusable? Well, yes, probably. The exact subscription query to use is now no longer embedded in the Component itself. The surrounding application supplies that. The Component has become even more independent of its context. It is even more reusable and flexible. On the downside, the parent context has more \"knowledge\" and responsibility. It has to \"wire\" the Component into the application. Obviously, there's always a cost to abstraction. So, you'll have to crunch the cost-benefit analysis for your situation. Reusability \u00b6 There are two levels of reusability: reusability within a particular application. You want to use a Component across multiple entities and perhaps in different widget ensembles within the one application. reusability across applications. Put the Component in a library. Reagent components are reusable in both ways - just look at a library like re-com . With re-frame Components , reuse is fairly easy within the one application, but when you try to put them in a library for use across multiple applications you run into a challenge to solve: placefulness . We noted earlier that re-frame Components extend to include the handlers which look after the I/O requirements. And those I/O handlers have to know where , within app-db to obtain and update data. But, from one application to another, the path (the place) where entities are stored can change. A library Component should not be dictating this \"place\" to the applications which use it. Solving Placefulness \u00b6 First , you could ignore the issue because either: 1. you have a single app to maintain, and you are optimising for simplicity (over generality and reusability) 2. you will avoid using re-frame components, and instead, you just use Reagent Components (e.g. we have a rather complicated Table Component which is just a Reagent Component) Second , to solve placefulness, you could standardise where entities are placed within app-db . You could mandate that entities are always stored at a known place (eg. [:entities :Customers] or [:entities :Products] ). You could then write your reusable components with this assumption, and all your applications adhere to this stipulation. You could perhaps use Subgraph . Third , you can parameterise the Component with base-path information via: - React context (probably not) - via args to the Component - ie. quite literally pass in the base path as an argument to the Component and then pass that along to the handlers by including that path in the dispatched event and subscription query vectors. Fourth , more radically, you could choose not to use the map in ratom approach that is app-db . We could use a data structure that is less placeful. Perhaps use a DataScript database via re-posh . Not doing - one thing we won't be doing is storing state in the Component itself, away from the central \"data store\". The moment we did that, we would have created multiple \"stores of state\", and then we'd have responsibility for coordinating the sync-ing of those data stores, a process which starts off looking simple enough but which soon envelops your architecture like an octopus. Managing distributed state is a much more difficult problem than placefulness. Summary \u00b6 Reagent components are readily reusable, and re-frame Components can be made reusable, subject to solving the placefulness issue.","title":"Reusable Components"},{"location":"reusable-components/#the-essence-of-a-component","text":"All Components have: two responsibilities and two associated requirements The two responsibilities: to render a value That value could be as simple as a string or as complicated as an entire Pivot Table. It may, optionally, also render affordances allowing the user to modify the value. E.g. a spinner supplies up/down buttons. Or, for a pivot table, the user can drag \"dimension fields\" from one place to another to configure the data rollups it displays. to capture and communicate user intent if the user interacts with the Component to modify the value, then it must communicate the user's intent to the surrounding application logic, so it can be interpreted and acted upon. To fulfil these two responsibilities, Components have two associated requirements : a way to obtain the value they represent a way to communicate user intent One of these requirements relates to Input (obtaining), and the other to Output (communicating intent), so we'll collectively refer to them as the Component's I/O requirements .","title":"The Essence Of A Component"},{"location":"reusable-components/#reagent-components","text":"The simplest Components are Widgets , which represent a single value like an integer, string or selection. You can create them from base HTML elements such as <input> or <select> using only Reagent (no re-frame) and, for that reason, they are referred to as Reagent Components . Here's an example: ( defn simple-text-input [ value callback-fn ] [ :input { :type \"text\" :value value ;; initial value :on-change # ( callback-fn ( -> % .-target .-value ))}]) ;; callback with value You'll notice that both of this Component's I/O requirements are provided via two positional arguments: a value (input) a callback function - a means of communicating the user's intent for change (output) Because both of these requirements are satisfied via arguments, this Component is quite reusable. We could use it for any string value. But, of course, the responsibility for providing I/O requirements doesn't disappear. It has just been shifted to the parent Component. This parent will have to act as the glue which \"wires\" this reusable Component into an application context, providing the value and actioning user intent.","title":"Reagent Components"},{"location":"reusable-components/#re-frame-components","text":"A re-frame Component is different from a Reagent Component . because of how it satisfies its I/O requirements : it will use subscribe to obtain values (input) it will use dispatch to communicate events modelling user intent (output) re-frame Components tend to be larger. They often represent an entire entity (not just a single, simple value) and they might involve a \"complex of widgets\" with a cohesive purpose. Here's an example: ( defn customer-names [] ( let [ customer @ ( subscribe [ :customer ])] ;; obtain the customer entity [ :div \"Name:\" ; first name [ simple-text-input ( :first-name customer ) ;; first-name from entity # ( dispatch [ :change-customer :first-name % ])] ;; first name changed ;; last name [ simple-text-input ( :last-name customer ) ;; last-name from entity # ( dispatch [ :change-customer :last-name % ])]])) ;; last name changed Notes: This is a re-frame Component because it uses subscribe and dispatch to provide its I/O requirements It composes two other components - Reagent components - the reusable simple-text-input we created above It parameterises the I/O requirements for the two sub-components by supplying a value and a callback to each","title":"re-frame Components"},{"location":"reusable-components/#many-instances","text":"But this re-frame Component only works when there is one Customer - you'll notice it contained the code: ( subscribe [ :customer ]) What if our application has many Customers ? We'd want a Component that can represent any one of them, or we might need to render many Customers in the UI at once (not just one at a time). How then should we rewrite this Component so it can represent Customer entity A one time, and Customer entity B another time? A Component instance representing entity A would have to subscribe to the value representing A . And any events it dispatches must cause changes to A , not B . Method: supply each Component instance with the identity of the Customer entity it should represent this identity is supplied as an argument (typically) each Component instance will use this identity within the query vector given to subscribe - so the query is parameterised by the identity the subscription handler will use this identity to obtain the entity's value likewise, when events are dispatched , they too will include identity , so the event handler knows which entity to modify Here's the rewrite which implements this method: ( defn customer-names [ id ] ;; customer `id` as argument ( let [ customer @ ( subscribe [ :customer id ])] ;; obtain the value using `id` [ :div \"Name:\" ; first name [ simple-text-input ( :first-name customer ) # ( dispatch [ :change-customer id :first-name % ])] ;; include `id` ;; last name [ simple-text-input ( :last-name customer ) # ( dispatch [ :change-customer id :last-name % ])]])) ;; include `id`","title":"Many Instances"},{"location":"reusable-components/#what-is-identity","text":"An identity distinguishes one entity from another - it is something that distinguishes the entity A from entity B . In a different technology context, it might be called \"a pointer\" (a memory address), \"a reference\" or \"a unique key\". Every entity is stored in app-db and, consequently, one reliable identity is the path to that entity's location within app-db . Such paths are vectors - paths are data. They are like a pointer to a place within app-db . So, the identity for entity A could be the path vector to A 's location, for example [:entities :customers 123] . In effect, if you did: ( get-in db [ :entities :customers 123 ]) you would get the entity. And the identity for B might be the same other than for the last element, [:entities :customers 456] . In this fictional scenario, the entities A and B are both stored in a map the location [:entities :customers] within app-db , but you would access them via different keys in that map ( 123 vs 456 ). Sometimes, the identity need only be the last part of the path - the 123 or 456 part in the example above. The location of the map, [:entities :customers] , within app-db could be \"known\" by the subscription handlers and event handlers, so it doesn't have to be provided, and only the final part of the path (a key in the map at that location) is needed to distinguish two identities. So, in summary, an identity is usually a path or a path segment.","title":"What Is Identity?"},{"location":"reusable-components/#using-identity","text":"Here's how we could use our reusable Component multiple times on one page to show many customers: ( defn customer-list [] [ :div ( for [ id @ ( subscribe [ :all-customer-ids ])] ^ { :key id } [ customer-names id ])]) Notice that id is provided for each instance (see the code [customer-names id] ). That's the entity identity.","title":"Using Identity"},{"location":"reusable-components/#multiple-identities","text":"Sometimes we need to provide more than one identity to a Component. For example, a dropdown Component might need: one identity for the list of alternative \"choices\" available to the user to select one identity for the current choice (value) held elsewhere within app-db Such a Component would need two arguments (props) for these two identities , and it would need a way to use the identities in subscriptions.","title":"Multiple Identities"},{"location":"reusable-components/#computed-identities","text":"identities are data, and you can compute data. When a parent Component has a child sub-component, the parent might provide its child with an identity which is derivative of the id supplied to it. Perhaps this identity is built by conj -ing a further value onto the original id . There are many possibilities. In another situation, the id provided to a component might reference an entity that itself \"contains\" the identity of a different entity - a reference to a reference. So, the Component might have to subscribe to the primary entity and then, in a second step, subscribe to the derived entity. If we explore these ideas far enough, we leave behind discussions about re-frame and start, instead, to discuss the pros and cons of the \"data model\" you have created within app-db .","title":"Computed Identities"},{"location":"reusable-components/#components-in-a-library","text":"Have you noticed the need for close coordination between a re-frame Component and the subscriptions and dispatches which service it's I/O Requirements? A re-frame Component doesn't stand by itself - it isn't the unit of reuse. Because a Component has two I/O requirements, the unit of reuse is the re-frame Component plus the mechanism needed to service those I/O requirements. That's what should be packaged up and put in your library if you want to reuse a Component across multiple applications. So, just to be clear: the unit of reuse is the combination of: the Component the subscription handlers which service its need to obtain values the event handlers which service the user intent it captures","title":"Components In A Library"},{"location":"reusable-components/#implications","text":"Because a reusable re-frame Component has three parts, there is another level of abstraction possible. Until now, I've said that a re-frame Component is defined by its use of subscribe and dispatch , but maybe it doesn't have to be that way. Here is a rewrite of that earlier Component: ( defn customer-names [ id get-customer-fn cust_change-fn ] ( let [ customer ( get-customer-fn id )] ;; obtain the value [ :div \"Name:\" ;; first name [ simple-text-input ( :first-name customer ) ;; obtain first-name from the entity # ( cust_change-fn id :first-name % )] ;; first name has changed ;; last name [ simple-text-input ( :last-name customer ) ;; obtain last-name from the entity # ( cust_change-fn id :last-name % )]])) ;; last name has changed Notes: there's now no sign of dispatch or subscribe instead, the Component is parameterised by two extra function arguments these functions handle the I/O requirements it is almost as if we have gone full circle now, and we're back to something which looks like a Reagent Component. Remember that one at the very top? The I/O requirements were handled via arguments, which shifts \"knowledge\" about the application context to the parent. Let's rewrite customer-list in terms of this new Component: ( defn customer-list [] ( let [ get-customer ( fn [ id ] @ ( subscribe [ :customer id ])) put-customer ( fn [ id field val ] ( dispatch [ :cust-change id field val ]))]) [ :div ( for [ id @ ( subscribe [ :all-customer-ids ])] ^ { :key id } [ customer-names id get-customer put-customer ])]) Notes: we create I/O functions which wrap subscribe and dispatch these two functions are passed into the sub-component as arguments But does this approach mean the customer-names Component is now more reusable? Well, yes, probably. The exact subscription query to use is now no longer embedded in the Component itself. The surrounding application supplies that. The Component has become even more independent of its context. It is even more reusable and flexible. On the downside, the parent context has more \"knowledge\" and responsibility. It has to \"wire\" the Component into the application. Obviously, there's always a cost to abstraction. So, you'll have to crunch the cost-benefit analysis for your situation.","title":"Implications"},{"location":"reusable-components/#reusability","text":"There are two levels of reusability: reusability within a particular application. You want to use a Component across multiple entities and perhaps in different widget ensembles within the one application. reusability across applications. Put the Component in a library. Reagent components are reusable in both ways - just look at a library like re-com . With re-frame Components , reuse is fairly easy within the one application, but when you try to put them in a library for use across multiple applications you run into a challenge to solve: placefulness . We noted earlier that re-frame Components extend to include the handlers which look after the I/O requirements. And those I/O handlers have to know where , within app-db to obtain and update data. But, from one application to another, the path (the place) where entities are stored can change. A library Component should not be dictating this \"place\" to the applications which use it.","title":"Reusability"},{"location":"reusable-components/#solving-placefulness","text":"First , you could ignore the issue because either: 1. you have a single app to maintain, and you are optimising for simplicity (over generality and reusability) 2. you will avoid using re-frame components, and instead, you just use Reagent Components (e.g. we have a rather complicated Table Component which is just a Reagent Component) Second , to solve placefulness, you could standardise where entities are placed within app-db . You could mandate that entities are always stored at a known place (eg. [:entities :Customers] or [:entities :Products] ). You could then write your reusable components with this assumption, and all your applications adhere to this stipulation. You could perhaps use Subgraph . Third , you can parameterise the Component with base-path information via: - React context (probably not) - via args to the Component - ie. quite literally pass in the base path as an argument to the Component and then pass that along to the handlers by including that path in the dispatched event and subscription query vectors. Fourth , more radically, you could choose not to use the map in ratom approach that is app-db . We could use a data structure that is less placeful. Perhaps use a DataScript database via re-posh . Not doing - one thing we won't be doing is storing state in the Component itself, away from the central \"data store\". The moment we did that, we would have created multiple \"stores of state\", and then we'd have responsibility for coordinating the sync-ing of those data stores, a process which starts off looking simple enough but which soon envelops your architecture like an octopus. Managing distributed state is a much more difficult problem than placefulness.","title":"Solving Placefulness"},{"location":"reusable-components/#summary","text":"Reagent components are readily reusable, and re-frame Components can be made reusable, subject to solving the placefulness issue.","title":"Summary"},{"location":"review-todomvc/","text":"Congratulations! You now know everything necessary to enjoy the todomvc example application within the re-frame repo. The code is heavily commented, and it will show you various re-frame features in action, together with providing useful practical advice. Don't skip this. Your review will be a very useful part of your learning process, and now is the right moment.","title":"Review TodoMVC"},{"location":"start-coding/","text":"Install Clojure \u00b6 Install Clojure and Leiningen (a build tool) by following these instructions . Use A Template \u00b6 Create a scaffold for your first project: Client only: https://github.com/day8/re-frame-template Full Stack: http://www.luminusweb.net/ Full Stack Example \u00b6 Take time to review a full stack application. RealWorld implements to the RealWorld Spec and API .","title":"START CODING"},{"location":"start-coding/#install-clojure","text":"Install Clojure and Leiningen (a build tool) by following these instructions .","title":"Install Clojure"},{"location":"start-coding/#use-a-template","text":"Create a scaffold for your first project: Client only: https://github.com/day8/re-frame-template Full Stack: http://www.luminusweb.net/","title":"Use A Template"},{"location":"start-coding/#full-stack-example","text":"Take time to review a full stack application. RealWorld implements to the RealWorld Spec and API .","title":"Full Stack Example"},{"location":"subscriptions/","text":"Subscriptions \u00b6 This tutorial covers dominoes 4, 5 and 6. There are just two API functions to understand - subscribe and reg-sub - but first let's get an overview. On Derived Data \u00b6 A UI is just derived data. A browser renders tree-shaped data called the DOM. Reagent renderers create DOM by computing hiccup-shaped data. Subscriptions deliver data to Reagent renderers. And, app-db is the root of this entire flow. When Domino 3 (an effect handler) modifies app-db , boom, boom, boom go dominoes 4, 5 & 6, computing stages of the \"materialised view\" that is ultimately DOM. Together these three dominoes implement a reactive dataflow. How Exactly? \u00b6 Data flows through The Signal Graph . app-db is the ground truth of a re-frame app, and it is at the root of a Directed Acyclic Graph (DAG) called the Signal Graph . At the other extent of this graph - at the leaves - are the View Functions , which calculate hiccup. Typically, the Signal Graph is not deep, with only a few interior layers of nodes between root and leaves. These interior nodes are the subscription nodes that you create via reg-sub . Or, more accurately, you use reg-sub to register how such interior nodes should be created, if and when they are needed. Data flows through this graph, being transformed by the interior nodes of its journey and, as a result, the data which arrives at the leaf View Functions will be a materialised view of what was originally in app-db . The nodes of the graph are pure functions. When data flows along an input arc and into a node, it becomes \"an argument\" (an input) to that node's pure function. That function will be \"called\" with the input arguments from input arcs, and it will calculate a return value, more data, which then flows along that node's output arcs to child nodes, where the process repeats. Ultimately, data is delivered into View Functions via a call to subscribe . It is derived data all the way through the graph. Even the hiccup produced by leaf nodes is just more derived data. A re-frame app is 75% derived data. I just made that number up, but you get the idea: there's quite a bit of it. Hell, the process doesn't even stop with leaf View Functions . Hiccup is turned into DOM, which is more derived data. And the browser turns DOM into pixels on your monitor - yep, more data. And a monitor turns pixels into photons (data, don't fight me here, I'm on a roll), which your eye cells detect and turn into chemicals reactions (data) which cause nerve cell signals (totally data), which reaches the priors in your brain (data). Derived data all the way, baby! Your brain is domino 12. Too much? Okay, fine. Just the Signal Graph, then. The Four Layers \u00b6 Conceptually, all nodes in the Signal Graph are a part of the same dataflow, but it is instructive to label them as follows: Layer 1 - Ground truth - is the root node, app-db Layer 2 - Extractors - subscriptions which extract data directly from app-db , but do no further computation. Layer 3 - Materialised View - subscriptions which obtain data from other subscriptions (never app-db directly), and compute derived data from their inputs Layer 4 - View Functions - the leaf nodes which compute hiccup (DOM). They subscribe to values calculated by Layer 2 or Layer 3 nodes. The simplest version of the Signal Graph has no Layer 3 (Materialised View) nodes. It only has Layer 2 (Extractor) subscriptions which take data from app-db , and those values then flow unchanged into Layer 4 (View Functions). In more complex cases, a View Function needs a materialised view of the data in app-db . A Layer 2 (extractor) subscription will obtain a data fragment of app-db which will then flow into a Layer 3 (materialized view) node which will compute derived data from it and, only then, does data flow into the Layer 4 (View Function) As Infographic \u00b6 Graph Creation \u00b6 Although data flows through the Signal Graph from app-db towards the View Functions , graph formation happens in the opposite direction. When a View Function uses a subscription, like this (subscribe [:something :needed]) , the sub-graph of nodes needed to service that subscription is created. The necessary sub-graph will \"grow backwards\" from the View Function all the way to app-db . So it is \"the data-thirsty demands\" of currently rendered View Functions which dictate what nodes exist in the Signal Graph . And, when a View Function is no longer rendered, the sub-graph needed to service its needs will be destroyed, unless it is still needed to service the needs of another, current View Function . Propagation Pruning \u00b6 The Signal Graph is reactive. When a node's inputs change, the node's subscription handler (function) re-runs automatically. The value it returns then becomes the node's new output value, and it will flow to downstream nodes in the graph, causing them to also re-run. But this only happens if the handler's output is different to the \"last time\" it ran. If a handler's return value \"this time\" is the same as \"last time\", data is not propagated to the sub-graph. No need. Nothing has changed. The computation for each node is performed by a pure function and a pure function will return the same value each time it is called with the same arguments. So, if we were to give a downstream node the same inputs as last time, it would produce the same outputs as last time, including the same hiccup at the leaves. Different How? \u00b6 Data values \"this time\" and \"last time\" are regarded as \"being the same\" if ClojureScript's = says they are. Why Layer 2 - Extractors? \u00b6 Why is a layer of \"extractors\" necessary? It is an efficiency thing. app-db will be changed by almost every event , often in a small, partial way. But any change whatsoever will cause all Layer2 (extractor) subscription to be automatically re-run. All of them. Every time. This is because app-db is their input value, and subscriptions re-run when one of their inputs change. Extractors obtain a data fragment from app-db and then immediately prune further propagation of that value if the fragment is the same \"last time\". As a consequence, the CPU intensive work in the Layer 3 (materialised view) and Layer 4 (View Functions) is only performed when necessary. Layer 2 (extractors) act as the Signal Graph's circuit breakers. We want them to be as computationally simple as possible. reg-sub \u00b6 Subscription handlers are registered using reg-sub . These handlers are the functions which take input values, flowing into the node, and calculate a derived value to be the node's output. Extractor subscriptions are registered like this: ( re-frame.core/reg-sub ;; a part of the re-frame API :id ;; usage: (subscribe [:id]) ( fn [ db query-v ] ;; `db` is the map out of `app-db` ( :something db ))) ;; trivial extraction - no computation This registers a computation function - a pretty simple one which just does an extraction. The argument query-v is the query vector supplied in the subscription. In our simple case here, we're not using it. But if the subscription was for (subscribe [:id \"blue\" :yeah]) then the query-v given to the handler would be [:id \"blue\" :yeah] . Layer 3 (materialised view) subscriptions depend on other subscriptions for their inputs, and they are registered like this: ( reg-sub :id ;; signals function ( fn [ query-v ] [( subscribe [ :a ]) ( subscribe [ :b 2 ])]) ;; <-- these inputs are provided to the computation function ;; computation function ( fn [[ a b ] query-v ] ;; input values supplied in a vector ( calculate-it a b ))) You supply two functions: a signals function which returns the input signals for this kind of node. It can return either a single signal, or a vector of signals, or a map where the values are the signals. In the example above, it is returning a 2-vector of signals. a computation function which takes the input values provided by the signals function , supplied as the first argument, and it produces a new derived value which will be the output of the node. Registration Doesn't Mean A Node Exists When you use reg-sub to register a handler, you are not immediately creating a node in the Signal Graph. At any one time, only those nodes required to service the needs of current View Functions will exist. Registering a handler only says how to create a Signal Graph node when and if it is needed. Syntactic Sugar \u00b6 The Layer 3 (materialized view) subscription above can be rewritten using some syntactic sugar: ( reg-sub :id ;; input signals :<- [ :a ] ;; means (subscribe [:a] is an input) :<- [ :b 2 ] ;; means (subscribe [:b 2] is an input) ;; computation function ( fn [[ a b ] query-v ] ( calculate-it a b )))","title":"Subscriptions"},{"location":"subscriptions/#subscriptions","text":"This tutorial covers dominoes 4, 5 and 6. There are just two API functions to understand - subscribe and reg-sub - but first let's get an overview.","title":"Subscriptions"},{"location":"subscriptions/#on-derived-data","text":"A UI is just derived data. A browser renders tree-shaped data called the DOM. Reagent renderers create DOM by computing hiccup-shaped data. Subscriptions deliver data to Reagent renderers. And, app-db is the root of this entire flow. When Domino 3 (an effect handler) modifies app-db , boom, boom, boom go dominoes 4, 5 & 6, computing stages of the \"materialised view\" that is ultimately DOM. Together these three dominoes implement a reactive dataflow.","title":"On Derived Data"},{"location":"subscriptions/#how-exactly","text":"Data flows through The Signal Graph . app-db is the ground truth of a re-frame app, and it is at the root of a Directed Acyclic Graph (DAG) called the Signal Graph . At the other extent of this graph - at the leaves - are the View Functions , which calculate hiccup. Typically, the Signal Graph is not deep, with only a few interior layers of nodes between root and leaves. These interior nodes are the subscription nodes that you create via reg-sub . Or, more accurately, you use reg-sub to register how such interior nodes should be created, if and when they are needed. Data flows through this graph, being transformed by the interior nodes of its journey and, as a result, the data which arrives at the leaf View Functions will be a materialised view of what was originally in app-db . The nodes of the graph are pure functions. When data flows along an input arc and into a node, it becomes \"an argument\" (an input) to that node's pure function. That function will be \"called\" with the input arguments from input arcs, and it will calculate a return value, more data, which then flows along that node's output arcs to child nodes, where the process repeats. Ultimately, data is delivered into View Functions via a call to subscribe . It is derived data all the way through the graph. Even the hiccup produced by leaf nodes is just more derived data. A re-frame app is 75% derived data. I just made that number up, but you get the idea: there's quite a bit of it. Hell, the process doesn't even stop with leaf View Functions . Hiccup is turned into DOM, which is more derived data. And the browser turns DOM into pixels on your monitor - yep, more data. And a monitor turns pixels into photons (data, don't fight me here, I'm on a roll), which your eye cells detect and turn into chemicals reactions (data) which cause nerve cell signals (totally data), which reaches the priors in your brain (data). Derived data all the way, baby! Your brain is domino 12. Too much? Okay, fine. Just the Signal Graph, then.","title":"How Exactly?"},{"location":"subscriptions/#the-four-layers","text":"Conceptually, all nodes in the Signal Graph are a part of the same dataflow, but it is instructive to label them as follows: Layer 1 - Ground truth - is the root node, app-db Layer 2 - Extractors - subscriptions which extract data directly from app-db , but do no further computation. Layer 3 - Materialised View - subscriptions which obtain data from other subscriptions (never app-db directly), and compute derived data from their inputs Layer 4 - View Functions - the leaf nodes which compute hiccup (DOM). They subscribe to values calculated by Layer 2 or Layer 3 nodes. The simplest version of the Signal Graph has no Layer 3 (Materialised View) nodes. It only has Layer 2 (Extractor) subscriptions which take data from app-db , and those values then flow unchanged into Layer 4 (View Functions). In more complex cases, a View Function needs a materialised view of the data in app-db . A Layer 2 (extractor) subscription will obtain a data fragment of app-db which will then flow into a Layer 3 (materialized view) node which will compute derived data from it and, only then, does data flow into the Layer 4 (View Function)","title":"The Four Layers"},{"location":"subscriptions/#as-infographic","text":"","title":"As Infographic"},{"location":"subscriptions/#graph-creation","text":"Although data flows through the Signal Graph from app-db towards the View Functions , graph formation happens in the opposite direction. When a View Function uses a subscription, like this (subscribe [:something :needed]) , the sub-graph of nodes needed to service that subscription is created. The necessary sub-graph will \"grow backwards\" from the View Function all the way to app-db . So it is \"the data-thirsty demands\" of currently rendered View Functions which dictate what nodes exist in the Signal Graph . And, when a View Function is no longer rendered, the sub-graph needed to service its needs will be destroyed, unless it is still needed to service the needs of another, current View Function .","title":"Graph Creation"},{"location":"subscriptions/#propagation-pruning","text":"The Signal Graph is reactive. When a node's inputs change, the node's subscription handler (function) re-runs automatically. The value it returns then becomes the node's new output value, and it will flow to downstream nodes in the graph, causing them to also re-run. But this only happens if the handler's output is different to the \"last time\" it ran. If a handler's return value \"this time\" is the same as \"last time\", data is not propagated to the sub-graph. No need. Nothing has changed. The computation for each node is performed by a pure function and a pure function will return the same value each time it is called with the same arguments. So, if we were to give a downstream node the same inputs as last time, it would produce the same outputs as last time, including the same hiccup at the leaves.","title":"Propagation Pruning"},{"location":"subscriptions/#different-how","text":"Data values \"this time\" and \"last time\" are regarded as \"being the same\" if ClojureScript's = says they are.","title":"Different How?"},{"location":"subscriptions/#why-layer-2-extractors","text":"Why is a layer of \"extractors\" necessary? It is an efficiency thing. app-db will be changed by almost every event , often in a small, partial way. But any change whatsoever will cause all Layer2 (extractor) subscription to be automatically re-run. All of them. Every time. This is because app-db is their input value, and subscriptions re-run when one of their inputs change. Extractors obtain a data fragment from app-db and then immediately prune further propagation of that value if the fragment is the same \"last time\". As a consequence, the CPU intensive work in the Layer 3 (materialised view) and Layer 4 (View Functions) is only performed when necessary. Layer 2 (extractors) act as the Signal Graph's circuit breakers. We want them to be as computationally simple as possible.","title":"Why Layer 2 - Extractors?"},{"location":"subscriptions/#reg-sub","text":"Subscription handlers are registered using reg-sub . These handlers are the functions which take input values, flowing into the node, and calculate a derived value to be the node's output. Extractor subscriptions are registered like this: ( re-frame.core/reg-sub ;; a part of the re-frame API :id ;; usage: (subscribe [:id]) ( fn [ db query-v ] ;; `db` is the map out of `app-db` ( :something db ))) ;; trivial extraction - no computation This registers a computation function - a pretty simple one which just does an extraction. The argument query-v is the query vector supplied in the subscription. In our simple case here, we're not using it. But if the subscription was for (subscribe [:id \"blue\" :yeah]) then the query-v given to the handler would be [:id \"blue\" :yeah] . Layer 3 (materialised view) subscriptions depend on other subscriptions for their inputs, and they are registered like this: ( reg-sub :id ;; signals function ( fn [ query-v ] [( subscribe [ :a ]) ( subscribe [ :b 2 ])]) ;; <-- these inputs are provided to the computation function ;; computation function ( fn [[ a b ] query-v ] ;; input values supplied in a vector ( calculate-it a b ))) You supply two functions: a signals function which returns the input signals for this kind of node. It can return either a single signal, or a vector of signals, or a map where the values are the signals. In the example above, it is returning a 2-vector of signals. a computation function which takes the input values provided by the signals function , supplied as the first argument, and it produces a new derived value which will be the output of the node. Registration Doesn't Mean A Node Exists When you use reg-sub to register a handler, you are not immediately creating a node in the Signal Graph. At any one time, only those nodes required to service the needs of current View Functions will exist. Registering a handler only says how to create a Signal Graph node when and if it is needed.","title":"reg-sub"},{"location":"subscriptions/#syntactic-sugar","text":"The Layer 3 (materialized view) subscription above can be rewritten using some syntactic sugar: ( reg-sub :id ;; input signals :<- [ :a ] ;; means (subscribe [:a] is an input) :<- [ :b 2 ] ;; means (subscribe [:b 2] is an input) ;; computation function ( fn [[ a b ] query-v ] ( calculate-it a b )))","title":"Syntactic Sugar"},{"location":"EPs/","text":"EP This directory contains re-frame \"Enhancement Proposals\" (EPs), one per file. Status \u00b6 Each EP proceeds through the following stages: - Placeholder - skeleton at best. One day someone might write something. - Drafting - some writing and thinking has been done, but it may be incoherent and/or wrong. - UnderReview - ready for general discussion in a specifically created (repo) Issue. - Accepted or Rejected - Released List \u00b6 EP 001 - Capture Handler Metadata - Drafting EP 002 - Multiple re-frame Instances - Drafting EP 003 - Reusable Components Via context - Placeholder EP 004 - View Registration - Placeholder EP 005 - State Machines - Placeholder","title":"Index"},{"location":"EPs/#status","text":"Each EP proceeds through the following stages: - Placeholder - skeleton at best. One day someone might write something. - Drafting - some writing and thinking has been done, but it may be incoherent and/or wrong. - UnderReview - ready for general discussion in a specifically created (repo) Issue. - Accepted or Rejected - Released","title":"Status"},{"location":"EPs/#list","text":"EP 001 - Capture Handler Metadata - Drafting EP 002 - Multiple re-frame Instances - Drafting EP 003 - Reusable Components Via context - Placeholder EP 004 - View Registration - Placeholder EP 005 - State Machines - Placeholder","title":"List"},{"location":"EPs/001-CaptureHandlerMetadata/","text":"EP 001 - Better Capture Of Handler Metadata \u00b6 Status: Drafting. May be incoherent and/or wrong. Don't read. Abstract \u00b6 This EP proposes changes to the way re-frame handlers are registered, to allow for the capture of richer handler metadata. These changes also lay the groundwork for tooling advances, and EPs to follow. Background \u00b6 re-frame's API currently includes 7 functions for registering handlers: - event: reg-event-db , reg-event-fx and reg-event-ctx - subscription: reg-sub and reg-sub-raw - effects: reg-fx - coeffects: reg-cofx Two others are on the drawing board: - reg-view - reg-interceptor So, there are potentially 9 kinds of handlers. Internally, re-frame manages registered handlers in a registrar , which is a two-level map, keyed at the first level by the kind of handler and, at the second level,\\by the (keyword) id of the handler. The leaf values are the handler functions themselves. Introduction \u00b6 This EP proposes that: 1. all current registration functions in the API be superseded by a new single macro reg 2. the leaf nodes of the registrar , which are currently the handler functions themselves, become instead a map of values related to the handler, including a doc string, the file/line where defined, specs, etc, and, of course, the handler itself. Motivations \u00b6 There's pressure from multiple directions to collect and retain more metadata about handlers: - tickets like #457 want docstrings for handlers - adding specs for events, so they can be checked at dev time - when re-frame becomes less of a framework and more of a library, handlers might need be \"grouped\" into \"packages\". So \"package\" information about handlers need to be supplied and retained. - Tooling support - we'd like re-frame-10x to actively help programmers when they are learning a new codebase. That's one of the four stated goals . Ideally, re-frame would be capable of providing tooling with \"a complete inventory\" of an app's handlers, along with useful metadata on each handles. When an event is processed, the audit trail of handlers involved should be rich with information. Macro \u00b6 As part of the retained handler metadata, we'd like to automatically capture source code coordinates, like namespace and line number. To make this happen, a macro will need to be introduced for registration, and that's a shift in approach because, until now, macros have been manfully resisted. Introducing docstrings into registrations also encourages a macro solution because docstrings should be removed from production builds. Method \u00b6 A new macro reg will become the method of registering handlers. The existing 7 registration functions will ultimately be deprecated. reg will take one argument, a map, which captures all aspects of the handler. Examples \u00b6 Previously, reg-event-db was used like this: ( rf/reg-event-db :event-id ( fn [ db event ] ( assoc db :some :thing ))) now, use reg would be used like this: ( rf/reg { :kind :event-db :id :event-id :fn ( fn [ db event ] ( assoc db :some :thing ))}) The map argument must contain the keys :kind , :id and :fn , with other valid keys being dependent on the kind of handler being registered. The value :kind can be one these 7 (mapping to 7 existing reg-* functions): - :event-db :event-fx :event-ctx - :sub :sub-raw - :fx - :cofx Optionally, for all kinds of handlers the the map can also have these additional keys: - :doc a doc string - :ns the namespace where the handler was registered - :line line number where the handler was registered - :file the name file where the handler was registered In a dev build, the reg macro will supply the final 3 (source code coordinates), if not explicitly supplied in the map. In a production build, the :doc string will be elided, so we do not appear in the final source code at all. The key :pkg is reserved for future use, and might eventually indicate the \"package\" to which this handler belongs. See EP 002. Other keys: XXX - :cept for interceptors (when registering events) - :ins for input signals (when registering subscriptions) - :ret for return spec (subscriptions and events) - :spec for event spec (when registering events) ??? Too much ?? XXX I'm not entirely happy about using short names like :cept . But, then again, there's the aesthetics of formatting the code and lining things up. XXX could have a :cofx key for event handlers to make them more explicit. Multiple Registrations \u00b6 The argument to reg can also be a vector of maps to allow for multiple handlers to be registered at once: ( rf/reg [{ :kind :event-db ... } { :kind :event-db ... } { :kind :event-fx ... } { :kind :sub ... ]) Or maybe move the registration keyword outside the map, to avoid repetition. ( rf/reg :event-db [{ ... } { ... } { ... } { ... ]) XXX maybe not needed. Provide the most minimal API? Then let towers of abstraction be built on top. Registrar \u00b6 Each entry stored in the registrar will become a map instead of just a handler. Map keys: - :kind - somehow redundant - :id - :doc - :line - :ns - :doc - :fn the handler XXX look into reg-sub Backwards Compatibility \u00b6 XXX Issues/Questions/Todos \u00b6 XXX implications for Cursive - it currently special-cases re-frame registration function -- give ColinF a heads up?? XXX Dear God, consider changes to documentation/tutorials XXX means giving up syntax sugar for reg-sub ? XXX any format for :doc for display in HTML? Or just texual.","title":"001 CaptureHandlerMetadata"},{"location":"EPs/001-CaptureHandlerMetadata/#ep-001-better-capture-of-handler-metadata","text":"Status: Drafting. May be incoherent and/or wrong. Don't read.","title":"EP 001 - Better Capture Of Handler Metadata"},{"location":"EPs/001-CaptureHandlerMetadata/#abstract","text":"This EP proposes changes to the way re-frame handlers are registered, to allow for the capture of richer handler metadata. These changes also lay the groundwork for tooling advances, and EPs to follow.","title":"Abstract"},{"location":"EPs/001-CaptureHandlerMetadata/#background","text":"re-frame's API currently includes 7 functions for registering handlers: - event: reg-event-db , reg-event-fx and reg-event-ctx - subscription: reg-sub and reg-sub-raw - effects: reg-fx - coeffects: reg-cofx Two others are on the drawing board: - reg-view - reg-interceptor So, there are potentially 9 kinds of handlers. Internally, re-frame manages registered handlers in a registrar , which is a two-level map, keyed at the first level by the kind of handler and, at the second level,\\by the (keyword) id of the handler. The leaf values are the handler functions themselves.","title":"Background"},{"location":"EPs/001-CaptureHandlerMetadata/#introduction","text":"This EP proposes that: 1. all current registration functions in the API be superseded by a new single macro reg 2. the leaf nodes of the registrar , which are currently the handler functions themselves, become instead a map of values related to the handler, including a doc string, the file/line where defined, specs, etc, and, of course, the handler itself.","title":"Introduction"},{"location":"EPs/001-CaptureHandlerMetadata/#motivations","text":"There's pressure from multiple directions to collect and retain more metadata about handlers: - tickets like #457 want docstrings for handlers - adding specs for events, so they can be checked at dev time - when re-frame becomes less of a framework and more of a library, handlers might need be \"grouped\" into \"packages\". So \"package\" information about handlers need to be supplied and retained. - Tooling support - we'd like re-frame-10x to actively help programmers when they are learning a new codebase. That's one of the four stated goals . Ideally, re-frame would be capable of providing tooling with \"a complete inventory\" of an app's handlers, along with useful metadata on each handles. When an event is processed, the audit trail of handlers involved should be rich with information.","title":"Motivations"},{"location":"EPs/001-CaptureHandlerMetadata/#macro","text":"As part of the retained handler metadata, we'd like to automatically capture source code coordinates, like namespace and line number. To make this happen, a macro will need to be introduced for registration, and that's a shift in approach because, until now, macros have been manfully resisted. Introducing docstrings into registrations also encourages a macro solution because docstrings should be removed from production builds.","title":"Macro"},{"location":"EPs/001-CaptureHandlerMetadata/#method","text":"A new macro reg will become the method of registering handlers. The existing 7 registration functions will ultimately be deprecated. reg will take one argument, a map, which captures all aspects of the handler.","title":"Method"},{"location":"EPs/001-CaptureHandlerMetadata/#examples","text":"Previously, reg-event-db was used like this: ( rf/reg-event-db :event-id ( fn [ db event ] ( assoc db :some :thing ))) now, use reg would be used like this: ( rf/reg { :kind :event-db :id :event-id :fn ( fn [ db event ] ( assoc db :some :thing ))}) The map argument must contain the keys :kind , :id and :fn , with other valid keys being dependent on the kind of handler being registered. The value :kind can be one these 7 (mapping to 7 existing reg-* functions): - :event-db :event-fx :event-ctx - :sub :sub-raw - :fx - :cofx Optionally, for all kinds of handlers the the map can also have these additional keys: - :doc a doc string - :ns the namespace where the handler was registered - :line line number where the handler was registered - :file the name file where the handler was registered In a dev build, the reg macro will supply the final 3 (source code coordinates), if not explicitly supplied in the map. In a production build, the :doc string will be elided, so we do not appear in the final source code at all. The key :pkg is reserved for future use, and might eventually indicate the \"package\" to which this handler belongs. See EP 002. Other keys: XXX - :cept for interceptors (when registering events) - :ins for input signals (when registering subscriptions) - :ret for return spec (subscriptions and events) - :spec for event spec (when registering events) ??? Too much ?? XXX I'm not entirely happy about using short names like :cept . But, then again, there's the aesthetics of formatting the code and lining things up. XXX could have a :cofx key for event handlers to make them more explicit.","title":"Examples"},{"location":"EPs/001-CaptureHandlerMetadata/#multiple-registrations","text":"The argument to reg can also be a vector of maps to allow for multiple handlers to be registered at once: ( rf/reg [{ :kind :event-db ... } { :kind :event-db ... } { :kind :event-fx ... } { :kind :sub ... ]) Or maybe move the registration keyword outside the map, to avoid repetition. ( rf/reg :event-db [{ ... } { ... } { ... } { ... ]) XXX maybe not needed. Provide the most minimal API? Then let towers of abstraction be built on top.","title":"Multiple Registrations"},{"location":"EPs/001-CaptureHandlerMetadata/#registrar","text":"Each entry stored in the registrar will become a map instead of just a handler. Map keys: - :kind - somehow redundant - :id - :doc - :line - :ns - :doc - :fn the handler XXX look into reg-sub","title":"Registrar"},{"location":"EPs/001-CaptureHandlerMetadata/#backwards-compatibility","text":"XXX","title":"Backwards Compatibility"},{"location":"EPs/001-CaptureHandlerMetadata/#issuesquestionstodos","text":"XXX implications for Cursive - it currently special-cases re-frame registration function -- give ColinF a heads up?? XXX Dear God, consider changes to documentation/tutorials XXX means giving up syntax sugar for reg-sub ? XXX any format for :doc for display in HTML? Or just texual.","title":"Issues/Questions/Todos"},{"location":"EPs/002-ReframeInstances/","text":"EP 002 - Multiple re-frame Instances \u00b6 Status: Drafting. May be incoherent and/or wrong. Probably don't read. Abstract \u00b6 This EP proposes changes to allow multiple re-frame apps to coexist on the same (HTML) page. Introduction \u00b6 Currently, there can only be one instance of re-frame on a page. This design limitation simplifies the programmer's development experience in 98.3% of usecases (yes, I just pulled that number out of my keyboard). But there are some problematic usecases: 1. when two or more instances of the same app need to coexist on the one page: - think of devcards where instances should coexist - when unittesting, it might be useful to create re-frame \"instances\" serially, use them, and then throw them away. 2. when two or more instances of different re-frame apps need to coexist on the one page. Different, as in, one is TodoMVC and the other is a MemeCreator. The challenge is to facilitate these more complicated usecases while not, in the process, losing the current simplicity which is enjoyed most of the time. Global State As A Frame \u00b6 Currently, re-frame has some global state in the form of various atoms scattered about internal namespaces. The best known is app-db . It would be completely straightforward to scoop up this state and put it into some sort of defrecord whole - let's call it Frame - and then allow the programmer to create instances of Frame when they want to create a new instance of a re-frame app. Imagine there's a new API function called create-frame , which creates a new instance of this defrecord Frame and that you can call it as often as you want to create as many re-frame apps as needed. So, that was the easy bit. The Two Problems \u00b6 Now the design work has to start in earnest and there's two problems to solve: 1. how to associate/register handlers with a Frame 2. within a view function, how to subscribe or dispatch from/to the right Frame We'll start with problem #1. On Mutating registrars \u00b6 A re-frame app is defined collectively by its handlers. As an app boots, calls to registration functions like reg-event-db and reg-sub collectively \"build up\" an app, infusing it with behaviour and capability. This \"building up\" process currently involves progressive mutation of a global registrar (map) held internally within re-frame . Each registration adds a new entry to this registrar . If you are troubled by the thought of side effects on globals, there's an FAQ entry you may find interesting . Problem 1: Frames And Registrars \u00b6 The first design challenge to explore is: what's the new relationship between Frames and registrars . re-frame currently holds a global registrar of handlers, but in our new world, where there are different Frame instances on a page, should each of these Frames have its own registrar of handlers? And, if so, how and when should handlers be added to their registrars ? And, to support the developer experience, how should this work with figwheel reloads of namespace containing registrations? How should the registrar within a given Frame be updated? Let's explore via usecases ... In the usecase where there are multiple Frames on a page and they are all instances of the same app - for example, multiple TodoMVC apps - then all the Frames will have an identical set of handlers. So there need be only one central registrar (continue to use re-frame's global one?) and all Frames can look up handlers in this global registrar , and not hold one themselves. So continuing with a global registrar would work. But there are harder usecases to contend with. Ones where there are many Frames on a page, but each is for a different app . Imagine that one app on the page is TodoMVC and the other is a MemeCreator tool. Each Frame needs a different set of handlers. In which case, can we still put all handlers into a central registrar ? Maybe. But it would \"safer\" if each app's Frame only had access to the subset of handlers specific to that app. More ideas. Perhaps when registering a handler, the \"package\" to which it belongs can be nominated. Collections of related handlers would all belong to the same package. So all of the handlers for re-frame-undo would be registered as part of the package :re-frame-undo . And then, create-frame could, optionally, take a set of packages as an argument indicating which of them should be included/imported into the Frame being created. Its almost as if we are importing packages of handlers into a Frame . Keep in mind that there are libraries of handlers. re-frame-undo is a library which has event handlers, subscription handlers, etc. So one Frame on a page might need to include the package of re-frame-undo handlers, but another Frame on the same page might not. Alternatively, we could drop the notion of :package and simply work from the namespace of the registration id . XXX Perhaps if the handler ids were organised into app-specific collections, a central registrar could work. The collection mechanism could be as simple as insisting on ids with namespaces. Or if ==t could be that registration puts handlers into packages . And then, when we created a Frame , we'd need to indicate which of these \"packages\" (collections of handlers) should be \"imported\" into that Frame ? But keep in mind the need for updates to handlers being reloaded by figwheel (or the like). A Frame will need to \"get\" these updated handlers. And also k Problem 1 - Solutions \u00b6 Registration calls (to reg-event-db , etc) could be adjusted to take an additional Frame argument. So, Handlers get registered \"into\" a Frame . Solution sketch #2 : all handlers are registered as they are now using reg-event-db etc, and are stored (as now) in a central registrar (as now). But each handler belongs to a \"package\" (which defaults to :default ). When a frame is created, you can, optionally, supply the set of packages . When the Frame is created all handlers in the nominated packages are injected into the Frame . If not set is provided, then all handlers are injected. At this point, I favour sketch #2 from a backwards compatibility point of view. It is the least disruptive. Problem 2: Views, dispatch and subscription \u00b6 In an HTML page containing multiple devcard instances, all for exactly the same app, there will be one Frame for each devcard . In this scenario, how can a view know to which Frame it should subscribe ? And to which Frame it should dispatch ? Problem 2: Minimal Design Solution \u00b6 The \"minimal design\" approach is to say that Frames are passed as an argument into each view function, and then further passed down into child views, and so on, and so on. Then, when using dispatch or subscribe a view will use the arg given to it called, say, frame like this: (dispatch frame [:event-id arg]) . This approach is certainly simple. But it does get laborious and tedious pretty quickly. Every view needs to accept a frame and then pass it down to all children. Even intermediate Problem 2: Better Design Solution \u00b6 Solution sketch #2 : Hack Reagent so that a given node in the hierarchy can \"register\" a Frame, and then provide a a way so that any given view can \"query upwards\" through its the parent/owner hierarchy of views looking for the frame to which it should subscribe and dispatch. Solution sketch #3 : The Algebraic Effects approach is to piggyback on React's context facility. context only works for simple values, so this path would passing down the id of the frame, and then looking it up. Problem \u00b6 if we subscribe in a view, and that subscription needs to causes other subscriptions to be created, how to get at the associated frame at the point when we want to create the further subscriptions?","title":"002 ReframeInstances"},{"location":"EPs/002-ReframeInstances/#ep-002-multiple-re-frame-instances","text":"Status: Drafting. May be incoherent and/or wrong. Probably don't read.","title":"EP 002 - Multiple re-frame Instances"},{"location":"EPs/002-ReframeInstances/#abstract","text":"This EP proposes changes to allow multiple re-frame apps to coexist on the same (HTML) page.","title":"Abstract"},{"location":"EPs/002-ReframeInstances/#introduction","text":"Currently, there can only be one instance of re-frame on a page. This design limitation simplifies the programmer's development experience in 98.3% of usecases (yes, I just pulled that number out of my keyboard). But there are some problematic usecases: 1. when two or more instances of the same app need to coexist on the one page: - think of devcards where instances should coexist - when unittesting, it might be useful to create re-frame \"instances\" serially, use them, and then throw them away. 2. when two or more instances of different re-frame apps need to coexist on the one page. Different, as in, one is TodoMVC and the other is a MemeCreator. The challenge is to facilitate these more complicated usecases while not, in the process, losing the current simplicity which is enjoyed most of the time.","title":"Introduction"},{"location":"EPs/002-ReframeInstances/#global-state-as-a-frame","text":"Currently, re-frame has some global state in the form of various atoms scattered about internal namespaces. The best known is app-db . It would be completely straightforward to scoop up this state and put it into some sort of defrecord whole - let's call it Frame - and then allow the programmer to create instances of Frame when they want to create a new instance of a re-frame app. Imagine there's a new API function called create-frame , which creates a new instance of this defrecord Frame and that you can call it as often as you want to create as many re-frame apps as needed. So, that was the easy bit.","title":"Global State As A Frame"},{"location":"EPs/002-ReframeInstances/#the-two-problems","text":"Now the design work has to start in earnest and there's two problems to solve: 1. how to associate/register handlers with a Frame 2. within a view function, how to subscribe or dispatch from/to the right Frame We'll start with problem #1.","title":"The Two Problems"},{"location":"EPs/002-ReframeInstances/#on-mutating-registrars","text":"A re-frame app is defined collectively by its handlers. As an app boots, calls to registration functions like reg-event-db and reg-sub collectively \"build up\" an app, infusing it with behaviour and capability. This \"building up\" process currently involves progressive mutation of a global registrar (map) held internally within re-frame . Each registration adds a new entry to this registrar . If you are troubled by the thought of side effects on globals, there's an FAQ entry you may find interesting .","title":"On Mutating registrars"},{"location":"EPs/002-ReframeInstances/#problem-1-frames-and-registrars","text":"The first design challenge to explore is: what's the new relationship between Frames and registrars . re-frame currently holds a global registrar of handlers, but in our new world, where there are different Frame instances on a page, should each of these Frames have its own registrar of handlers? And, if so, how and when should handlers be added to their registrars ? And, to support the developer experience, how should this work with figwheel reloads of namespace containing registrations? How should the registrar within a given Frame be updated? Let's explore via usecases ... In the usecase where there are multiple Frames on a page and they are all instances of the same app - for example, multiple TodoMVC apps - then all the Frames will have an identical set of handlers. So there need be only one central registrar (continue to use re-frame's global one?) and all Frames can look up handlers in this global registrar , and not hold one themselves. So continuing with a global registrar would work. But there are harder usecases to contend with. Ones where there are many Frames on a page, but each is for a different app . Imagine that one app on the page is TodoMVC and the other is a MemeCreator tool. Each Frame needs a different set of handlers. In which case, can we still put all handlers into a central registrar ? Maybe. But it would \"safer\" if each app's Frame only had access to the subset of handlers specific to that app. More ideas. Perhaps when registering a handler, the \"package\" to which it belongs can be nominated. Collections of related handlers would all belong to the same package. So all of the handlers for re-frame-undo would be registered as part of the package :re-frame-undo . And then, create-frame could, optionally, take a set of packages as an argument indicating which of them should be included/imported into the Frame being created. Its almost as if we are importing packages of handlers into a Frame . Keep in mind that there are libraries of handlers. re-frame-undo is a library which has event handlers, subscription handlers, etc. So one Frame on a page might need to include the package of re-frame-undo handlers, but another Frame on the same page might not. Alternatively, we could drop the notion of :package and simply work from the namespace of the registration id . XXX Perhaps if the handler ids were organised into app-specific collections, a central registrar could work. The collection mechanism could be as simple as insisting on ids with namespaces. Or if ==t could be that registration puts handlers into packages . And then, when we created a Frame , we'd need to indicate which of these \"packages\" (collections of handlers) should be \"imported\" into that Frame ? But keep in mind the need for updates to handlers being reloaded by figwheel (or the like). A Frame will need to \"get\" these updated handlers. And also k","title":"Problem 1:  Frames And Registrars"},{"location":"EPs/002-ReframeInstances/#problem-1-solutions","text":"Registration calls (to reg-event-db , etc) could be adjusted to take an additional Frame argument. So, Handlers get registered \"into\" a Frame . Solution sketch #2 : all handlers are registered as they are now using reg-event-db etc, and are stored (as now) in a central registrar (as now). But each handler belongs to a \"package\" (which defaults to :default ). When a frame is created, you can, optionally, supply the set of packages . When the Frame is created all handlers in the nominated packages are injected into the Frame . If not set is provided, then all handlers are injected. At this point, I favour sketch #2 from a backwards compatibility point of view. It is the least disruptive.","title":"Problem 1 - Solutions"},{"location":"EPs/002-ReframeInstances/#problem-2-views-dispatch-and-subscription","text":"In an HTML page containing multiple devcard instances, all for exactly the same app, there will be one Frame for each devcard . In this scenario, how can a view know to which Frame it should subscribe ? And to which Frame it should dispatch ?","title":"Problem 2: Views, dispatch and subscription"},{"location":"EPs/002-ReframeInstances/#problem-2-minimal-design-solution","text":"The \"minimal design\" approach is to say that Frames are passed as an argument into each view function, and then further passed down into child views, and so on, and so on. Then, when using dispatch or subscribe a view will use the arg given to it called, say, frame like this: (dispatch frame [:event-id arg]) . This approach is certainly simple. But it does get laborious and tedious pretty quickly. Every view needs to accept a frame and then pass it down to all children. Even intermediate","title":"Problem 2: Minimal Design Solution"},{"location":"EPs/002-ReframeInstances/#problem-2-better-design-solution","text":"Solution sketch #2 : Hack Reagent so that a given node in the hierarchy can \"register\" a Frame, and then provide a a way so that any given view can \"query upwards\" through its the parent/owner hierarchy of views looking for the frame to which it should subscribe and dispatch. Solution sketch #3 : The Algebraic Effects approach is to piggyback on React's context facility. context only works for simple values, so this path would passing down the id of the frame, and then looking it up.","title":"Problem 2: Better Design Solution"},{"location":"EPs/002-ReframeInstances/#problem","text":"if we subscribe in a view, and that subscription needs to causes other subscriptions to be created, how to get at the associated frame at the point when we want to create the further subscriptions?","title":"Problem"},{"location":"EPs/003-ReusableComponents/","text":"EP 003 - Enabling Creation Of Reusable Components \u00b6 Status: Placeholder. Don't bother reading yet. Abstract \u00b6 This EP proposes changes to facilitate easier use of React's Context feature. XXX to make it easier to write more complex Reusable components. Background \u00b6 React components form a tree, with values being passed down through the hierarchy in the form of props . All very functional. Except there are some problems: - it can be a PITA to pass every little bit of data through many, many layers. Manual and time-consuming. - often we don't want to burden intermediate layers with knowledge about what leaf nodes needed. That kind of \"unnecessary knowing\" leads to various kinds of fragility. - if we are using someone else's layout components, we may have not have control over what they pass to children. Algebraic Effects are intended to help solve these kinds of problems in a functional way, but that's not our world. The solution available in React is called Context . It is a mechanism for allowing data to be \"shared\" globally within a given tree of React components (without it needing for it to be passed/threaded through all layers of that tree). React's context docs are here . Components \u00b6 re-com is a library which supplies reusable Reagent widgets. And widgets , like a datepicker, are the simplest kind of components. re-com components are reusability because they take an input stream of data and they achieves reusablity by passing in values and supplying callbacks. This works at the level of simple widgets. But re-frame components need to subscribe and dispatch. XXX talk about dispatch back rather than callback XXX need to identify the part of app-db on which event handlers and subscriptions should operate.","title":"003 ReusableComponents"},{"location":"EPs/003-ReusableComponents/#ep-003-enabling-creation-of-reusable-components","text":"Status: Placeholder. Don't bother reading yet.","title":"EP 003 - Enabling Creation Of Reusable Components"},{"location":"EPs/003-ReusableComponents/#abstract","text":"This EP proposes changes to facilitate easier use of React's Context feature. XXX to make it easier to write more complex Reusable components.","title":"Abstract"},{"location":"EPs/003-ReusableComponents/#background","text":"React components form a tree, with values being passed down through the hierarchy in the form of props . All very functional. Except there are some problems: - it can be a PITA to pass every little bit of data through many, many layers. Manual and time-consuming. - often we don't want to burden intermediate layers with knowledge about what leaf nodes needed. That kind of \"unnecessary knowing\" leads to various kinds of fragility. - if we are using someone else's layout components, we may have not have control over what they pass to children. Algebraic Effects are intended to help solve these kinds of problems in a functional way, but that's not our world. The solution available in React is called Context . It is a mechanism for allowing data to be \"shared\" globally within a given tree of React components (without it needing for it to be passed/threaded through all layers of that tree). React's context docs are here .","title":"Background"},{"location":"EPs/003-ReusableComponents/#components","text":"re-com is a library which supplies reusable Reagent widgets. And widgets , like a datepicker, are the simplest kind of components. re-com components are reusability because they take an input stream of data and they achieves reusablity by passing in values and supplying callbacks. This works at the level of simple widgets. But re-frame components need to subscribe and dispatch. XXX talk about dispatch back rather than callback XXX need to identify the part of app-db on which event handlers and subscriptions should operate.","title":"Components"},{"location":"EPs/004-ViewRegistration/","text":"EP 003 - View Registration \u00b6 Status: Placeholder. Only scribbles. Don't read yet. Abstract \u00b6 Broadbrush: - views will be registered via a new re-frame.core/def-view function - like other re-frame registration functions, def-view associates a keyword with a (reagent) render function - the registered view keyword (eg: :my-view ) can be used in hiccup to identify the renderer. eg: [:my-view \"Hello world\"] - def-view allows various values to be injected as args into the view render - see https://github.com/reagent-project/reagent/issues/362 Why: - removing (render) functions from hiccup will make hiccup even more data oriented. Symptoms include helping with various state machine ideas. - injection of dispatch and subscribe will help view functions to be slightly more pure. dispatch still kinda a problem. - ijection of context which will help with \"multiple re-frame apps on the one page\" problem What might need to be injected (as args) into a view: subscribe and dispatch a frame supplied via context (subscribe and dispatch obtained from frame) other context: data from higher in the DOM tree animation? CSS ? XXX searches up the DOM heirarchy looking for a frame context then extracts dispatch and subscribe. Sounds inefficient. Code Doodle #1 \u00b6 Associate the keyword :my-view-id with a renderer using def-view : ( def-view :my-view-id ;; indicate what `context` is required [ :dispatch :subscribe :context XXX ] ;; the renderer ;; last argument `context` is a map of: ;; - `:subs` - a vector of subscription values? ;; - :dispatch and :subscribe ;; - :context - a vector of context values ;; ( fn [ a-str context ] ( let [ XXXX ] ))) Use of :my-view-id : [ :my-view-id \"Hello\" ] Code Doodle #2 \u00b6 Associate the keyword :my-view-id with a renderer using def-view : ( def-view :my-view-id ;; injection function ;; indicate what subscriptions we wish to obtain ;; obtain a dispatch for use ;; get the context id if you want to ;; :subscriptions ( fn [ _ id ] { :subs [[ :item ]] :context [ \"name1\" , \"name2\" )}) ;; the renderer ;; last argument `ins` is a map of: ;; - `:subs` - a vector of subscription values? ;; - :dispatch and :subscribe ;; - :context - a vector of context values ;; ( fn [ a-str ins ] ( let [ XXXX ] ))) Use of :my-view-id : [ :my-view-id \"Hello\" ] Code Doodle #3 \u00b6 [:something arg1 arg2] ( def-view :something ( fn [ arg1 arg2 ] ;; obtain dispatch and subscription ;; obtain a subscription ot two ;; add a key on the component ( fn [ arg1 arg2 ] )) Misc Notes \u00b6 reagent hiccup will be changed/monkey-patched so that views can be identified by keyword Views are the leaves of the signal graph. They need to subscribe and dispatch. how to obtain other pieces of context (beyond the current frame) XXX There's a nasty problem with frames and subscriptions. How does the signal function know what frame to create new subscriptions against??? Usage \u00b6","title":"004 ViewRegistration"},{"location":"EPs/004-ViewRegistration/#ep-003-view-registration","text":"Status: Placeholder. Only scribbles. Don't read yet.","title":"EP 003 - View Registration"},{"location":"EPs/004-ViewRegistration/#abstract","text":"Broadbrush: - views will be registered via a new re-frame.core/def-view function - like other re-frame registration functions, def-view associates a keyword with a (reagent) render function - the registered view keyword (eg: :my-view ) can be used in hiccup to identify the renderer. eg: [:my-view \"Hello world\"] - def-view allows various values to be injected as args into the view render - see https://github.com/reagent-project/reagent/issues/362 Why: - removing (render) functions from hiccup will make hiccup even more data oriented. Symptoms include helping with various state machine ideas. - injection of dispatch and subscribe will help view functions to be slightly more pure. dispatch still kinda a problem. - ijection of context which will help with \"multiple re-frame apps on the one page\" problem What might need to be injected (as args) into a view: subscribe and dispatch a frame supplied via context (subscribe and dispatch obtained from frame) other context: data from higher in the DOM tree animation? CSS ? XXX searches up the DOM heirarchy looking for a frame context then extracts dispatch and subscribe. Sounds inefficient.","title":"Abstract"},{"location":"EPs/004-ViewRegistration/#code-doodle-1","text":"Associate the keyword :my-view-id with a renderer using def-view : ( def-view :my-view-id ;; indicate what `context` is required [ :dispatch :subscribe :context XXX ] ;; the renderer ;; last argument `context` is a map of: ;; - `:subs` - a vector of subscription values? ;; - :dispatch and :subscribe ;; - :context - a vector of context values ;; ( fn [ a-str context ] ( let [ XXXX ] ))) Use of :my-view-id : [ :my-view-id \"Hello\" ]","title":"Code Doodle #1"},{"location":"EPs/004-ViewRegistration/#code-doodle-2","text":"Associate the keyword :my-view-id with a renderer using def-view : ( def-view :my-view-id ;; injection function ;; indicate what subscriptions we wish to obtain ;; obtain a dispatch for use ;; get the context id if you want to ;; :subscriptions ( fn [ _ id ] { :subs [[ :item ]] :context [ \"name1\" , \"name2\" )}) ;; the renderer ;; last argument `ins` is a map of: ;; - `:subs` - a vector of subscription values? ;; - :dispatch and :subscribe ;; - :context - a vector of context values ;; ( fn [ a-str ins ] ( let [ XXXX ] ))) Use of :my-view-id : [ :my-view-id \"Hello\" ]","title":"Code Doodle #2"},{"location":"EPs/004-ViewRegistration/#code-doodle-3","text":"[:something arg1 arg2] ( def-view :something ( fn [ arg1 arg2 ] ;; obtain dispatch and subscription ;; obtain a subscription ot two ;; add a key on the component ( fn [ arg1 arg2 ] ))","title":"Code Doodle #3"},{"location":"EPs/004-ViewRegistration/#misc-notes","text":"reagent hiccup will be changed/monkey-patched so that views can be identified by keyword Views are the leaves of the signal graph. They need to subscribe and dispatch. how to obtain other pieces of context (beyond the current frame) XXX There's a nasty problem with frames and subscriptions. How does the signal function know what frame to create new subscriptions against???","title":"Misc Notes"},{"location":"EPs/004-ViewRegistration/#usage","text":"","title":"Usage"},{"location":"EPs/005-StateMachines/","text":"EP 003 - Finite State Machines \u00b6 Status: Placeholder. Don't bother reading yet. Abstract \u00b6 Colloquial: I'd like re-frame to have a better story for programming in FSMs. I want to represent \"Higher Order Behaviour\" which currently gets \"smeared\" across multiple event handlers. Introduction \u00b6 Many high level aspects of SPAs are best modelled explicitly as an FSM. First, an app must gather X from the user, but if they press cancel, then return to showing Y, but otherwise move on to do activity Z. It is quite natural to model such overall decisions and the UIs involved as an FSM. Many low level aspects of SPAs are best modelled explicitly as FSM too. The simple act of GETing from a server involves various states, including waiting, and failed, and timed-out, and retrying and succeeded. BUT you need the power of a fully expressive state machine. You need orthogonal state, guards, hierarchical state, history, etc. Back in 1987, Harel identified the set of features required - anything less and your tool will not be expressive enough to do the job. Harel also insisted that statecharts was a visual formalism, so tooling is also important. Why? \u00b6 Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy. -- Alan Perlis State machines are appealing because: - they constrain you (vs the full Turing tar-pit). Just because you can wield immense power doesn't mean you should. - they force you to think through and structure a problem. This process helps to flush out the corner cases. - they make explicit certain important assumptions which are otherwise hidden in a thicket of conditionals. Also, Why Developers Never Use State Machines https://www.skorks.com/2011/09/why-developers-never-use-state-machines/ \"The strength of JavaScript is that you can do anything. The weakness is that you will.\" - Reg Braithwaite How? \u00b6 Technical elements: - a way to register: - a state machine specification against a machine-id - the specification will be a data structure, listing states, transitions, etc - a way to create an instance of a registered state machine - args: machine-id, id for this particular instance - data for machine instance will be stored in app-db (at :machines or a configurable place?) - a way to trigger - the id of the state machine targeted - the trigger - the trigger args - trigger causes: - state transition - an action fn to be called which produces :effects - UI changes. See EP on reg-view which will make it much easier to describe UI in machine data structure - a way to destroy an instance Misc Notes \u00b6 Events model user intent, not implementation details. So, we DO NOT want events that talk about FSM or triggers etc because that's an implementation detail. Instead, we want But event handlers should know about XXX Triggers \u00b6 Types of triggers: 1. External (from the user, websocket) 2. Data - something about app-db has changed Implementation \u00b6 What if we didn't even use FSM and used Behaviour Trees instead? Behaviour trees are more composable. A better match for a data-oriented design. Links And Notes: statecharts THE PRECISE SEMANTICS OF UML STATE MACHINES David Khourshid - Infinitely Better UIs with Finite Automata also written Statecharts: Updating UI state https://statecharts.github.io/ Harel Paper setState Machine Speaker Deck by Michele Bertoli Previously CLJS : - https://github.com/jebberjeb/reframe-fsm - https://github.com/protocol55/re-state - http://blog.cognitect.com/blog/2017/8/14/restate-your-ui-creating-a-user-interface-with-re-frame-and-state-machines Other Attempts: - Fractal UI components using snabbdom, Harel statecharts, and event emitters BT 101 \u2013 Behavior Trees grammar basics Understanding Behavior Trees behavior3js github repo Understanding the Second Generation of Behavior Trees (video) 10 Reasons the Age of Finite State Machines is Over Parameterizing Behavior Trees Behavior Trees in Robotics and AI TLA+ - ** Three Approximations - includes SAM - State Machines and Computing - SAM \u2013 the State-Action-Model pattern - TLA Intro - Computation and State Machines - Leslie Lamport - SAM Pattern in JS -","title":"005 StateMachines"},{"location":"EPs/005-StateMachines/#ep-003-finite-state-machines","text":"Status: Placeholder. Don't bother reading yet.","title":"EP 003 - Finite State Machines"},{"location":"EPs/005-StateMachines/#abstract","text":"Colloquial: I'd like re-frame to have a better story for programming in FSMs. I want to represent \"Higher Order Behaviour\" which currently gets \"smeared\" across multiple event handlers.","title":"Abstract"},{"location":"EPs/005-StateMachines/#introduction","text":"Many high level aspects of SPAs are best modelled explicitly as an FSM. First, an app must gather X from the user, but if they press cancel, then return to showing Y, but otherwise move on to do activity Z. It is quite natural to model such overall decisions and the UIs involved as an FSM. Many low level aspects of SPAs are best modelled explicitly as FSM too. The simple act of GETing from a server involves various states, including waiting, and failed, and timed-out, and retrying and succeeded. BUT you need the power of a fully expressive state machine. You need orthogonal state, guards, hierarchical state, history, etc. Back in 1987, Harel identified the set of features required - anything less and your tool will not be expressive enough to do the job. Harel also insisted that statecharts was a visual formalism, so tooling is also important.","title":"Introduction"},{"location":"EPs/005-StateMachines/#why","text":"Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy. -- Alan Perlis State machines are appealing because: - they constrain you (vs the full Turing tar-pit). Just because you can wield immense power doesn't mean you should. - they force you to think through and structure a problem. This process helps to flush out the corner cases. - they make explicit certain important assumptions which are otherwise hidden in a thicket of conditionals. Also, Why Developers Never Use State Machines https://www.skorks.com/2011/09/why-developers-never-use-state-machines/ \"The strength of JavaScript is that you can do anything. The weakness is that you will.\" - Reg Braithwaite","title":"Why?"},{"location":"EPs/005-StateMachines/#how","text":"Technical elements: - a way to register: - a state machine specification against a machine-id - the specification will be a data structure, listing states, transitions, etc - a way to create an instance of a registered state machine - args: machine-id, id for this particular instance - data for machine instance will be stored in app-db (at :machines or a configurable place?) - a way to trigger - the id of the state machine targeted - the trigger - the trigger args - trigger causes: - state transition - an action fn to be called which produces :effects - UI changes. See EP on reg-view which will make it much easier to describe UI in machine data structure - a way to destroy an instance","title":"How?"},{"location":"EPs/005-StateMachines/#misc-notes","text":"Events model user intent, not implementation details. So, we DO NOT want events that talk about FSM or triggers etc because that's an implementation detail. Instead, we want But event handlers should know about XXX","title":"Misc Notes"},{"location":"EPs/005-StateMachines/#triggers","text":"Types of triggers: 1. External (from the user, websocket) 2. Data - something about app-db has changed","title":"Triggers"},{"location":"EPs/005-StateMachines/#implementation","text":"What if we didn't even use FSM and used Behaviour Trees instead? Behaviour trees are more composable. A better match for a data-oriented design. Links And Notes: statecharts THE PRECISE SEMANTICS OF UML STATE MACHINES David Khourshid - Infinitely Better UIs with Finite Automata also written Statecharts: Updating UI state https://statecharts.github.io/ Harel Paper setState Machine Speaker Deck by Michele Bertoli Previously CLJS : - https://github.com/jebberjeb/reframe-fsm - https://github.com/protocol55/re-state - http://blog.cognitect.com/blog/2017/8/14/restate-your-ui-creating-a-user-interface-with-re-frame-and-state-machines Other Attempts: - Fractal UI components using snabbdom, Harel statecharts, and event emitters BT 101 \u2013 Behavior Trees grammar basics Understanding Behavior Trees behavior3js github repo Understanding the Second Generation of Behavior Trees (video) 10 Reasons the Age of Finite State Machines is Over Parameterizing Behavior Trees Behavior Trees in Robotics and AI TLA+ - ** Three Approximations - includes SAM - State Machines and Computing - SAM \u2013 the State-Action-Model pattern - TLA Intro - Computation and State Machines - Leslie Lamport - SAM Pattern in JS -","title":"Implementation"},{"location":"FAQs/BestPractice/","text":"\u00b6 Question \u00b6 What are the current best practices? Answer \u00b6 To grasp best practices: 1. Read through the re-frame documentation. 2. Review example projects, like this RealWorld example . The Resources doc provides further examples. Keep in mind, best practices evolve over time. Here are some of the more recent ideas. Use Namespaced Keywords \u00b6 In the interests of minimalism, the docs don't use namespaced keywords for ids (event ids, subscription ids, etc), but in prectice you should. You can use either synthetic or real namespaces in your ids, but some experienced re-framers claim you should only use real namespaces. I remain unconvinced. Shrug. Tip: tooling like clojure-lsp can help you to navigate to where an event id or subsription id is registered. Structuring app-db \u00b6 While using app-db as a simple map works well in many situations, if you want more structure, consider using a library like doxa or relic . Use the :fx effect \u00b6 While event handlers can return a map of arbitrary effects, it is now recommended that they only return a map containing two standard keys :db and :fx . Learn more here and here . Compose Event Handlers \u00b6 Event handlers can be composed of other functions through the use of the :db / :fx effect pattern, which is described here Avoid Placeful Events \u00b6 Originally, it was recommended that events be a vector like this [:some-event-id arg1 arg2] . This works reasonably for simple cases, but it does introduce fragility for more complex use cases due to the lnherent \"placefulness\" of vectors. A better practice is to encapsulate the \"args\" into a single map: [:some-event-id {:x arg1 :another arg2}] And then to optionally use the unwrap middleware on the asspciated event handlers. See here","title":"What Is Best Practice?"},{"location":"FAQs/BestPractice/#_1","text":"","title":""},{"location":"FAQs/BestPractice/#question","text":"What are the current best practices?","title":"Question"},{"location":"FAQs/BestPractice/#answer","text":"To grasp best practices: 1. Read through the re-frame documentation. 2. Review example projects, like this RealWorld example . The Resources doc provides further examples. Keep in mind, best practices evolve over time. Here are some of the more recent ideas.","title":"Answer"},{"location":"FAQs/BestPractice/#use-namespaced-keywords","text":"In the interests of minimalism, the docs don't use namespaced keywords for ids (event ids, subscription ids, etc), but in prectice you should. You can use either synthetic or real namespaces in your ids, but some experienced re-framers claim you should only use real namespaces. I remain unconvinced. Shrug. Tip: tooling like clojure-lsp can help you to navigate to where an event id or subsription id is registered.","title":"Use Namespaced Keywords"},{"location":"FAQs/BestPractice/#structuring-app-db","text":"While using app-db as a simple map works well in many situations, if you want more structure, consider using a library like doxa or relic .","title":"Structuring app-db"},{"location":"FAQs/BestPractice/#use-the-fx-effect","text":"While event handlers can return a map of arbitrary effects, it is now recommended that they only return a map containing two standard keys :db and :fx . Learn more here and here .","title":"Use the :fx effect"},{"location":"FAQs/BestPractice/#compose-event-handlers","text":"Event handlers can be composed of other functions through the use of the :db / :fx effect pattern, which is described here","title":"Compose Event Handlers"},{"location":"FAQs/BestPractice/#avoid-placeful-events","text":"Originally, it was recommended that events be a vector like this [:some-event-id arg1 arg2] . This works reasonably for simple cases, but it does introduce fragility for more complex use cases due to the lnherent \"placefulness\" of vectors. A better practice is to encapsulate the \"args\" into a single map: [:some-event-id {:x arg1 :another arg2}] And then to optionally use the unwrap middleware on the asspciated event handlers. See here","title":"Avoid Placeful Events"},{"location":"FAQs/CatchingEventExceptions/","text":"\u00b6 Question \u00b6 How can I detect exceptions in Event Handlers? Answer \u00b6 A suggested solution can be found in this issue .","title":"How can I detect exceptions in Event Handlers?"},{"location":"FAQs/CatchingEventExceptions/#_1","text":"","title":""},{"location":"FAQs/CatchingEventExceptions/#question","text":"How can I detect exceptions in Event Handlers?","title":"Question"},{"location":"FAQs/CatchingEventExceptions/#answer","text":"A suggested solution can be found in this issue .","title":"Answer"},{"location":"FAQs/DB_Normalisation/","text":"\u00b6 Question \u00b6 app-db contains a map . How do I store normalised data in a map , bettering mirroring the structure in my server-side database? Answer \u00b6 These libraries might be interesting to you: compound SubGraph pull reflet - use normalised and non-normalised data in the same app-db See also this comment . If you want to go whole hog and ditch app-db and embrace DataScript, then you might find re-posh interesting.","title":"How do I store normalised data in app-db?"},{"location":"FAQs/DB_Normalisation/#_1","text":"","title":""},{"location":"FAQs/DB_Normalisation/#question","text":"app-db contains a map . How do I store normalised data in a map , bettering mirroring the structure in my server-side database?","title":"Question"},{"location":"FAQs/DB_Normalisation/#answer","text":"These libraries might be interesting to you: compound SubGraph pull reflet - use normalised and non-normalised data in the same app-db See also this comment . If you want to go whole hog and ditch app-db and embrace DataScript, then you might find re-posh interesting.","title":"Answer"},{"location":"FAQs/DoINeedReFrame/","text":"\u00b6 Question \u00b6 Reagent looks terrific. So, why do I need re-frame? What benefit is there in the extra layers and conceptual overhead it brings? Answer \u00b6 Yes, we agree, Reagent is terrific. We use it enthusiastically ourselves. And, yes, we'd agree that if your application is small and simple, then standalone Reagent is a reasonable choice. But it does only supply the V part of the MVC triad. As your application gets bigger and more complicated, you will need to find solutions to questions in the M and C realms. Questions like \"where do I put control logic?\". And, \"how do I store and update state?\". And, \"how should new websocket packets be communicated with the broader app\"? Or GET failures? And, \"how do I put up a spinner when waiting for CPU intensive computations to run, while allowing the user to press Cancel?\" How do I ensure efficient view updates? How do I write my control logic in a way that's testable? These questions accumulate. Reagent, by itself, provides little guidance and, so, you'll need to design your own solutions. Your choices will also accumulate and, over time, they'll become baked into your codebase. Now, any decision which is hard to revisit later is an architectural decision - \"difficult to change later\" is pretty much the definition of \"architecture\". So, as you proceed, baking your decisions into your codebase, you will be incrementally growing an architecture. So, then, the question is this: is your architecture better than re-frame's? Because that's what re-frame gives you ... an architecture ... solutions to the various challenges you'll face when developing your app, and mechanism for implementing those solutions. Now, in response, some will enthusiastically say \"yes, I want to grow my own architecture. I like mine!\". And fair enough - it can be an interesting ride! Problems arise ONLY when this process is not conscious and purposeful. It is a credit to Reagent that you can accelerate quickly and get a bunch of enjoyable early wins. But, equally, that acceleration can have you off the road in a ditch because of the twists and turns on the way to a larger application. I've had many people (20?) privately say to me that's what happened to them. And that's pretty much the reason for this FAQ - this happens a bit too often and there's been a bit too much pain. So, my advice is ... if your application is a little more complicated, be sure to make a conscious choice around architecture. Don't think \"Reagent is all I need\", because it isn't. One way or another you'll be using \"Reagent + a broader architecture\". Example Choices Made By re-frame \u00b6 Events are cardinal. Nothing happens without an event. Events are data (so they are loggable, and can be queued, etc). Dispatched events are handled async - they are put in a queue and handled very soon, but not now (for a variety of subtle reasons). For efficiency, subscriptions (reactions) should be layered and de-duplicated. Views are never imperative or side effecting (best effort). Unidirectional data flow only, ever. Interceptors over middleware. Provide cross cutting concerns like logging and debugging. Event handlers capture control and contain key logic. Ensure purity via coeffects and effects. All state is stored in one place. State is committed-to transactionally, never incrementally or piecemeal. Hmm. I feel like I'm missing a few, but that's certainly an indicative list. re-frame is only about 750 lines of code. So its value is much more in the honed choices it embodies (and documents), than the code it provides. What Reagent Does Provide \u00b6 Above I said: Reagent, by itself, provides little guidance ... which is true but, it does provide useful building blocks. If you do want to create your own architecture, then be sure to check out Reagent's track , reaction and rswap . There's also other Reagent-based architectures like keechma and carry which make different choices - ones which may better suit your needs.","title":"Reagent looks terrific. Why do I need re-frame?"},{"location":"FAQs/DoINeedReFrame/#_1","text":"","title":""},{"location":"FAQs/DoINeedReFrame/#question","text":"Reagent looks terrific. So, why do I need re-frame? What benefit is there in the extra layers and conceptual overhead it brings?","title":"Question"},{"location":"FAQs/DoINeedReFrame/#answer","text":"Yes, we agree, Reagent is terrific. We use it enthusiastically ourselves. And, yes, we'd agree that if your application is small and simple, then standalone Reagent is a reasonable choice. But it does only supply the V part of the MVC triad. As your application gets bigger and more complicated, you will need to find solutions to questions in the M and C realms. Questions like \"where do I put control logic?\". And, \"how do I store and update state?\". And, \"how should new websocket packets be communicated with the broader app\"? Or GET failures? And, \"how do I put up a spinner when waiting for CPU intensive computations to run, while allowing the user to press Cancel?\" How do I ensure efficient view updates? How do I write my control logic in a way that's testable? These questions accumulate. Reagent, by itself, provides little guidance and, so, you'll need to design your own solutions. Your choices will also accumulate and, over time, they'll become baked into your codebase. Now, any decision which is hard to revisit later is an architectural decision - \"difficult to change later\" is pretty much the definition of \"architecture\". So, as you proceed, baking your decisions into your codebase, you will be incrementally growing an architecture. So, then, the question is this: is your architecture better than re-frame's? Because that's what re-frame gives you ... an architecture ... solutions to the various challenges you'll face when developing your app, and mechanism for implementing those solutions. Now, in response, some will enthusiastically say \"yes, I want to grow my own architecture. I like mine!\". And fair enough - it can be an interesting ride! Problems arise ONLY when this process is not conscious and purposeful. It is a credit to Reagent that you can accelerate quickly and get a bunch of enjoyable early wins. But, equally, that acceleration can have you off the road in a ditch because of the twists and turns on the way to a larger application. I've had many people (20?) privately say to me that's what happened to them. And that's pretty much the reason for this FAQ - this happens a bit too often and there's been a bit too much pain. So, my advice is ... if your application is a little more complicated, be sure to make a conscious choice around architecture. Don't think \"Reagent is all I need\", because it isn't. One way or another you'll be using \"Reagent + a broader architecture\".","title":"Answer"},{"location":"FAQs/DoINeedReFrame/#example-choices-made-by-re-frame","text":"Events are cardinal. Nothing happens without an event. Events are data (so they are loggable, and can be queued, etc). Dispatched events are handled async - they are put in a queue and handled very soon, but not now (for a variety of subtle reasons). For efficiency, subscriptions (reactions) should be layered and de-duplicated. Views are never imperative or side effecting (best effort). Unidirectional data flow only, ever. Interceptors over middleware. Provide cross cutting concerns like logging and debugging. Event handlers capture control and contain key logic. Ensure purity via coeffects and effects. All state is stored in one place. State is committed-to transactionally, never incrementally or piecemeal. Hmm. I feel like I'm missing a few, but that's certainly an indicative list. re-frame is only about 750 lines of code. So its value is much more in the honed choices it embodies (and documents), than the code it provides.","title":"Example Choices Made By re-frame"},{"location":"FAQs/DoINeedReFrame/#what-reagent-does-provide","text":"Above I said: Reagent, by itself, provides little guidance ... which is true but, it does provide useful building blocks. If you do want to create your own architecture, then be sure to check out Reagent's track , reaction and rswap . There's also other Reagent-based architectures like keechma and carry which make different choices - ones which may better suit your needs.","title":"What Reagent Does Provide"},{"location":"FAQs/FocusOnElement/","text":"\u00b6 Question \u00b6 How do I switch \"focus\" to a particular HTML element? HTML autofocus \u00b6 Perhaps you can use the autofocus HTML element attribute like this: ( defn view [] [ :input { :type \"text\" :id \"my-id\" :auto-focus true ]) But this might not work in Safari these days (Safari is the new IE 6 of browsers). Instead, you could use a more portable (but more complicated) version of this approach, which uses React refs with a Form-3 component: ( defn my-input [] ( let [ ref ( atom nil )] ( r/create-class { :component-did-mount ( fn [ _ ] ( .focus @ ref )) :reagent-render ( fn [ _ ] [ :input { :ref # ( reset! ref % )}])}))) A terse way of achiving the same outcome is: [ :input { :ref # ( when % ( .focus % )}] But all these approaches only cause focus once, when the widget is first rendered. You may need to have more control than that. Reagent after-render \u00b6 If you want to switch focus between elements after they have first rendered, you can create an effect handler which uses Reagent's after-render API to register a function that will imperatively set focus: ( re-frame.core/reg-fx :focus-to-element ( fn [ element-id ] ( reagent/after-render # ( some-> js/document ( .getElementById element-id ) .focus )))) WARNING : as written, this code will fail silently if element-id is not found. If you use this code fragment, you may want to detect and report that problem. You can then use this effect within your event handler: ( re-frame.core/reg-event-fx :something ( fn [ cofx event ] { :db .... :focus-to-element some-element-id })) This assumes you can compute or obtain the some-element-id value for the HTML element on which you want focus. One small trick: we perform the imperative focus using Reagent/after-render because sometimes the target HTML element won't exist in the DOM until after the rendering which occurs in the next animation frame.","title":"How to focus on an HTML element"},{"location":"FAQs/FocusOnElement/#_1","text":"","title":""},{"location":"FAQs/FocusOnElement/#question","text":"How do I switch \"focus\" to a particular HTML element?","title":"Question"},{"location":"FAQs/FocusOnElement/#html-autofocus","text":"Perhaps you can use the autofocus HTML element attribute like this: ( defn view [] [ :input { :type \"text\" :id \"my-id\" :auto-focus true ]) But this might not work in Safari these days (Safari is the new IE 6 of browsers). Instead, you could use a more portable (but more complicated) version of this approach, which uses React refs with a Form-3 component: ( defn my-input [] ( let [ ref ( atom nil )] ( r/create-class { :component-did-mount ( fn [ _ ] ( .focus @ ref )) :reagent-render ( fn [ _ ] [ :input { :ref # ( reset! ref % )}])}))) A terse way of achiving the same outcome is: [ :input { :ref # ( when % ( .focus % )}] But all these approaches only cause focus once, when the widget is first rendered. You may need to have more control than that.","title":"HTML autofocus"},{"location":"FAQs/FocusOnElement/#reagent-after-render","text":"If you want to switch focus between elements after they have first rendered, you can create an effect handler which uses Reagent's after-render API to register a function that will imperatively set focus: ( re-frame.core/reg-fx :focus-to-element ( fn [ element-id ] ( reagent/after-render # ( some-> js/document ( .getElementById element-id ) .focus )))) WARNING : as written, this code will fail silently if element-id is not found. If you use this code fragment, you may want to detect and report that problem. You can then use this effect within your event handler: ( re-frame.core/reg-event-fx :something ( fn [ cofx event ] { :db .... :focus-to-element some-element-id })) This assumes you can compute or obtain the some-element-id value for the HTML element on which you want focus. One small trick: we perform the imperative focus using Reagent/after-render because sometimes the target HTML element won't exist in the DOM until after the rendering which occurs in the next animation frame.","title":"Reagent after-render"},{"location":"FAQs/FullStackReframe/","text":"\u00b6 Question \u00b6 I'm interested in taking the re-frame concepts and applying them to my entire Client/Server stack. The Short Answer \u00b6 You'll want to investigate CQRS. The Longer Answer \u00b6 Perhaps watch Bobby Calderwood's video ? Look at his reference implementation or, perhaps, this alternative . Be aware that \"Event Sourcing\" often comes along for the ride with CQRS, but it doesn't have to. It adds complexity (Kafka?). Don't do it lightly. Maybe just use CQRS without ES? If you do want Event Sourcing, then Kafka might be your friend, Greg Young might be your God and Onyx may be useful. Further Related Links \u00b6 Reactive PostgreSQL: https://yogthos.net/posts/2016-11-05-LuminusPostgresNotifications.html Datalog All The Way Down: https://www.youtube.com/watch?v=aI0zVzzoK_E","title":"How do I do full-stack re-frame?"},{"location":"FAQs/FullStackReframe/#_1","text":"","title":""},{"location":"FAQs/FullStackReframe/#question","text":"I'm interested in taking the re-frame concepts and applying them to my entire Client/Server stack.","title":"Question"},{"location":"FAQs/FullStackReframe/#the-short-answer","text":"You'll want to investigate CQRS.","title":"The Short Answer"},{"location":"FAQs/FullStackReframe/#the-longer-answer","text":"Perhaps watch Bobby Calderwood's video ? Look at his reference implementation or, perhaps, this alternative . Be aware that \"Event Sourcing\" often comes along for the ride with CQRS, but it doesn't have to. It adds complexity (Kafka?). Don't do it lightly. Maybe just use CQRS without ES? If you do want Event Sourcing, then Kafka might be your friend, Greg Young might be your God and Onyx may be useful.","title":"The Longer Answer"},{"location":"FAQs/FullStackReframe/#further-related-links","text":"Reactive PostgreSQL: https://yogthos.net/posts/2016-11-05-LuminusPostgresNotifications.html Datalog All The Way Down: https://www.youtube.com/watch?v=aI0zVzzoK_E","title":"Further Related Links"},{"location":"FAQs/GlobalInterceptors/","text":"\u00b6 Question \u00b6 Does re-frame allow me to register global interceptors? Ones which are included for every event handler? Answer (v1.0.0 onwards) \u00b6 Yes, re-frame provides an API for registering global interceptors. The following code creates a global interceptor to keep a track of all events: ;; We'll be recording events into this atom ;; The most recent events will be at the front of the list. ( def event-store ( atom ( list ))) ( defn keep-last-20 [ existing new-one ] ( take 20 ( conj existing new-one ))) ;; this interceptor will collect events and add them to the atom above ( def event-collector ( re-frame.core/->interceptor :id :event-collector :before ( fn [ context ] ( swap! event-store keep-last-20 ( re-frame.core/get-coeffect context :event )) context ))) ;; register this global interceptor early in program's boot process, ;; using re-frame's API ( re-frame.core/reg-global-interceptor event-collector ) Answer (prior to v1.0.0) \u00b6 Prior to v1.0.0, re-frame provided no API to directly support this feature, but there are ways of making it happen. Let's assume you have an interceptor called omni-ceptor which you want automatically added to all your event handlers. You'd write a replacement for both reg-event-db and reg-event-fx , and get these replacements to automatically add omni-ceptor to the interceptor chain at registration time. Here's how to write one of these auto-injecting replacements: ( defn my-reg-event-db ;; a replacement for reg-event-db ;; 2-arity with no interceptors ([ id handler ] ( my-reg-event-db id nil handler )) ;; 3-arity with interceptors ([ id interceptors handler ] ( re-frame.core/reg-event-db ;; which uses reg-event-db id [ omni-ceptor interceptors ] ;; <-- inject `omni-ceptor` handler ))) NB: did you know that interceptor chains are flattened and nils are removed? With this in place, you would always use my-reg-event-db instead of the standard reg-event-db : ( my-reg-event-db :event-id ( fn [ db v ] ... )) And, hey presto, you'd have your omni-ceptor \"globally\" injected.","title":"How do I register a global interceptor"},{"location":"FAQs/GlobalInterceptors/#_1","text":"","title":""},{"location":"FAQs/GlobalInterceptors/#question","text":"Does re-frame allow me to register global interceptors? Ones which are included for every event handler?","title":"Question"},{"location":"FAQs/GlobalInterceptors/#answer-v100-onwards","text":"Yes, re-frame provides an API for registering global interceptors. The following code creates a global interceptor to keep a track of all events: ;; We'll be recording events into this atom ;; The most recent events will be at the front of the list. ( def event-store ( atom ( list ))) ( defn keep-last-20 [ existing new-one ] ( take 20 ( conj existing new-one ))) ;; this interceptor will collect events and add them to the atom above ( def event-collector ( re-frame.core/->interceptor :id :event-collector :before ( fn [ context ] ( swap! event-store keep-last-20 ( re-frame.core/get-coeffect context :event )) context ))) ;; register this global interceptor early in program's boot process, ;; using re-frame's API ( re-frame.core/reg-global-interceptor event-collector )","title":"Answer (v1.0.0 onwards)"},{"location":"FAQs/GlobalInterceptors/#answer-prior-to-v100","text":"Prior to v1.0.0, re-frame provided no API to directly support this feature, but there are ways of making it happen. Let's assume you have an interceptor called omni-ceptor which you want automatically added to all your event handlers. You'd write a replacement for both reg-event-db and reg-event-fx , and get these replacements to automatically add omni-ceptor to the interceptor chain at registration time. Here's how to write one of these auto-injecting replacements: ( defn my-reg-event-db ;; a replacement for reg-event-db ;; 2-arity with no interceptors ([ id handler ] ( my-reg-event-db id nil handler )) ;; 3-arity with interceptors ([ id interceptors handler ] ( re-frame.core/reg-event-db ;; which uses reg-event-db id [ omni-ceptor interceptors ] ;; <-- inject `omni-ceptor` handler ))) NB: did you know that interceptor chains are flattened and nils are removed? With this in place, you would always use my-reg-event-db instead of the standard reg-event-db : ( my-reg-event-db :event-id ( fn [ db v ] ... )) And, hey presto, you'd have your omni-ceptor \"globally\" injected.","title":"Answer (prior to v1.0.0)"},{"location":"FAQs/Inspecting-app-db/","text":"\u00b6 Question \u00b6 How can I inspect the contents of app-db ? Perhaps from figwheel. Short Answer \u00b6 If at a REPL, inspect: re-frame.db/app-db . If at the js console, that's window.re_frame.db.app_db.state . If you want a visual browser of app-db, along with inspecting subpaths of app-db, and diffing changes, use re-frame-10x . You are using cljs-devtools , right? If not, stop everything ( unless you are using re-natal ) and immediately make that happen. Better Answer \u00b6 Are you sure you need to? First, you seldom want to inspect all of app-db . And, second, inspecting via a REPL might be clumsy. Instead, you probably want to inspect a part of app-db . And you probably want to inspect it directly in the GUI itself, not off in a REPL. Here is a useful technique from @escherize. Add something like this to the hiccup of your view ... [ :pre ( with-out-str ( pprint @ interesting ))] This assumes that @interesting is the value (ratom or subscription) you want to observe (note the @ in front). pprint output is nice to read, but not compact. For a more compact view, do this: [ :pre ( pr-str @ some-atom )] ;; NB: using pr-str instead of pprint If you choose to use pprint then you'll need to require it within the ns of your view.cljs : [ cljs.pprint :refer [ pprint ]] Finally, combining the short and long answers, you could even do this: [ :pre ( with-out-str ( pprint @ re-frame.db/app-db ))] ;; see everything! or [ :pre ( with-out-str ( pprint ( :part @ re-frame.db/app-db )))] ;; see a part of it! You definitely have clj-devtools installed now, right? Other Inspection Tools \u00b6 Another very strong tool is re-Frisk which provides a nice solution for navigating and inspecting your re-frame data structures. @yogthos' json-html library provides a slick presentation, at the expense of more screen real estate, and the need to include specific CSS.","title":"How can I Inspect app-db?"},{"location":"FAQs/Inspecting-app-db/#_1","text":"","title":""},{"location":"FAQs/Inspecting-app-db/#question","text":"How can I inspect the contents of app-db ? Perhaps from figwheel.","title":"Question"},{"location":"FAQs/Inspecting-app-db/#short-answer","text":"If at a REPL, inspect: re-frame.db/app-db . If at the js console, that's window.re_frame.db.app_db.state . If you want a visual browser of app-db, along with inspecting subpaths of app-db, and diffing changes, use re-frame-10x . You are using cljs-devtools , right? If not, stop everything ( unless you are using re-natal ) and immediately make that happen.","title":"Short Answer"},{"location":"FAQs/Inspecting-app-db/#better-answer","text":"Are you sure you need to? First, you seldom want to inspect all of app-db . And, second, inspecting via a REPL might be clumsy. Instead, you probably want to inspect a part of app-db . And you probably want to inspect it directly in the GUI itself, not off in a REPL. Here is a useful technique from @escherize. Add something like this to the hiccup of your view ... [ :pre ( with-out-str ( pprint @ interesting ))] This assumes that @interesting is the value (ratom or subscription) you want to observe (note the @ in front). pprint output is nice to read, but not compact. For a more compact view, do this: [ :pre ( pr-str @ some-atom )] ;; NB: using pr-str instead of pprint If you choose to use pprint then you'll need to require it within the ns of your view.cljs : [ cljs.pprint :refer [ pprint ]] Finally, combining the short and long answers, you could even do this: [ :pre ( with-out-str ( pprint @ re-frame.db/app-db ))] ;; see everything! or [ :pre ( with-out-str ( pprint ( :part @ re-frame.db/app-db )))] ;; see a part of it! You definitely have clj-devtools installed now, right?","title":"Better Answer"},{"location":"FAQs/Inspecting-app-db/#other-inspection-tools","text":"Another very strong tool is re-Frisk which provides a nice solution for navigating and inspecting your re-frame data structures. @yogthos' json-html library provides a slick presentation, at the expense of more screen real estate, and the need to include specific CSS.","title":"Other Inspection Tools"},{"location":"FAQs/LoadOnMount/","text":"\u00b6 Question \u00b6 How do I load the data for a view, when the user navigates to that view? For Javascript The Developer \u00b6 Are you from the Javascript/React world? If so, this first section is for you. In re-frame, Components are functions. They compute a materialized view of values which are reactively delivered, and they don't have state. On the other hand, React has a more OO sense of Components. They are classes with state and behaviour. And even React's more modern, so-called function components come with Hooks which are ordered, and often imperative and effectful. So, with respect to Components, re-frame and React are technically different. But it is on a philosophical point that they differ the most: In re-frame, Components are not causal , they are reactive. Whereas React Components are often deeply causal, via Collocated queries, ComponentDidMount, Hooks and Suspense, etc. In React, Components initiate things - like HTTP requests. In re-frame, it is events which are causal (never components). Why this difference? \u00b6 Humans have a cognitive bias: \"what is focal is presumed causal\". Political leaders know this. They like presenting good news themselves because they like to be \"seen\" as causal of good stuff, but they'll get a press secretary to deliver bad news. Movie directors know how to use this when framing their protagonists within the story. Unfortunately, the React team have lost themselves in this bias. They keep trying to make the most focal part of the system (components) also be the causal part. Please stop doing that! It is a mistake. Events are what's causal - they embody the user's intent. Just to be clear, I love React. What an utterly brilliant idea and great execution. I'm deeply grateful because, wow!, did it change things. It is just that I preferred React when it was only trying to be the V part of MVC. Everything since has been downhill. Perhaps read the further explanation in PurelyFunctional.tv's writeup under the heading \"Reacters load data on mount\". Do This Instead \u00b6 With re-frame, imperative, effectful stuff only ever happens during the handling of an event. When the user clicks on a tab to change what is shown to them in the UI, an event is dispatched, and it is the associated event handler which will compute the effects of the user's request. That might include: change application state so the panel is shown further change application state so that a \"twirly busy\" thing is shown issue a database query or open a websocket Also, remember that events should model \"user intent\", like \"review overdue items\". Be sure to never model events like \"load overdue items from database\" because that's just a low level operation performed in the service of fulfilling the user's intent. There's a useful effect handler available for HTTP work: https://github.com/day8/re-frame-http-fx Look at the \"Real World App\" example for inspiration: https://github.com/jacekschae/conduit","title":"How Do I Load On Mount?"},{"location":"FAQs/LoadOnMount/#_1","text":"","title":""},{"location":"FAQs/LoadOnMount/#question","text":"How do I load the data for a view, when the user navigates to that view?","title":"Question"},{"location":"FAQs/LoadOnMount/#for-javascript-the-developer","text":"Are you from the Javascript/React world? If so, this first section is for you. In re-frame, Components are functions. They compute a materialized view of values which are reactively delivered, and they don't have state. On the other hand, React has a more OO sense of Components. They are classes with state and behaviour. And even React's more modern, so-called function components come with Hooks which are ordered, and often imperative and effectful. So, with respect to Components, re-frame and React are technically different. But it is on a philosophical point that they differ the most: In re-frame, Components are not causal , they are reactive. Whereas React Components are often deeply causal, via Collocated queries, ComponentDidMount, Hooks and Suspense, etc. In React, Components initiate things - like HTTP requests. In re-frame, it is events which are causal (never components).","title":"For Javascript The Developer"},{"location":"FAQs/LoadOnMount/#why-this-difference","text":"Humans have a cognitive bias: \"what is focal is presumed causal\". Political leaders know this. They like presenting good news themselves because they like to be \"seen\" as causal of good stuff, but they'll get a press secretary to deliver bad news. Movie directors know how to use this when framing their protagonists within the story. Unfortunately, the React team have lost themselves in this bias. They keep trying to make the most focal part of the system (components) also be the causal part. Please stop doing that! It is a mistake. Events are what's causal - they embody the user's intent. Just to be clear, I love React. What an utterly brilliant idea and great execution. I'm deeply grateful because, wow!, did it change things. It is just that I preferred React when it was only trying to be the V part of MVC. Everything since has been downhill. Perhaps read the further explanation in PurelyFunctional.tv's writeup under the heading \"Reacters load data on mount\".","title":"Why this difference?"},{"location":"FAQs/LoadOnMount/#do-this-instead","text":"With re-frame, imperative, effectful stuff only ever happens during the handling of an event. When the user clicks on a tab to change what is shown to them in the UI, an event is dispatched, and it is the associated event handler which will compute the effects of the user's request. That might include: change application state so the panel is shown further change application state so that a \"twirly busy\" thing is shown issue a database query or open a websocket Also, remember that events should model \"user intent\", like \"review overdue items\". Be sure to never model events like \"load overdue items from database\" because that's just a low level operation performed in the service of fulfilling the user's intent. There's a useful effect handler available for HTTP work: https://github.com/day8/re-frame-http-fx Look at the \"Real World App\" example for inspiration: https://github.com/jacekschae/conduit","title":"Do This Instead"},{"location":"FAQs/Logging/","text":"\u00b6 Question \u00b6 I use logging method X, how can I make re-frame use my method? Answer \u00b6 re-frame makes use of the logging functions: warn , log , error , group and groupEnd . By default, these functions map directly to the js/console equivalents, but you can override that by providing your own set or subset of these functions using re-frame.core/set-loggers! like this: ( defn my-warn [ & args ] ( post-warning-somewhere ( apply str args ))) ( defn my-log [ & args ] ( write-to-datadog ( apply str args ))) ( re-frame.core/set-loggers! { :warn my-warn :log my-log ... })","title":"How do I use logging method X"},{"location":"FAQs/Logging/#_1","text":"","title":""},{"location":"FAQs/Logging/#question","text":"I use logging method X, how can I make re-frame use my method?","title":"Question"},{"location":"FAQs/Logging/#answer","text":"re-frame makes use of the logging functions: warn , log , error , group and groupEnd . By default, these functions map directly to the js/console equivalents, but you can override that by providing your own set or subset of these functions using re-frame.core/set-loggers! like this: ( defn my-warn [ & args ] ( post-warning-somewhere ( apply str args ))) ( defn my-log [ & args ] ( write-to-datadog ( apply str args ))) ( re-frame.core/set-loggers! { :warn my-warn :log my-log ... })","title":"Answer"},{"location":"FAQs/Null-Dispatched-Events/","text":"\u00b6 Question \u00b6 If I dispatch a js event object (from a view), it is nullified by the time it gets to the event-handler. What gives? :on-click ( fn [ event ] ( dispatch [ :clicked event ])) Short Answer \u00b6 If you want to dispatch a js event object to a re-frame event handler, you must call (.persist event) before the dispatch . React recycles events (using a pool), and re-frame event handlers run async. Find out more here Longer Answer \u00b6 It is better to extract the salient details from the event and dispatch them, rather than the entire js event object. When you dispatch pure, simple ClojureScript data (ie. rather than js objects) testing and debugging will be easier. To put this point even more strongly again, think about it like this: a DOM on-click callback might tell us \"a button was clicked\" our application must then interpret that click. The click means the user wanted to achieve something. They had \"intent\". it is this \"intent\" which should be captured in the re-frame event which is dispatched. It is this intent which the event handler must later facilitate. So, in summary, re-frame view functions should transform DOM events into re-frame events which capture user intent: \"a button was clicked\" becomes user wants to delete item with id 42 As a result, philosophically, low-level DOM objects have no place in an event.","title":"Dispatched Events Are Null"},{"location":"FAQs/Null-Dispatched-Events/#_1","text":"","title":""},{"location":"FAQs/Null-Dispatched-Events/#question","text":"If I dispatch a js event object (from a view), it is nullified by the time it gets to the event-handler. What gives? :on-click ( fn [ event ] ( dispatch [ :clicked event ]))","title":"Question"},{"location":"FAQs/Null-Dispatched-Events/#short-answer","text":"If you want to dispatch a js event object to a re-frame event handler, you must call (.persist event) before the dispatch . React recycles events (using a pool), and re-frame event handlers run async. Find out more here","title":"Short Answer"},{"location":"FAQs/Null-Dispatched-Events/#longer-answer","text":"It is better to extract the salient details from the event and dispatch them, rather than the entire js event object. When you dispatch pure, simple ClojureScript data (ie. rather than js objects) testing and debugging will be easier. To put this point even more strongly again, think about it like this: a DOM on-click callback might tell us \"a button was clicked\" our application must then interpret that click. The click means the user wanted to achieve something. They had \"intent\". it is this \"intent\" which should be captured in the re-frame event which is dispatched. It is this intent which the event handler must later facilitate. So, in summary, re-frame view functions should transform DOM events into re-frame events which capture user intent: \"a button was clicked\" becomes user wants to delete item with id 42 As a result, philosophically, low-level DOM objects have no place in an event.","title":"Longer Answer"},{"location":"FAQs/PollADatabaseEvery60/","text":"\u00b6 Question \u00b6 When the user switches to a particular panel, I'd like to start regularly polling my backend (database) - say every 60 seconds. And, then later, when the user switches away from that panel, I want to stop that polling. First, What Not To Do \u00b6 Please be sure to read How Do I Load On Mount? An Answer \u00b6 We'll create an effect. It will be general in nature. It will start and stop the timed/scheduled dispatch of an event. For this FAQ, we want an event dispatched every 60 seconds and each event will trigger a backend poll, but the effect we are about to create will be useful well beyond this narrow case. We'll be creating an effect called, say, :interval . So, event handlers will be returning: { :interval <something> } So now we design the <something> bit. It will be a data format (DSL) which allows an event handler to start and stop a regular event dispatch. To :start a regular dispatch, an event handler would return data in this format: { :interval { :action :start :id :panel-1-query ;; my id for this (so I can cancel later) :frequency 60000 ;; how many ms between dispatches :event [ :panel-query 1 ]}} ;; what to dispatch And to later cancel the regular dispatch, an event handler would return this: { :interval { :action :cancel :id :panel-1-query }} ;; the id provided to :start With that design work done, let's now implement it by registering an effect handler : ( re-frame.core/reg-fx ;; the re-frame API for registering effect handlers :interval ;; the effect id ( let [ live-intervals ( atom {})] ;; storage for live intervals ( fn [{ :keys [ action id frequency event ]}] ;; the handler ( if ( = action :start ) ( swap! live-intervals assoc id ( js/setInterval # ( dispatch event ) frequency )) ( do ( js/clearInterval ( get @ live-intervals id )) ( swap! live-intervals dissoc id )))))) You'd probably want a bit more error checking, but that's the (untested) sketch. A Side Note About Effect Handlers and Figwheel \u00b6 Figwheel provides for the hot reloading of code, which is terrific. But, during development, as Figwheel is reloading code, effectful handlers, like the one above, can be get into a messed up state - existing timers might be lost (and become never-stoppable). Stateful things are grubby in the face of reloading, and all we can do is try to manage for it as best we can, on a case by case basis. One strategy is to put all your grubby effect handlers into their own separate namespace effects.cljs - one that isn't edited often, removing the trigger for a Figwheel reload. OR, you can code defensively for reloading, perhaps like this: ( defonce interval-handler ;; notice the use of defonce ( let [ live-intervals ( atom {})] ;; storage for live intervals ( fn handler [{ :keys [ action id frequency event ]}] ;; the effect handler ( condp = action :clean ( doall ;; <--- new. clean up all existing ( map # ( handler { :action :end :id %1 }) ( keys @ live-intervals )) :start ( swap! live-intervals assoc id ( js/setInterval # ( dispatch event ) frequency ))) :end ( do ( js/clearInterval ( get @ live-intervals id )) ( swap! live-intervals dissoc id )))) ;; when this code is reloaded `:clean` existing intervals ( interval-handler { :action :clean }) ;; now register ( re-frame.core/reg-fx ;; the re-frame API for registering effect handlers :interval ;; the effect id interval-handler ) Key takeaway: every effect handler is statefully grubby in its own special way. So you'll have to come up with strategies to handle Figwheel reloads on a case by case basis. Sometimes there's no escaping an application restart.","title":"How do I turn on/off polling a database every 60 secs"},{"location":"FAQs/PollADatabaseEvery60/#_1","text":"","title":""},{"location":"FAQs/PollADatabaseEvery60/#question","text":"When the user switches to a particular panel, I'd like to start regularly polling my backend (database) - say every 60 seconds. And, then later, when the user switches away from that panel, I want to stop that polling.","title":"Question"},{"location":"FAQs/PollADatabaseEvery60/#first-what-not-to-do","text":"Please be sure to read How Do I Load On Mount?","title":"First, What Not To Do"},{"location":"FAQs/PollADatabaseEvery60/#an-answer","text":"We'll create an effect. It will be general in nature. It will start and stop the timed/scheduled dispatch of an event. For this FAQ, we want an event dispatched every 60 seconds and each event will trigger a backend poll, but the effect we are about to create will be useful well beyond this narrow case. We'll be creating an effect called, say, :interval . So, event handlers will be returning: { :interval <something> } So now we design the <something> bit. It will be a data format (DSL) which allows an event handler to start and stop a regular event dispatch. To :start a regular dispatch, an event handler would return data in this format: { :interval { :action :start :id :panel-1-query ;; my id for this (so I can cancel later) :frequency 60000 ;; how many ms between dispatches :event [ :panel-query 1 ]}} ;; what to dispatch And to later cancel the regular dispatch, an event handler would return this: { :interval { :action :cancel :id :panel-1-query }} ;; the id provided to :start With that design work done, let's now implement it by registering an effect handler : ( re-frame.core/reg-fx ;; the re-frame API for registering effect handlers :interval ;; the effect id ( let [ live-intervals ( atom {})] ;; storage for live intervals ( fn [{ :keys [ action id frequency event ]}] ;; the handler ( if ( = action :start ) ( swap! live-intervals assoc id ( js/setInterval # ( dispatch event ) frequency )) ( do ( js/clearInterval ( get @ live-intervals id )) ( swap! live-intervals dissoc id )))))) You'd probably want a bit more error checking, but that's the (untested) sketch.","title":"An Answer"},{"location":"FAQs/PollADatabaseEvery60/#a-side-note-about-effect-handlers-and-figwheel","text":"Figwheel provides for the hot reloading of code, which is terrific. But, during development, as Figwheel is reloading code, effectful handlers, like the one above, can be get into a messed up state - existing timers might be lost (and become never-stoppable). Stateful things are grubby in the face of reloading, and all we can do is try to manage for it as best we can, on a case by case basis. One strategy is to put all your grubby effect handlers into their own separate namespace effects.cljs - one that isn't edited often, removing the trigger for a Figwheel reload. OR, you can code defensively for reloading, perhaps like this: ( defonce interval-handler ;; notice the use of defonce ( let [ live-intervals ( atom {})] ;; storage for live intervals ( fn handler [{ :keys [ action id frequency event ]}] ;; the effect handler ( condp = action :clean ( doall ;; <--- new. clean up all existing ( map # ( handler { :action :end :id %1 }) ( keys @ live-intervals )) :start ( swap! live-intervals assoc id ( js/setInterval # ( dispatch event ) frequency ))) :end ( do ( js/clearInterval ( get @ live-intervals id )) ( swap! live-intervals dissoc id )))) ;; when this code is reloaded `:clean` existing intervals ( interval-handler { :action :clean }) ;; now register ( re-frame.core/reg-fx ;; the re-frame API for registering effect handlers :interval ;; the effect id interval-handler ) Key takeaway: every effect handler is statefully grubby in its own special way. So you'll have to come up with strategies to handle Figwheel reloads on a case by case basis. Sometimes there's no escaping an application restart.","title":"A Side Note About Effect Handlers and Figwheel"},{"location":"FAQs/UseASubscriptionInAJsEvent/","text":"Question \u00b6 How do I access the value of a subscription from within a Reagent or JavaScript event (such as on-click)? The Wrong Way \u00b6 You should NOT do this: [ :input { :type \"button\" :value \"Click me!\" :on-click # ( let [ sub-val @ ( subscribe [ :something ])] ;;<--- Eeek .... )}] because that subscribe : 1. might create a memory leak (the subscription might not be \"freed\") 2. makes the event handler impure (it grabs a global value) The Better Way \u00b6 If your on-click function requires access to re-frame data, the first thing you should do is convert it to a re-frame event and dispatch that instead. ( re-frame.core/reg-event-fx :input/on-click ( fn [ coeffects event ] .... )) [ :input { :type \"button\" :value \"Click me!\" :on-click # ( dispatch [ :input/on-click % ])}] Since you have access to the coeffects now, you may be able to get the data you need directly rather than using a subscription. If you still need to use a subscription, then visit How can I use a subscription in an Event Handler to see how to inject the subscription value directly into your coeffects and avoid the possibility of a memory leak. Up: FAQ Index","title":"UseASubscriptionInAJsEvent"},{"location":"FAQs/UseASubscriptionInAJsEvent/#question","text":"How do I access the value of a subscription from within a Reagent or JavaScript event (such as on-click)?","title":"Question"},{"location":"FAQs/UseASubscriptionInAJsEvent/#the-wrong-way","text":"You should NOT do this: [ :input { :type \"button\" :value \"Click me!\" :on-click # ( let [ sub-val @ ( subscribe [ :something ])] ;;<--- Eeek .... )}] because that subscribe : 1. might create a memory leak (the subscription might not be \"freed\") 2. makes the event handler impure (it grabs a global value)","title":"The Wrong Way"},{"location":"FAQs/UseASubscriptionInAJsEvent/#the-better-way","text":"If your on-click function requires access to re-frame data, the first thing you should do is convert it to a re-frame event and dispatch that instead. ( re-frame.core/reg-event-fx :input/on-click ( fn [ coeffects event ] .... )) [ :input { :type \"button\" :value \"Click me!\" :on-click # ( dispatch [ :input/on-click % ])}] Since you have access to the coeffects now, you may be able to get the data you need directly rather than using a subscription. If you still need to use a subscription, then visit How can I use a subscription in an Event Handler to see how to inject the subscription value directly into your coeffects and avoid the possibility of a memory leak. Up: FAQ Index","title":"The Better Way"},{"location":"FAQs/UseASubscriptionInAnEventHandler/","text":"\u00b6 Question \u00b6 How do I access the value of a subscription from within an event handler? The Wrong Way \u00b6 You should NOT do this: ( re-frame.core/reg-event-db :event-id ( fn [ db v ] ( let [ sub-val @ ( subscribe [ :something ])] ;; <--- Eeek .... ))) because that subscribe : 1. might create a memory leak (the subscription might not be \"freed\") 2. makes the event handler impure (it grabs a global value) The Better Way \u00b6 Instead, the value of a subscription should be injected into the coeffects of that handler via an interceptor. A sketch: ( re-frame.core/reg-event-fx ;; handler must access coeffects, so use -fx :event-id ( inject-sub [ :query-id :param ]) ;; <-- interceptor will inject subscription value into coeffects ( fn [ coeffects event ] ( let [ sub-val ( :something coeffects )] ;; obtain subscription value .... ))) Notes: 1. inject-sub is an interceptor which will get the subscription value and add it to coeffects (somehow) 2. The event handler obtains the value from coeffects So, how to write this inject-sub interceptor? Solutions \u00b6 re-frame doesn't yet have a builtin inject-sub interceptor to do this injection. I'd suggest you use this 3rd party library: https://github.com/vimsical/re-frame-utils/blob/master/src/vimsical/re_frame/cofx/inject.cljc","title":"How can I use a subscription in an Event Handler"},{"location":"FAQs/UseASubscriptionInAnEventHandler/#_1","text":"","title":""},{"location":"FAQs/UseASubscriptionInAnEventHandler/#question","text":"How do I access the value of a subscription from within an event handler?","title":"Question"},{"location":"FAQs/UseASubscriptionInAnEventHandler/#the-wrong-way","text":"You should NOT do this: ( re-frame.core/reg-event-db :event-id ( fn [ db v ] ( let [ sub-val @ ( subscribe [ :something ])] ;; <--- Eeek .... ))) because that subscribe : 1. might create a memory leak (the subscription might not be \"freed\") 2. makes the event handler impure (it grabs a global value)","title":"The Wrong Way"},{"location":"FAQs/UseASubscriptionInAnEventHandler/#the-better-way","text":"Instead, the value of a subscription should be injected into the coeffects of that handler via an interceptor. A sketch: ( re-frame.core/reg-event-fx ;; handler must access coeffects, so use -fx :event-id ( inject-sub [ :query-id :param ]) ;; <-- interceptor will inject subscription value into coeffects ( fn [ coeffects event ] ( let [ sub-val ( :something coeffects )] ;; obtain subscription value .... ))) Notes: 1. inject-sub is an interceptor which will get the subscription value and add it to coeffects (somehow) 2. The event handler obtains the value from coeffects So, how to write this inject-sub interceptor?","title":"The Better Way"},{"location":"FAQs/UseASubscriptionInAnEventHandler/#solutions","text":"re-frame doesn't yet have a builtin inject-sub interceptor to do this injection. I'd suggest you use this 3rd party library: https://github.com/vimsical/re-frame-utils/blob/master/src/vimsical/re_frame/cofx/inject.cljc","title":"Solutions"},{"location":"FAQs/ViewsOnGlobalRegistration/","text":"\u00b6 Question \u00b6 I feel offended by re-frame's reg-* API. How is it functional to side effect globally? Background \u00b6 A re-frame app is defined collectively by its handlers. As an app boots, calls to registration functions like reg-event-db and reg-sub collectively \"build up\" an app, infusing it with behaviour and capability. Currently, this \"building up\" process involves the progressive mutation of a global registrar (map) held internally within re-frame . Each registration adds a new entry to this registrar . How should we analyse this from a functional point of view? Answer \u00b6 There are three ways to view this: Egads! Say it isn't true. Mutation of a global? Summon the functional lynch mob! In theory, top-level side effects will introduce some pain points, but re-frame's design represents a conscious decision to trade off functional purity for simplicity of everyday developer experience. So, yes, re-frame represents a point in the possible design space, with associated pros and cons. But the cons tend to be theoretical and the pros are real. Actually, there's no purity problem! As a Clojure program starts, each defn (becomes a def which) happily interns a symbol and function in a map-ish structure representing a namespace . The lynch mob stays home for that. The pitchforks remain in their rack. re-frame handler registration is the same pattern - an id and handler function are interned within a map-ish structure (a registrar ), once, on program load. So, if you feel uncomfortable with what re-frame does, you should also feel uncomfortable about using defn . Also, it would be useful to understand how you are creating a virtual machine when you program re-frame While Point 3 is an interesting perspective to consider, the real discussion should probably be around points 1 and 2: is it a good idea for re-frame to tradeoff purity for simplicity? You can't really judge this properly until you have used it and experienced the simplicity, and/or found pain points (devcards!). Many people experience few problems and live happily ever after. For others, the conceptual distaste is insurmountable and nagging. Like it or hate it, please realise it was a deliberate and conscious design decision, not some oversight.","title":"re-frame uses side-effecting registrations. Should I feel dirty?"},{"location":"FAQs/ViewsOnGlobalRegistration/#_1","text":"","title":""},{"location":"FAQs/ViewsOnGlobalRegistration/#question","text":"I feel offended by re-frame's reg-* API. How is it functional to side effect globally?","title":"Question"},{"location":"FAQs/ViewsOnGlobalRegistration/#background","text":"A re-frame app is defined collectively by its handlers. As an app boots, calls to registration functions like reg-event-db and reg-sub collectively \"build up\" an app, infusing it with behaviour and capability. Currently, this \"building up\" process involves the progressive mutation of a global registrar (map) held internally within re-frame . Each registration adds a new entry to this registrar . How should we analyse this from a functional point of view?","title":"Background"},{"location":"FAQs/ViewsOnGlobalRegistration/#answer","text":"There are three ways to view this: Egads! Say it isn't true. Mutation of a global? Summon the functional lynch mob! In theory, top-level side effects will introduce some pain points, but re-frame's design represents a conscious decision to trade off functional purity for simplicity of everyday developer experience. So, yes, re-frame represents a point in the possible design space, with associated pros and cons. But the cons tend to be theoretical and the pros are real. Actually, there's no purity problem! As a Clojure program starts, each defn (becomes a def which) happily interns a symbol and function in a map-ish structure representing a namespace . The lynch mob stays home for that. The pitchforks remain in their rack. re-frame handler registration is the same pattern - an id and handler function are interned within a map-ish structure (a registrar ), once, on program load. So, if you feel uncomfortable with what re-frame does, you should also feel uncomfortable about using defn . Also, it would be useful to understand how you are creating a virtual machine when you program re-frame While Point 3 is an interesting perspective to consider, the real discussion should probably be around points 1 and 2: is it a good idea for re-frame to tradeoff purity for simplicity? You can't really judge this properly until you have used it and experienced the simplicity, and/or found pain points (devcards!). Many people experience few problems and live happily ever after. For others, the conceptual distaste is insurmountable and nagging. Like it or hate it, please realise it was a deliberate and conscious design decision, not some oversight.","title":"Answer"},{"location":"FAQs/When-Does-Dispatch-Happen/","text":"\u00b6 Question \u00b6 How long after I call dispatch will the event be processed? Answer \u00b6 The answer is \"it depends\", but this comment in the code might provide you the answers you seek.","title":"How long after I do a dispatch does the event get handled?"},{"location":"FAQs/When-Does-Dispatch-Happen/#_1","text":"","title":""},{"location":"FAQs/When-Does-Dispatch-Happen/#question","text":"How long after I call dispatch will the event be processed?","title":"Question"},{"location":"FAQs/When-Does-Dispatch-Happen/#answer","text":"The answer is \"it depends\", but this comment in the code might provide you the answers you seek.","title":"Answer"},{"location":"FAQs/Why-CLJC/","text":"\u00b6 Question \u00b6 Why is re-frame implemented in .cljc files? Aren't ClojureScript files meant to be .cljs ? Answer \u00b6 So tests can be run on both the JVM and the JS platforms, re-frame's implementation is mostly in .cljc files. The trailing c in .cljc stands for common . Necessary interop for each platform can be found in interop.clj (for the JVM) and interop.cljs (for JS). See also: https://github.com/day8/re-frame-test","title":"Why is re-frame implemented in `.cljc` files"},{"location":"FAQs/Why-CLJC/#_1","text":"","title":""},{"location":"FAQs/Why-CLJC/#question","text":"Why is re-frame implemented in .cljc files? Aren't ClojureScript files meant to be .cljs ?","title":"Question"},{"location":"FAQs/Why-CLJC/#answer","text":"So tests can be run on both the JVM and the JS platforms, re-frame's implementation is mostly in .cljc files. The trailing c in .cljc stands for common . Necessary interop for each platform can be found in interop.clj (for the JVM) and interop.cljs (for JS). See also: https://github.com/day8/re-frame-test","title":"Answer"},{"location":"FAQs/Why-Clear-Sub-Cache/","text":"\u00b6 Question \u00b6 Why do we call clear-subscription-cache! when reloading code with Figwheel? Answer \u00b6 Pour yourself a drink, as this is a circuitous tale involving one of the hardest problems in Computer Science. 1: Humble beginnings When React is rendering, if an exception is thrown, it doesn't catch or handle the errors gracefully. Instead, all of the React components up to the root are destroyed. When these components are destroyed, none of their standard lifecycle methods are called, like ComponentDidUnmount . 2: Simple assumptions Reagent tracks the watchers of a Reaction to know when no-one is watching and it can call the Reaction's on-dispose . Part of the book-keeping involved in this requires running the on-dispose in a React ComponentWillUnmount lifecycle method. At this point, your spidey senses are probably tingling. 3: The hardest problem in CS re-frame subscriptions are created as Reactions. re-frame helpfully deduplicates subscriptions if multiple parts of the view request the same subscription. This is a big efficiency boost. When re-frame creates the subscription Reaction, it sets the on-dispose method of that subscription to remove itself from the subscription cache. This means that when that subscription isn't being watched by any part of the view, it can be disposed. 4: The gnarly implications If you are Writing a re-frame app Write a bug in your subscription code (your one bug for the year) Which causes an exception to be thrown in your rendering code then: React will destroy all of the components in your view without calling ComponentWillUnmount . Reagent will not get notified that some subscriptions are not needed anymore. The subscription on-dispose functions that should have been run, are not. re-frame's subscription cache will not be invalidated correctly, and the subscription with the bug is still in the cache. At this point you are looking at a blank screen. After debugging, you find the problem and fix it. You save your code and Figwheel recompiles and reloads the changed code. Figwheel attempts to re-render from the root. This causes all of the Reagent views to be rendered and to request re-frame subscriptions if they need them. Because the old buggy subscription is still sitting around in the cache, re-frame will return that subscription instead of creating a new one based on the fixed code. The only way around this (once you realise what is going on) is to reload the page. 5: Coda re-frame 0.9.0 provides a new function: re-frame.core/clear-subscription-cache! which will run the on-dispose function for every subscription in the cache, emptying the cache, and causing new subscriptions to be created after reloading.","title":"Why do we need to clear the subscription cache when reloading with Figwheel?"},{"location":"FAQs/Why-Clear-Sub-Cache/#_1","text":"","title":""},{"location":"FAQs/Why-Clear-Sub-Cache/#question","text":"Why do we call clear-subscription-cache! when reloading code with Figwheel?","title":"Question"},{"location":"FAQs/Why-Clear-Sub-Cache/#answer","text":"Pour yourself a drink, as this is a circuitous tale involving one of the hardest problems in Computer Science. 1: Humble beginnings When React is rendering, if an exception is thrown, it doesn't catch or handle the errors gracefully. Instead, all of the React components up to the root are destroyed. When these components are destroyed, none of their standard lifecycle methods are called, like ComponentDidUnmount . 2: Simple assumptions Reagent tracks the watchers of a Reaction to know when no-one is watching and it can call the Reaction's on-dispose . Part of the book-keeping involved in this requires running the on-dispose in a React ComponentWillUnmount lifecycle method. At this point, your spidey senses are probably tingling. 3: The hardest problem in CS re-frame subscriptions are created as Reactions. re-frame helpfully deduplicates subscriptions if multiple parts of the view request the same subscription. This is a big efficiency boost. When re-frame creates the subscription Reaction, it sets the on-dispose method of that subscription to remove itself from the subscription cache. This means that when that subscription isn't being watched by any part of the view, it can be disposed. 4: The gnarly implications If you are Writing a re-frame app Write a bug in your subscription code (your one bug for the year) Which causes an exception to be thrown in your rendering code then: React will destroy all of the components in your view without calling ComponentWillUnmount . Reagent will not get notified that some subscriptions are not needed anymore. The subscription on-dispose functions that should have been run, are not. re-frame's subscription cache will not be invalidated correctly, and the subscription with the bug is still in the cache. At this point you are looking at a blank screen. After debugging, you find the problem and fix it. You save your code and Figwheel recompiles and reloads the changed code. Figwheel attempts to re-render from the root. This causes all of the Reagent views to be rendered and to request re-frame subscriptions if they need them. Because the old buggy subscription is still sitting around in the cache, re-frame will return that subscription instead of creating a new one based on the fixed code. The only way around this (once you realise what is going on) is to reload the page. 5: Coda re-frame 0.9.0 provides a new function: re-frame.core/clear-subscription-cache! which will run the on-dispose function for every subscription in the cache, emptying the cache, and causing new subscriptions to be created after reloading.","title":"Answer"},{"location":"FAQs/laggy-input/","text":"\u00b6 Question \u00b6 My input field is laggy. When the user types quickly, it is dropping characters. I have implemented it like this: [ :input { :type \"text\" :value @ ( rf/subscribe [ ::subs/username ]) :on-change # ( rf/dispatch [ ::events/change-username ( -> % .-target .-value )])}] Answer \u00b6 That on-change handler is being called after the user types every character. If the user is typing very quickly, then the following race condition can occur: The user types a new character taking the field from state A to state B ( B has one new, extra character in it, compared to state A ) The change event for state B is dispatched by on-change . And that event is queued for processing. But before that event can be processed, the browser schedules an animation frame. In that animation frame the component is re-rendered But during that re-render the subscribe will deliver state A That means the text in the box will revert from state B to state A (the character just typed won't be in the input) Now if nothing happened till the next animation frame the situation would resolve itself. Because state B would be rendered next time because the event which included the new character would have been processed well before then. BUT if the user immediately types another character, the state dispatched will be State A + new character . The prevous character typed, which caused A -> B, is now lost. Bottom line: with very fast typing, characters can get dropped just before animation-frames. There are three solutions: don't use on-change , and instead use on-blur which is only called when the user has done all their fast typing and they leave the field. if you have to use on-change then switch to use dispatch-sync in on-change , instead of dispatch . The event will not be placed on the queue. It will be handled immediately. Synchronously. use a component from something like re-com because it has been engineered to not have this problem. Or copy the (local state) technique it uses.","title":"Why is my input field laggy?"},{"location":"FAQs/laggy-input/#_1","text":"","title":""},{"location":"FAQs/laggy-input/#question","text":"My input field is laggy. When the user types quickly, it is dropping characters. I have implemented it like this: [ :input { :type \"text\" :value @ ( rf/subscribe [ ::subs/username ]) :on-change # ( rf/dispatch [ ::events/change-username ( -> % .-target .-value )])}]","title":"Question"},{"location":"FAQs/laggy-input/#answer","text":"That on-change handler is being called after the user types every character. If the user is typing very quickly, then the following race condition can occur: The user types a new character taking the field from state A to state B ( B has one new, extra character in it, compared to state A ) The change event for state B is dispatched by on-change . And that event is queued for processing. But before that event can be processed, the browser schedules an animation frame. In that animation frame the component is re-rendered But during that re-render the subscribe will deliver state A That means the text in the box will revert from state B to state A (the character just typed won't be in the input) Now if nothing happened till the next animation frame the situation would resolve itself. Because state B would be rendered next time because the event which included the new character would have been processed well before then. BUT if the user immediately types another character, the state dispatched will be State A + new character . The prevous character typed, which caused A -> B, is now lost. Bottom line: with very fast typing, characters can get dropped just before animation-frames. There are three solutions: don't use on-change , and instead use on-blur which is only called when the user has done all their fast typing and they leave the field. if you have to use on-change then switch to use dispatch-sync in on-change , instead of dispatch . The event will not be placed on the queue. It will be handled immediately. Synchronously. use a component from something like re-com because it has been engineered to not have this problem. Or copy the (local state) technique it uses.","title":"Answer"},{"location":"images/logo/","text":"See the ai folder to illustrator files.","title":"Index"},{"location":"releases/2015/","text":"\u00b6 0.6.0 (2015-12-09) \u00b6 New API: #118 - Add add-post-event-callback to the API. @pupeno is developing prerenderer which looks pretty neat. Support this effort by adding a way for prerenderer to hook event processing. on-changes middleware now official. No longer experimental. Improvements: #134 My thanks to @scgilardi for a nice simplification of the routing state machine. Again! #133 Improve Readme formatting 0.5.0 (2015-11-5) \u00b6 New Features: #108 - Add dynamic subscriptions. Docs to follow, and your cheque is in the mail. Improvements: fixed problem with log grouping removed -------New Event------- log msg made groups collapsed by default #104 - Updated to the latest TodoMVC CSS Reimplemented the router loop. Removed use of core.async. Replaced with hand rolled scheduling. See 420e42a As a result: there is less of a pause between a dispatch and the associated event handler being run. (<1ms vs 5ms??) groups of events queued up will be handled in a batch, one after the other, without yielding to the browser (previously re-frame yielded to the browser before every single event). This fixes issues like #39 and #121 I doubt this will affect normal apps. But it could affect games which depend on existing timings. Maybe. It could affect apps which dispatch large volumes of events (telemetry?) very quickly. Maybe. v0.4.1 (2015-05-29) \u00b6 Improvements: fix #65 - Detect mistaken use of middleware factories examples/ now work with figwheel v0.4.0 (2015-05-04) \u00b6 Headline: Exceptions in event handlers no longer break the router loop. Previously, any exception in an event handler broke the app permanently. This change will: improve the debugging experience with figwheel mean apps, in production, stand a chance of reporting UHE to the user, and can perhaps even recover to a sane state. #53 Fix Logging And Error Reporting You can now provide your own logging functions. Further explanation here . Deprecated: log-ex middleware is no longer needed. Simply remove its use. Sometime in the last couple of months, changes to the CLJS runtime meant that useful exceptions could escape go-loops, and good stack traces appear (at least in Chrome). New Features: #52 Add a way to purge redos (dispatch [:purge-redos]) When trying to recover from an UHE, do an undo to get back to the last sane state, and then use this new feature to purge the just-generated-redo. #43 Add ability to clear handlers (event and subs) via two new API functions: re-frame.core/clear-sub-handlers! re-frame.core/clear-event-handlers! Useful for those using the ClojureScript fork of Component . Experimental: #50 Add \"reaction-like\" middleware called on-changes . Other: improve some comments in todomvc example v0.3.2 (2015-04-21) \u00b6 Improvements: Fix #42 - Put in checks for dispatch-sync Fix #49 - add table of content and link to wiki for middleware Fix #46 - Minor typos fixed v0.3.1 (2015-04-18) \u00b6 Various small improvements and bug fixes: log-ex middleware added to core api (it was a mistake that it was missing) modest improves to simple example. Better comments, layout, etc. the anonymous functions in standard middleware now have meaningful names, which makes stack traces easier to understand. #24 - Fix missing paren in README #31 - Fix list formatting in README #32 - fix a broken wiki link #30 - Fix up the enrich docstring v0.3.0 (2015-04-15) \u00b6 Headline \u00b6 the middleware after and enrich now call the supplied function f with both db and v (previously just db ). Because javascript is so forgiving about function arity, this change is backwards compatible. new event handler middleware log-ex for correctly printing handler stacktraces. See explanation . ongoing improvements to the docs in Wiki Other \u00b6 move to reagent v0.5.0 fix undo bug which could result in incorrect explanations. improve todomvc's use of localstorage experimental work with slimmer.js for testing correct README wiki links license.txt was incorrectly named previously v0.2.0 (2015-03-06) \u00b6 Breaking \u00b6 Renames: register-pure-handler renamed to register-handler (and existing low level register-handler becomes register-handler-base but is not a part of the API). remove apply-event middleware and replace with similar trim-v rename register-subs to register-sub (avoid confusion over possible plurals) rename set-max-undos to set-max-undos! Changes: undoable middleware is now a factory. Where before you used this undoable , you must now use this (undoable \"some explanation\") . See further below. Headline \u00b6 exceptions in handler now reported more sanely via console.error. (core.async really messes with a good stack) example todomvc available in examples folder. Wiki documentation is now more substantial. introduce new handler middleware: debug , enrich and after Other: \u00b6 exceptions in a go loop are a special type of hell. Improve the reporting of exceptions happening in event handlers. allow Middleware to be registered as a vector. data > functions > macros fix two bugs in undo implementation name licence file correctly, thanks to @smith fix typo in readme, thanks to @btheado Readme now admits to 200 lines of code, not 100. dispatch now explicitly returns nil travis integration (not that we have any tests currently) Details On Undo Changes \u00b6 The undo/redo feature built into re-frame is now more functional (at the cost of a breaking change). There is now an explanation associated with each undo state describing modification. This allows an app to inform the user what actions they will be undoing or redoing. Previously undoable was simply middleware, but it is now a middleware factory. Essentially, that means you can't use it \"plain\" anymore, and instead you must call it, like this (undoable \"Some explanation\") The explanation provided to undoable must be either a string (static explanation) or a function (db event) -> string , allowing you to customize the undo message based on details of the event. v0.1.7 (2015-02-25) \u00b6 Initial public release v0.1.1 (2014-12-18) \u00b6 Internal beta release","title":2015},{"location":"releases/2015/#_1","text":"","title":""},{"location":"releases/2015/#060-2015-12-09","text":"New API: #118 - Add add-post-event-callback to the API. @pupeno is developing prerenderer which looks pretty neat. Support this effort by adding a way for prerenderer to hook event processing. on-changes middleware now official. No longer experimental. Improvements: #134 My thanks to @scgilardi for a nice simplification of the routing state machine. Again! #133 Improve Readme formatting","title":"0.6.0  (2015-12-09)"},{"location":"releases/2015/#050-2015-11-5","text":"New Features: #108 - Add dynamic subscriptions. Docs to follow, and your cheque is in the mail. Improvements: fixed problem with log grouping removed -------New Event------- log msg made groups collapsed by default #104 - Updated to the latest TodoMVC CSS Reimplemented the router loop. Removed use of core.async. Replaced with hand rolled scheduling. See 420e42a As a result: there is less of a pause between a dispatch and the associated event handler being run. (<1ms vs 5ms??) groups of events queued up will be handled in a batch, one after the other, without yielding to the browser (previously re-frame yielded to the browser before every single event). This fixes issues like #39 and #121 I doubt this will affect normal apps. But it could affect games which depend on existing timings. Maybe. It could affect apps which dispatch large volumes of events (telemetry?) very quickly. Maybe.","title":"0.5.0  (2015-11-5)"},{"location":"releases/2015/#v041-2015-05-29","text":"Improvements: fix #65 - Detect mistaken use of middleware factories examples/ now work with figwheel","title":"v0.4.1 (2015-05-29)"},{"location":"releases/2015/#v040-2015-05-04","text":"Headline: Exceptions in event handlers no longer break the router loop. Previously, any exception in an event handler broke the app permanently. This change will: improve the debugging experience with figwheel mean apps, in production, stand a chance of reporting UHE to the user, and can perhaps even recover to a sane state. #53 Fix Logging And Error Reporting You can now provide your own logging functions. Further explanation here . Deprecated: log-ex middleware is no longer needed. Simply remove its use. Sometime in the last couple of months, changes to the CLJS runtime meant that useful exceptions could escape go-loops, and good stack traces appear (at least in Chrome). New Features: #52 Add a way to purge redos (dispatch [:purge-redos]) When trying to recover from an UHE, do an undo to get back to the last sane state, and then use this new feature to purge the just-generated-redo. #43 Add ability to clear handlers (event and subs) via two new API functions: re-frame.core/clear-sub-handlers! re-frame.core/clear-event-handlers! Useful for those using the ClojureScript fork of Component . Experimental: #50 Add \"reaction-like\" middleware called on-changes . Other: improve some comments in todomvc example","title":"v0.4.0  (2015-05-04)"},{"location":"releases/2015/#v032-2015-04-21","text":"Improvements: Fix #42 - Put in checks for dispatch-sync Fix #49 - add table of content and link to wiki for middleware Fix #46 - Minor typos fixed","title":"v0.3.2  (2015-04-21)"},{"location":"releases/2015/#v031-2015-04-18","text":"Various small improvements and bug fixes: log-ex middleware added to core api (it was a mistake that it was missing) modest improves to simple example. Better comments, layout, etc. the anonymous functions in standard middleware now have meaningful names, which makes stack traces easier to understand. #24 - Fix missing paren in README #31 - Fix list formatting in README #32 - fix a broken wiki link #30 - Fix up the enrich docstring","title":"v0.3.1  (2015-04-18)"},{"location":"releases/2015/#v030-2015-04-15","text":"","title":"v0.3.0  (2015-04-15)"},{"location":"releases/2015/#headline","text":"the middleware after and enrich now call the supplied function f with both db and v (previously just db ). Because javascript is so forgiving about function arity, this change is backwards compatible. new event handler middleware log-ex for correctly printing handler stacktraces. See explanation . ongoing improvements to the docs in Wiki","title":"Headline"},{"location":"releases/2015/#other","text":"move to reagent v0.5.0 fix undo bug which could result in incorrect explanations. improve todomvc's use of localstorage experimental work with slimmer.js for testing correct README wiki links license.txt was incorrectly named previously","title":"Other"},{"location":"releases/2015/#v020-2015-03-06","text":"","title":"v0.2.0  (2015-03-06)"},{"location":"releases/2015/#breaking","text":"Renames: register-pure-handler renamed to register-handler (and existing low level register-handler becomes register-handler-base but is not a part of the API). remove apply-event middleware and replace with similar trim-v rename register-subs to register-sub (avoid confusion over possible plurals) rename set-max-undos to set-max-undos! Changes: undoable middleware is now a factory. Where before you used this undoable , you must now use this (undoable \"some explanation\") . See further below.","title":"Breaking"},{"location":"releases/2015/#headline_1","text":"exceptions in handler now reported more sanely via console.error. (core.async really messes with a good stack) example todomvc available in examples folder. Wiki documentation is now more substantial. introduce new handler middleware: debug , enrich and after","title":"Headline"},{"location":"releases/2015/#other_1","text":"exceptions in a go loop are a special type of hell. Improve the reporting of exceptions happening in event handlers. allow Middleware to be registered as a vector. data > functions > macros fix two bugs in undo implementation name licence file correctly, thanks to @smith fix typo in readme, thanks to @btheado Readme now admits to 200 lines of code, not 100. dispatch now explicitly returns nil travis integration (not that we have any tests currently)","title":"Other:"},{"location":"releases/2015/#details-on-undo-changes","text":"The undo/redo feature built into re-frame is now more functional (at the cost of a breaking change). There is now an explanation associated with each undo state describing modification. This allows an app to inform the user what actions they will be undoing or redoing. Previously undoable was simply middleware, but it is now a middleware factory. Essentially, that means you can't use it \"plain\" anymore, and instead you must call it, like this (undoable \"Some explanation\") The explanation provided to undoable must be either a string (static explanation) or a function (db event) -> string , allowing you to customize the undo message based on details of the event.","title":"Details On Undo Changes"},{"location":"releases/2015/#v017-2015-02-25","text":"Initial public release","title":"v0.1.7  (2015-02-25)"},{"location":"releases/2015/#v011-2014-12-18","text":"Internal beta release","title":"v0.1.1  (2014-12-18)"},{"location":"releases/2016/","text":"\u00b6 0.9.1 (2016.12.20) \u00b6 Fixes #296 Dynamic subscriptions weren't working in re-frame 0.9.0. This has been rectified. The hosts responsible have been taken underground for reprocessing. 0.9.0 (2016.12.15) - The Dolores Release \u00b6 Welcome, board members. Dr Ford has created a new 6-part narrative , and Bernard some infographics . Anyone seen Dolores? Headline The README and /docs have been substantially reworked. #218 Make it okay to use subscribe in Form-1 components. This is a big deal. Breaking Due to the new tracing features using goog-define (described below), re-frame now requires ClojureScript 1.7.48 or above. See Parameterizing ClojureScript Builds for more information. Migrating Added clear-subscription-cache! function. You should call this when you are hot reloading code to ensure that any bad subscriptions that cause rendering exceptions are removed. See Why do we call clear-subscription-cache! ? and reagent-project/reagent#272 for more details. Improvements #200 Remove trailing spaces from console logging Add re-frame.loggers/get-loggers function to well, you know. Added experimental tracing features. These are subject to change and remain undocumented at the moment. By default they are disabled, and will be completely compiled out by advanced optimisations. To enable them, set a :closure-defines key to {\"re_frame.trace.trace_enabled_QMARK_\" true} #223 When using make-restore-fn , dispose of any subscriptions that were created after the restore function was created. #283 Make trim-v interceptor symmetrical, so it adds the missing event id back on to the :event coeffect in the :after function. Fixes #259 Fix a bug where registering a subscription would create and close over dependent subscriptions, meaning that they would never be garbage collected, and doing more work than necessary. Fix a bug where subscribing to a subscription that didn't exist would throw an exception, instead of returning nil. #248 Provide after interceptor with db coeffect, if no db effect was produced. #278 Provide enrich interceptor with db coeffect, if no db effect was produced. 0.8.0 (2016.08.19) - The Walnuts Release \u00b6 Staying on the leading edge of new buzzwords is obviously critical for any framework. Angular's terrifying faceplant is a sobering reminder to us all. With this release, re-frame's already impressive buzzword muscles bulge further with new walnuts like \"effects\", \"coeffects\", \"interceptors\" and \"de-duplicated signal graph\". I know, right? Some may even find these new features useful. Joking aside, this is a substantial release which will change how you use re-frame. Headline re-frame subscriptions are now de-duplicated. As a result, many Signal graphs will be more efficient. The new behaviour better matches programmer intuitions about what \"should\" happen. Each subscription causes a handler to execute, producing a reactive stream of updates. Two calls to (subscribe [:some :query]) results in two copies of the same subscription handler running, each delivering a stream of updates. Now, if these two subscriptions were running at the same time, this would be inefficient. Both handlers would be doing the same computations and delivering the same stream of updates. Unnecessary, duplicate work. Starting with this version, this sort of duplication has been eliminated. Two, or more, concurrent subscriptions for the same query will now source reactive updates from the one executing handler. So, how do we know if two subscriptions are \"the same\"? Answer: two subscriptions are the same if their query vectors test = to each other. So, these two subscriptions are not \"the same\": [:some-event 42] [:some-event \"blah\"] . Even though they involve the same event id, :some-event , the query vectors do not test = . added a new subscription handler registration function called re-frame.core/reg-sub . It is an alternative to re-frame.core/register-sub (now renamed to re-frame.core/reg-sub-raw ). reg-sub is significantly easier to use and understand, while often also being more performant. The design has really fallen out nicely and we're delighted with it. With reg-sub , you no longer need to use reaction explicitly. Subscription handlers are now pure which makes them easier to understand, trace and test etc. Plus, as you'll see in the docs, there is some gratuitous syntactic sugar. Who doesn't like sugar? At this point, the todomvc example represents the best tutorial on the subject: https://github.com/day8/re-frame/blob/master/examples/todomvc/src/todomvc/subs.cljs re-frame now supports the notion of Event Handlers accepting coeffects and returning effects. There's now three kinds of event handlers: -db , -fx and -ctx . For a tutorial see: https://github.com/day8/re-frame/tree/master/docs For Effect Handler examples see: https://github.com/day8/re-frame-http-fx https://github.com/day8/re-frame-forward-events-fx https://github.com/day8/re-frame-async-flow-fx You can now run and debug re-frame tests on the JVM. Just to be clear: this does not mean you can run re-frame apps on the JVM (there's no React or Reagent available). But you can debug your event handler tests using full JVM tooling goodness. @samroberton and @escherize have provided the thought leadership and drive here. They converted re-frame to .cljc , supplying pluggable interop for both the js and jvm platforms. Further, they have worked with @danielcompton to create a library of testing utilities which will hopefully evolve into a nice step forward on both platforms: https://github.com/day8/re-frame-test Work is ongoing in this area. the undo/redo features buried in re-frame has been factored out into a standalone library . undo and redo have been a part of re-frame from the beginning, but they have never officially been made a part of the API, and have not been documented. So it nice to see it available, and fully documented. This new library includes various enhancements over that which previously existed, and it works in with effectful handlers described above. Middleware is dead, long live Interceptors. Up until now, re-frame has allowed you to decorate event handlers with middleware which looked after the cross cutting concerns of tracing, undo/redo, validation, etc. This has proved a neat and successful part of the framework. We thought we were happy. But recently @steveb8n gave a cljsyd talk on Pedestal's Interceptor pattern which suddenly transformed them from arcane to delightfully simple in 20 mins. Interceptors are really \"middleware via data\" rather than \"middleware via higher order functions\". So it is another way of doing the same thing, but thanks to @steveb8n Interceptors appear a more flexible base, and simpler. Interceptors also dovetail really nicely with the effects and coeffects story which has emerged in re-frame through this 0.8.0 release. Docs: https://github.com/day8/re-frame/tree/master/docs we now have a logo designed by Sketch Maester @martinklepsch. Thank you Martin! But remember, no good deed ever goes unpunished - we'll be pestering you every time from now on :-) Breaking requires Reagent >= v0.6.0 re-frame.core/register-handler has been renamed re-frame.core/reg-event-db . There's now three kinds of event-handlers, -db , -fx and -ctx . Event handlers of the 2nd and 3rd kinds should be registered via the new registration functions re-frame.core/reg-event-fx and re-frame.core/reg-event-ctx re-frame.core/register-sub has been renamed re-frame.core/reg-sub-raw . This is to indicate that this kind of registration is now considered the low level, close to the metal way to create subscriptions handlers. This release introduced reg-sub which becomes the preferred way to register subscription handlers. middlewares have been replaced by Interceptors. In day to day use, there's a good chance you won't notice the change UNLESS: You have written your own middleware. If so, you'll have to rewrite it. See how the builtin interceptors are done . You explicitly use comp to compose middleware like this: clj (reg-event-db :some-id (comp debug tim-v) ;; <-- change to [debug trim-v] (fn [db event] ...)) if you have previously used the undo/redo capabilities buried in re-frame, be aware they have extracted into a sibling library: https://github.com/day8/re-frame-undo. By default, re-frame uses js/console functions like error and warn when logging, but you can supply alternative functions using re-frame.core/set-loggers! . With this release, any alternatives you supply will be called with different parameters. Previously loggers were called with a single str parameter but now they are expected to act like console.log itself and take variadic, non string params. Sorry to break things, but we are trying to maximise use of cljs-devtools and information is lost when strings are output, instead of actual data. Of course, you need only worry about this if you are using re-frame.core/set-loggers! to hook in your own loggers. If you are, then, to transition, you'll need to tweak like this: ``` ;; your old log function might have looked like this. Single string parameter. (defn my-logger [s] (do-something-with s)) ;; your new version will have variadic params, and turn them into a string (defn my-logger [& args] (do-something-with (apply str args)) ``` Improvements Bug fix: post-event-callbacks were not called when dispatch-sync was called. added new API re-frame.core/clear-post-event-callback which de-registers a callback previously added by re-frame.core/add-post-event-callback when an event-handler makes no change to app-db , the debug middleware now logs a single line saying so, rather than a \"group\". Makes it slightly easier to grok the absence of change. Standardised test namespaces: renamed to use -test suffix and moved to eliminate redundant /test folder Added cljs.test based tests via browser/html. These mimic original karma tests. NOTE: previous lein aliases once and auto have been replaced by test-once , test-auto & karma-once see CONTRIBUTING.md 0.7.0 (2016-03-14) \u00b6 Breaking: - removed middleware log-ex . It is no longer needed because browsers now correctly report the throw site of re-thrown exceptions. In the unlikely event that you absolutely still need it, the source for log-ex is still in middleware.cljs , commented out. Just transfer it to your project. debug middleware now produces slightly different output (to console). So no code will need to change, just your expectations of what you see in console. Previously all console output from an event handler was put into the one console group, which could lead to exceptions being hidden (down in a closed group). Improvements: - added one tick of extra pause when events have :flush-dom metadata. Previously, there were odd times when the pause wasn't long enough to ensure redraws. - now compatible with Reagent 0.6.0 (but this not fully tested) while remaining backwards compatible with Reagent v0.5.1 - #138 Switch to using CircleCI and automated testing with Karma Fixed: - #149 Undo now discards oldest undo states, not the newest ones.","title":2016},{"location":"releases/2016/#_1","text":"","title":""},{"location":"releases/2016/#091-20161220","text":"","title":"0.9.1 (2016.12.20)"},{"location":"releases/2016/#090-20161215-the-dolores-release","text":"Welcome, board members. Dr Ford has created a new 6-part narrative , and Bernard some infographics . Anyone seen Dolores?","title":"0.9.0 (2016.12.15) - The Dolores Release"},{"location":"releases/2016/#080-20160819-the-walnuts-release","text":"Staying on the leading edge of new buzzwords is obviously critical for any framework. Angular's terrifying faceplant is a sobering reminder to us all. With this release, re-frame's already impressive buzzword muscles bulge further with new walnuts like \"effects\", \"coeffects\", \"interceptors\" and \"de-duplicated signal graph\". I know, right? Some may even find these new features useful. Joking aside, this is a substantial release which will change how you use re-frame.","title":"0.8.0  (2016.08.19) - The Walnuts Release"},{"location":"releases/2016/#070-2016-03-14","text":"Breaking: - removed middleware log-ex . It is no longer needed because browsers now correctly report the throw site of re-thrown exceptions. In the unlikely event that you absolutely still need it, the source for log-ex is still in middleware.cljs , commented out. Just transfer it to your project. debug middleware now produces slightly different output (to console). So no code will need to change, just your expectations of what you see in console. Previously all console output from an event handler was put into the one console group, which could lead to exceptions being hidden (down in a closed group). Improvements: - added one tick of extra pause when events have :flush-dom metadata. Previously, there were odd times when the pause wasn't long enough to ensure redraws. - now compatible with Reagent 0.6.0 (but this not fully tested) while remaining backwards compatible with Reagent v0.5.1 - #138 Switch to using CircleCI and automated testing with Karma Fixed: - #149 Undo now discards oldest undo states, not the newest ones.","title":"0.7.0  (2016-03-14)"},{"location":"releases/2017/","text":"\u00b6 0.10.2 (2017.10.07) \u00b6 New Features On dispose callbacks now run on JVM re-frame. #386 . Log warnings when tracing is not enabled and you try to add a trace callback #395 . New Docs added a new FAQ entry How do I turn on/off polling a database every 60 secs (hint: effects) added a new FAQ entry How do I do full-stack re-frame? Added a gitbook for re-frame docs #414 . Lots of spelling fixes, for which we are eternally grateful. 0.10.1 (2017.08.17) \u00b6 fix a showstopper bug introduced at the last minute in v0.10.0 0.10.0 (2017.08.16) \u00b6 New Docs added API documentation added testing docs added a new mental model added a new FAQ entry on dispatch processing added a new FAQ entry on representing normalised data in app-db added a new FAQ entry on how to register a global interceptor Breaking #357 I'd be amazed if this actually broke any apps. Shocked! But, better safe than sorry. The effect handler for :db has changed: if the new value provided tests identical? to the existing value within app-db , then app-db is not reset! . Previously, app-db was always reset! irrespective, which potentially caused Layer 2 subscriptions to run unnecessarily. So this is a tiny efficiency change in this edge case, and it results in behaviour that better matches programmer intuitions. Minor Fixes and Improvements #400 Improve error message when a registered cofx can't be found The effect handler for :dispatch-n will now ignore nils . See checkin #340 #341 Fix re-frame.core/on-changes to work even if event handler does not set :db . #395 Warn users if they try to enable tracing without setting the closure define re-frame.trace.trace-enabled? . 0.9.4 (2017.06.01) \u00b6 Improvements added a CITATION.md file re-frame now supports self-hosted ClojureScript at an alpha/unofficial/experimental level. It may be removed in the future if it causes problems elsewhere. #325 0.9.3 (2017.05.15) \u00b6 Breaking (previously undefined behaviour) reg-sub enforces using :<- to indicate subscription inputs. Previously any keyword would have worked here. While using anything other than :<- was undefined behaviour previously, this could possibly break some code when upgrading. Thanks to @Sohalt #336 . Fixes re-frame.interceptor/update-coeffect has been fixed. #328 Fix ns form in re-frame.interceptor . Thanks to @ggeoffrey . #338 Even more spelling fixes. 0.9.2 (2017.02.09) \u00b6 Improvements Update dependency on reagent from 0.6.0-rc to 0.6.0 . A truckload of tweaks, spelling fixes, and general improvements to the docs. A big thanks to everyone who contributed! Fixes Use :devDependencies instead of :dependencies for the lein-npm Karma dependencies. This stops consumers of re-frame with the lein-npm plugin from having to install Karma and friends. Correct :id of on-changes interceptor from :enrich to :on-changes","title":2017},{"location":"releases/2017/#_1","text":"","title":""},{"location":"releases/2017/#0102-20171007","text":"","title":"0.10.2  (2017.10.07)"},{"location":"releases/2017/#0101-20170817","text":"fix a showstopper bug introduced at the last minute in v0.10.0","title":"0.10.1  (2017.08.17)"},{"location":"releases/2017/#0100-20170816","text":"","title":"0.10.0  (2017.08.16)"},{"location":"releases/2017/#094-20170601","text":"","title":"0.9.4 (2017.06.01)"},{"location":"releases/2017/#093-20170515","text":"","title":"0.9.3 (2017.05.15)"},{"location":"releases/2017/#092-20170209","text":"","title":"0.9.2 (2017.02.09)"},{"location":"releases/2018/","text":"\u00b6 0.10.6 (2018-09-03) \u00b6 Fixed After interceptor now runs against effect db if effect db is nil/false. #447 The effect handler for :dispatch-later will now ignore nils . #455 Add locking to the EventQueue when running under JVM to avoid race conditions and subtle errors when dispatching lots of events. #471 0.10.5 (2018.02.13) \u00b6 Changed Event handlers and fx are now traced, to provide more granular timing info in re-frame-trace. This has no impact on your code execution if you haven't enabled tracing . 0.10.4 (2018.01.31) \u00b6 Changed Interceptors, effects, and coeffects are now captured in re-frame's tracing. 0.10.3 (2018.01.24) \u00b6 New add purge-event-queue to the API. See https://github.com/day8/re-frame-test/issues/13 for motivation. added a new FAQ entry Reagent looks terrific. Why do I need re-frame? added a new Infographic explaining how dominoes play out over time in the browser Changed Debounce trace callbacks to handle larger batches of traces at once, to improve efficiency. Improved error messages to not have multiple spaces before variables. Fixed Handle js/performance not being defined in NodeJS. #439 Improve cache eviction behaviour of subscription caches. In more complex applications a subscription may have been unnecessarily created and destroyed several times after a Figwheel re-render.","title":2018},{"location":"releases/2018/#_1","text":"","title":""},{"location":"releases/2018/#0106-2018-09-03","text":"","title":"0.10.6 (2018-09-03)"},{"location":"releases/2018/#0105-20180213","text":"","title":"0.10.5 (2018.02.13)"},{"location":"releases/2018/#0104-20180131","text":"","title":"0.10.4 (2018.01.31)"},{"location":"releases/2018/#0103-20180124","text":"","title":"0.10.3 (2018.01.24)"},{"location":"releases/2019/","text":"\u00b6 0.11.0-rc3 (2019-11-20) \u00b6 Changed Upgrade reagent to 0.9.0-rc3. Report issues here . Update examples/simple/CodeWalkThrough.md Upgrade shadow-cljs to 2.8.69 Migrate to GitHub Actions 0.11.0-rc2 (2019-10-19) \u00b6 Changed Upgrade shadow-cljs to 2.8.64 Upgrade karma to 4.4.1 Upgrade reagent to 0.9.0-rc2. Report issues here . 0.11.0-rc1 (2019-09-11) \u00b6 Changed Upgrade reagent to 0.9.0-rc1. Report issues here . Removed Remove direct dependency on react and react-dom as these are now provided by reagent. Remove dependency on create-react-class as it is obsolete. 0.10.9 (2019-08-22) \u00b6 Changes Migrate to shadow-cljs and lein-shadow Bring deps.edn into parity with project.clj 0.10.8 (2019-07-15) \u00b6 Changes Revert after and enrich interceptors to the behaviour in version 0.10.6 and earlier; i.e. reverts breaking changes in 0.10.7. 0.10.7 (2019-06-24) \u00b6 BREAKING CHANGES after and enrich interceptors now no longer run if there is no db effect, rather than running against the db coffect. #453 New add update-effect #440 Fixed #512 Error with infer-externs \"goog is not defined in the externs\" Improvements Update dependency on reagent from 0.7.0 to 0.8.1 . Update dependency on karma from 4.0.0 to 4.1.0 . Update dependency on Clojure from 1.8.0 to 1.10.1 . Update dependency on ClojureScript from 1.10.439 to 1.10.520 .","title":2019},{"location":"releases/2019/#_1","text":"","title":""},{"location":"releases/2019/#0110-rc3-2019-11-20","text":"","title":"0.11.0-rc3 (2019-11-20)"},{"location":"releases/2019/#0110-rc2-2019-10-19","text":"","title":"0.11.0-rc2 (2019-10-19)"},{"location":"releases/2019/#0110-rc1-2019-09-11","text":"","title":"0.11.0-rc1 (2019-09-11)"},{"location":"releases/2019/#0109-2019-08-22","text":"","title":"0.10.9 (2019-08-22)"},{"location":"releases/2019/#0108-2019-07-15","text":"","title":"0.10.8 (2019-07-15)"},{"location":"releases/2019/#0107-2019-06-24","text":"","title":"0.10.7 (2019-06-24)"},{"location":"releases/2020/","text":"\u00b6 The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein. 1.1.2 (2020-11-11) \u00b6 Added Add a new interceptor called unwrap . It decreases the amount of destructuring necessary in an event handler where the event is structured as a 2-vector of [event-id payload-map] . Implemented as the outcome of #644 . Changed The :coeffects map (within context ) will now contain a new key called :original-event which has as its value the original event dispatched, prior to any modification by interceptors such as trim-v and unwrap . To this another way, the coeffects map will have BOTH an :event and an :original-event key, which will reference the original event dispatched UNLESS interceptors have modified :event The trim-v interceptor now produces a warning if event is not a vector. Just in case someone has mixed the use of trim-v and unwrap together. The trim-v interceptor will not modify an event if it is not a vector. Breaking Previously, the trim-v interceptor stored the original event (prior to any modification) within coeffects using the key :re-frame.std-interceptors/untrimmed-event . But, now, trim-v no longer does this. Any code relying on this implementation detail will now break. Instead, you should access the event stored in the :original-event key, as described above. Fixed Fix reg-global-interceptor code reloading by replacing interceptors with duplicate ids in place to maintain the ordering of global interceptors. Previously would result in the interceptor actually being duplicated. See #655 Fix event handlers passing events modified by interceptors to tracing, instead all event handlers now use :original-event for tracing. 1.1.1 (2020-08-26) \u00b6 Added The built-in effect :dispatch-later can now take a single map value. Supplying a sequence of maps is now deprecated in favour of using multiple :dispatch-later effects within the new :fx effect. See the API documentation . 1.1.0 (2020-08-24) \u00b6 Added re-frame now guarantees that a :db effect, if present, will be actioned before any other sibling effects. re-frame continues to provide no guarantees about the order in which other effects will be actioned. Added an new :fx built-in effect handler. Previously, you might have returned effects like this: 1 2 3 4 5 6 7 8 9 ( reg-event-fx :token ( fn [{ :keys [ db ]} [ _ id ]] { :db ( assoc db :twirly true ) :dispatch [ :blah ] :full-screen true :http ( list { :method :GET :url \"http://abc.com/endpoint\" ... } { :method :POST :url \"http://blah.com/endpoint\" ... })})) but now, using :fx : 1 2 3 4 5 6 7 8 9 10 ( reg-event-fx :token ( fn [{ :keys [ db ]} [ _ id ]] { :db ( assoc db :twirly true ) :fx [ [ :dispatch [ :blah ]] [ :full-screen true ] [ :http { :method :GET :url \"http://abc.com/endpoint\" ... }] [ :http { :method :POST :url \"http://blah.com/endpoint\" ... }] ( when seventies? [ :hair \"side burns\" ])] ;; nils are ignored Notes: the effect :fx will be associated with a seq , typically a vector the effects in :fx will be actioned in seq order each element in the seq should be a 2-vector . This vector will contain an effect-id, typically a keyword, and an effect payload. if any element of :fx is nil, it will be ignored. This allows effects to be conditionally included via a when (an example is given above) :db effects should not be put into :fx . re-frame will emit a warning if it finds one. Benefits: :fx allows for effects to be ordered you can include the same kind of effect multiple times (eg :dispatch ) which means there is no longer any need for special effects like :dispatch-n . Indeed, all *-n style effects are now redundant. this feature is a stepping stone towards making it easier to create an event handler which is a composition of other functions. We imagine circumstances in the future in which event handlers might be written more like this: #!clj (reg-event-xxxx ;; <-- a new kind of registration function :event-id interceptors [function1 function2 function3]) See exploratory discussion here and here This new effect is described in the API docs . Further discussion on its introduction can be found in issue #639 . Changed if your reg-event-fx handler returns an effect map containing an unknown effect key, re-frame will now produce a warning, not a hard error. See #639 . 1.0.0 (2020-07-20) \u00b6 No changes since 1.0.0-rc6. Final 1.0.0 release. 1.0.0-rc6 (2020-07-06) \u00b6 Fixed Handle exception in interop/on-load when in an environment that does not support goog.events/listen (e.g. React Native). See #604 . 1.0.0-rc5 (2020-07-04) \u00b6 Changed Revert changes in 1.0.0-rc4 as 'fixed' bug was a false positive. 1.0.0-rc4 (2020-07-04) \u00b6 Changed ~Change impl of execution of global interceptor functions in attempt to fix supposed order execution bug that later turned out to be a false positive.~ 1.0.0-rc3 (2020-05-27) \u00b6 Changed Upgrade binaryage/devtools to 1.0.2 Fixed Fix ReferenceError exception in Web Worker. See #614 and #615 . Might also fix use in React Native. See #604 . 1.0.0-rc2 (2020-05-23) \u00b6 Fixed Fix cljdoc config ( doc/cljdoc.edn ) with updated docs/ structure. 1.0.0-rc1 (2020-05-16) \u00b6 Added Add support for cljs-oss/canary builds. See #478 . Add global interceptors. See #570 . Add cljdoc config. See #592 Add missing docstrings to re-frame.core cs. See #588 Fixed Fix documentation for re-frame.core ns. See #456 and #216 Fix excessive overwriting handler warnings. See #204 . Consistently use (co)effect helpers. See #548 . Thanks to @mbertheau . Fix use of deprecated reagent/render for reagent.dom/render. See #577 . Thanks to @pathammer Fix support for layer 3 subscriptions in clj environment. See #541 . Thanks to @dawran6 . Fix infer externs warnings. See #591 . Changed Change sample apps to use source files from the repo checkout instead of re-frame release artifacts. Upgrade shadow-cljs to 2.8.110 Upgrade lein-shadow to 0.2.0 Upgrade ClojureScript to 1.10.764 Removed Remove doctoc. See #581 Remove GitBook. See #580 0.12.0 (2020-03-08) \u00b6 Changed Upgrade reagent to 0.10.0 . Important: If using re-frame-10x you need to upgrade to 0.6.0. If using re-com you need to upgrade to 2.8.0. 0.11.0 (2020-01-20) \u00b6 Everything in 0.11.0-rc1 to 0.11.0-rc4 or in other words the same as 0.11.0-rc4. 0.11.0-rc4 (2020-01-16) \u00b6 Changed Upgrade reagent to 0.9.1 Clarify debug interceptor log message. See #546 . Thanks to @mbertheau Refactoring of fx-handler->interceptor . See #547 . Thanks to @mbertheau Upgrade shadow-cljs to 2.8.83 Upgrade ClojureScript to 1.10.597 Upgrade lein-git-inject to 0.0.11 Added :debug log level. See #562 . Thanks to @p-himik","title":2020},{"location":"releases/2020/#_1","text":"The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein.","title":""},{"location":"releases/2020/#112-2020-11-11","text":"","title":"1.1.2 (2020-11-11)"},{"location":"releases/2020/#111-2020-08-26","text":"","title":"1.1.1 (2020-08-26)"},{"location":"releases/2020/#110-2020-08-24","text":"","title":"1.1.0 (2020-08-24)"},{"location":"releases/2020/#100-2020-07-20","text":"No changes since 1.0.0-rc6. Final 1.0.0 release.","title":"1.0.0 (2020-07-20)"},{"location":"releases/2020/#100-rc6-2020-07-06","text":"","title":"1.0.0-rc6 (2020-07-06)"},{"location":"releases/2020/#100-rc5-2020-07-04","text":"","title":"1.0.0-rc5 (2020-07-04)"},{"location":"releases/2020/#100-rc4-2020-07-04","text":"","title":"1.0.0-rc4 (2020-07-04)"},{"location":"releases/2020/#100-rc3-2020-05-27","text":"","title":"1.0.0-rc3 (2020-05-27)"},{"location":"releases/2020/#100-rc2-2020-05-23","text":"","title":"1.0.0-rc2 (2020-05-23)"},{"location":"releases/2020/#100-rc1-2020-05-16","text":"","title":"1.0.0-rc1 (2020-05-16)"},{"location":"releases/2020/#0120-2020-03-08","text":"","title":"0.12.0 (2020-03-08)"},{"location":"releases/2020/#0110-2020-01-20","text":"Everything in 0.11.0-rc1 to 0.11.0-rc4 or in other words the same as 0.11.0-rc4.","title":"0.11.0 (2020-01-20)"},{"location":"releases/2020/#0110-rc4-2020-01-16","text":"","title":"0.11.0-rc4 (2020-01-16)"},{"location":"releases/2021/","text":"1.2.0 (2021-02-25) \u00b6 Changed Upgrade to reagent 1.0.0 which includes React 17.0.1 . Note: also upgrade re-frame-10x to v1.0.0 when making the transition. Upgrade clojure.tools.logging to 1.1.0","title":2021},{"location":"releases/2021/#120-2021-02-25","text":"","title":"1.2.0 (2021-02-25)"},{"location":"releases/2022/","text":"\u00b6 The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein. 1.3.0 (2022-08-27) \u00b6 1.3.0-rc3 has been re-tagged as 1.3.0 final. rc3 (2022-03-04) \u00b6 Added Warn user when calling subscribe outside of reactive context. See #740 . Thanks to @dannyfreeman . Allow enrich to return nil . See #751 . Thanks to @NoahTheDuke . rc2 (2021-12-22) \u00b6 Fixed Fix some docs re recent reg-sub additions. Thanks to @eval . rc1 (2021-12-20) \u00b6 Added Syntactic sugar for trivial reg-sub declarations. See #634 . Thanks to @bsboiko . Changed Change nil :fx value to :warn instead of :error console log","title":2022},{"location":"releases/2022/#_1","text":"The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein.","title":""},{"location":"releases/2022/#130-2022-08-27","text":"1.3.0-rc3 has been re-tagged as 1.3.0 final.","title":"1.3.0 (2022-08-27)"},{"location":"releases/2022/#rc3-2022-03-04","text":"","title":"rc3 (2022-03-04)"},{"location":"releases/2022/#rc2-2021-12-22","text":"","title":"rc2 (2021-12-22)"},{"location":"releases/2022/#rc1-2021-12-20","text":"","title":"rc1 (2021-12-20)"},{"location":"releases/2023/","text":"\u00b6 The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein. Unreleased \u00b6 Committed but unreleased changes are put here, at the top. Older releases are detailed chronologically below. Breaking re-frame.std-interceptors/path now keeps a :re-frame.db/path-history key in the context, not a :re-frame-path/db-store key. This shouldn't affect users, unless you're directly hacking the event loop. 763 on detecting an incorrect event structure, the unwrap interceptor now exceptions instead of writing an error to js/console and continuing. Added Interceptors now have an optional :comment key. It's a no-op. re-frame.std-interceptors/path now remembers the path it uses in a :comment . ((re-frame-10x#165)[https://github.com/day8/re-frame-10x/issues/165])","title":2023},{"location":"releases/2023/#_1","text":"The re-frame Clojars page contains dependency coordinates for Maven/deps/Lein.","title":""},{"location":"releases/2023/#unreleased","text":"Committed but unreleased changes are put here, at the top. Older releases are detailed chronologically below.","title":"Unreleased"}]}